# 常用方法或对象

## 内置函数

dart

```dart
```

go

```go
```

js

```js
```

python

```sh
abs()	delattr()	hash()	memoryview()	set()
all()	dict()	help()	min()	setattr()
any()	dir()	hex()	next()	slice()
ascii()	divmod()	id()	object()	sorted()
bin()	enumerate()	input()	oct()	staticmethod()
bool()	eval()	int()	open()	str()
breakpoint()	exec()	isinstance()	ord()	sum()
bytearray()	filter()	issubclass()	pow()	super()
bytes()	float()	iter()	print()	tuple()
callable()	format()	len()	property()	type()
chr()	frozenset()	list()	range()	vars()
classmethod()	getattr()	locals()	repr()	zip()
compile()	globals()	map()	reversed()	__import__()
complex()	hasattr()	max()	round()
```

```python
```

## Encoding and decoding fully qualified URIs（编码解码URI）

dart

要编码和解码除了 URI 中特殊意义（例如 /, :, &, #）的字符，
则可以使用 encodeFull() 和 decodeFull() 函数。
这两个函数可以用来编码和解码整个 URI，并且保留 URI 特殊意义的字符不变。

```dart
var uri = 'http://example.org/api?foo=some message';

var encoded = Uri.encodeFull(uri);
assert(encoded == 'http://example.org/api?foo=some%20message');
// 注意上面 some 和 message 之间的空格被编码了。

var decoded = Uri.decodeFull(encoded);
assert(uri == decoded);
```

go

```go
```

js

`encodeURI()`  函数通过将特定字符的每个实例替换为一个、两个、三或四转义序列
来对统一资源标识符 (URI) 进行编码 (该字符的 UTF-8 编码仅为四转义序列)由两个 "代理" 字符组成)。

encodeURI 会替换所有的字符，但不包括以下字符

- 保留字符	; , / ? : @ & = + $
- 非转义的字符	字母 数字 - _ . ! ~ * ' ( )
- 数字符号	#

`decodeURI()` 函数解码一个由encodeURI 先前创建的统一资源标识符（URI）或类似的例程。

```js
var uri = 'http://example.org/api?foo=some message';
encodeURI(uri) // 'http://example.org/api?foo=some%20message'
decodeURI(encodeURI(uri)) // 'http://example.org/api?foo=some message'
```

python

```python
```

## Encoding and decoding URI components（编码解码URI组件）

dart

使用 encodeComponent() 和 decodeComponent() 可以编码 和解码 URI 中的所有字符，
特殊意义的字符（/, &, 和 : 等） 也会编码，

```dart
var uri = 'http://example.org/api?foo=some message';

var encoded = Uri.encodeComponent(uri);
assert(encoded == 'http%3A%2F%2Fexample.org%2Fapi%3Ffoo%3Dsome%20message');
// 注意上面特殊字符也被编码了，比如 / 编码为 %2F。

var decoded = Uri.decodeComponent(encoded);
assert(uri == decoded);
```

go

```go
```

js

`encodeURIComponent()`是对统一资源标识符（URI）的组成部分进行编码的方法。
它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码
（只有由两个Unicode代理区字符组成的字符才用四个转义字符编码）。

encodeURIComponent 转义除了字母、数字、(、)、.、!、~、*、'、-和_之外的所有字符。

`decodeURIComponent()` 方法用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI）。

```js
var uri = 'http://example.org/api?foo=some message';
encodeURIComponent(uri) // 'http%3A%2F%2Fexample.org%2Fapi%3Ffoo%3Dsome%20message'
decodeURIComponent(encodeURIComponent(uri)) // 'http://example.org/api?foo=some message'
```

python

```python
```

## Parsing URIs

```sh
┌────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                              href                                              │
├──────────┬──┬─────────────────────┬────────────────────────┬───────────────────────────┬───────┤
│ protocol │  │        auth         │          host          │           path            │ hash  │
│          │  │                     ├─────────────────┬──────┼──────────┬────────────────┤       │
│          │  │                     │    hostname     │ port │ pathname │     search     │       │
│          │  │                     │                 │      │          ├─┬──────────────┤       │
│          │  │                     │                 │      │          │ │    query     │       │
"  https:   //    user   :   pass   @ sub.example.com : 8080   /p/a/t/h  ?  query=string   #hash "
│          │  │          │          │    hostname     │ port │          │                │       │
│          │  │          │          ├─────────────────┴──────┤          │                │       │
│ protocol │  │ username │ password │          host          │          │                │       │
├──────────┴──┼──────────┴──────────┼────────────────────────┤          │                │       │
│   origin    │                     │         origin         │ pathname │     search     │ hash  │
├─────────────┴─────────────────────┴────────────────────────┴──────────┴────────────────┴───────┤
│                                              href                                              │
└────────────────────────────────────────────────────────────────────────────────────────────────┘
```

dart

如果有个 Uri 对象或者 URI 字符串，使用 Uri 的属性 可以获取每个部分，比如 path。
使用 parse() 静态 函数可以从字符串中解析一个 Uri 对象：

```dart
var uri = Uri.parse('http://example.org:8080/foo/bar#frag');

assert(uri.scheme   == 'http');
assert(uri.host     == 'example.org');
assert(uri.path     == '/foo/bar');
assert(uri.fragment == 'frag');
assert(uri.origin   == 'http://example.org:8080');
```

go

```go
```

js

new URL(input[, base])

```js
// 使用 WHATWG 的 API 解析 URL 字符串：
const myURL = new URL('https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash');

// 使用遗留的 API 解析 URL 字符串：
const url = require('url');
const myURL = url.parse('https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash');

// 可以将 true 作为第二个参数传递给 require('url').parse
require('url').parse('/status?name=ryan', true)

const { URL } = require('url');
const myURL = new URL('/foo', 'https://example.org/'); // https://example.org/foo


// URLSearchParams
const { URL, URLSearchParams } = require('url');

const myURL = new URL('https://example.org/?abc=123');
console.log(myURL.searchParams.get('abc'));
// 输出 123

myURL.searchParams.append('abc', 'xyz');
console.log(myURL.href);
// 输出 https://example.org/?abc=123&abc=xyz

myURL.searchParams.delete('abc');
myURL.searchParams.set('a', 'b');
console.log(myURL.href);
// 输出 https://example.org/?a=b


const { URLSearchParams } = require('url');
const params = new URLSearchParams({
  user: 'abc',
  query: ['first', 'second']
});
console.log(params.getAll('query'));
  // 输出 [ 'first,second' ]
console.log(params.toString());
  // 输出 'user=abc&query=first%2Csecond'
```

python

```python
```

## Building URIs

dart

使用 Uri() 构造函数可以从 URI 的 各个部分来构造一个 Uri 对象：

```dart
var uri = new Uri(scheme: 'http', host: 'example.org',
                  path: '/foo/bar', fragment: 'frag');
assert(uri.toString() ==
    'http://example.org/foo/bar#frag');
```

go

```go
```

js

```js
// 使用 WHATWG 的 API 解析 URL 字符串：
const myURL = new URL('https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash');

// 使用遗留的 API 解析 URL 字符串：
const url = require('url');
const myURL = url.parse('https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash');

const { URL } = require('url');
const myURL = new URL('/foo', 'https://example.org/'); // https://example.org/foo
```

python

```python
```

## Dates and times 日期和时间

dart

DateTime 对象代表某个时刻。时区是 UTC 或者 本地时区。
一些构造函数可以创建 DateTime 对象：

使用 Duration 来在 DateTime 对象上前后移动数天可能会有问题，
比如像夏令时等时间问题。如果要按照天数来位移时间，则 需要使用 UTC 日期。

```dart
// Get the current date and time.
var now = new DateTime.now();

// Create a new DateTime with the local time zone.
var y2k = new DateTime(2000);   // January 1, 2000

// Specify the month and day.
y2k = new DateTime(2000, 1, 2); // January 2, 2000

// Specify the date as a UTC time.
y2k = new DateTime.utc(2000);   // 1/1/2000, UTC

// Specify a date and time in ms since the Unix epoch.
y2k = new DateTime.fromMillisecondsSinceEpoch(
    946684800000, isUtc: true);

// Parse an ISO 8601 date.
y2k = DateTime.parse('2000-01-01T00:00:00Z');


// millisecondsSinceEpoch 属性
// 返回自从 “Unix epoch”—January 1, 1970, UTC 以来的毫秒数值：
// 1/1/2000, UTC
y2k = new DateTime.utc(2000);
assert(y2k.millisecondsSinceEpoch == 946684800000);

// 1/1/1970, UTC
var unixEpoch = new DateTime.utc(1970);
assert(unixEpoch.millisecondsSinceEpoch == 0);


// 使用 Duration 类可以计算两个日期之间的间隔， 还可以前后位移日期：
var y2k = new DateTime.utc(2000);

// Add one year.
var y2001 = y2k.add(const Duration(days: 366));
assert(y2001.year == 2001);

// Subtract 30 days.
var december2000 = y2001.subtract(
    const Duration(days: 30));
assert(december2000.year == 2000);
assert(december2000.month == 12);

// Calculate the difference between two dates.
// Returns a Duration object.
var duration = y2001.difference(y2k);
assert(duration.inDays == 366); // y2k was a leap year.
```

go

```go
```

js

注意，月份从0开始计算，但是，天数从1开始计算。
另外，除了日期的默认值为1，小时、分钟、秒钟和毫秒的默认值都是0

Date的实例对象，有几十个自己的方法，除了valueOf和toString，可以分为以下三类。

- to类：从Date对象返回一个字符串，表示指定的时间。
- get类：获取Date对象的日期和时间。
- set类：设置Date对象的日期和时间。

```js
// Date对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。
Date()

// 如果不加参数，实例代表的就是当前时间。
var today = new Date();

// 参数为时间零点开始计算的毫秒数
new Date(1378218728000)
// Tue Sep 03 2013 22:32:08 GMT+0800 (CST)

// 参数为日期字符串
new Date('January 6, 2013');
// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)

// 参数为多个整数，
// 代表年、月、日、小时、分钟、秒、毫秒
new Date(2013, 0, 1, 0, 0, 0, 0)
// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)

// 第一点，参数可以是负整数，代表1970年元旦之前的时间。
// 第二点，只要是能被Date.parse()方法解析的字符串，都可以当作参数。
new Date(-1378218728000)
// Fri Apr 30 1926 17:27:52 GMT+0800 (CST)
new Date('2013-2-15')
new Date('2013/2/15')
new Date('02/15/2013')
new Date('2013-FEB-15')
new Date('FEB, 15, 2013')
new Date('FEB 15, 2013')
new Date('February, 15, 2013')
new Date('February 15, 2013')
new Date('15 Feb 2013')
new Date('15, February, 2013')
// Fri Feb 15 2013 00:00:00 GMT+0800 (CST)

// 如果月设为15，就折算为下一年的4月。
// 日期设为0，就代表上个月的最后一天。
new Date(2013, 15)
// Tue Apr 01 2014 00:00:00 GMT+0800 (CST)
new Date(2013, 0, 0)
// Mon Dec 31 2012 00:00:00 GMT+0800 (CST)

// 两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；
// 进行加法运算时，返回的是两个字符串连接而成的新字符串。
var d1 = new Date(2000, 2, 1);
var d2 = new Date(2000, 3, 1);
d2 - d1
// 2678400000
d2 + d1
// "Sat Apr 01 2000 00:00:00 GMT+0800 (CST)Wed Mar 01 2000 00:00:00 GMT+0800 (CST)"


// Date.now方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，
// 相当于 Unix 时间戳乘以1000。
Date.now() // 1364026285194


// Date.parse方法用来解析日期字符串，返回距离1970年1月1日 00:00:00的毫秒数。
// 如果解析失败，返回NaN
// 日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式
Date.parse('Aug 9, 1995')
Date.parse('January 26, 2011 13:51:50')
Date.parse('Mon, 25 Dec 1995 13:30:00 GMT')
Date.parse('Mon, 25 Dec 1995 13:30:00 +0430')
Date.parse('2011-10-10')
Date.parse('2011-10-10T14:48:00')


// Date.UTC方法接受年、月、日等变量作为参数，
// 返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。
// 格式
Date.UTC(year, month[, date[, hrs[, min[, sec[, ms]]]]])
// 用法
Date.UTC(2011, 0, 1, 2, 3, 4, 567)
// 1293847384567
```

python

```sh
>>> # dates are easily constructed and formatted
>>> from datetime import date
>>> now = date.today()
>>> now
datetime.date(2003, 12, 2)
>>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")
'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'

>>> # dates support calendar arithmetic
>>> birthday = date(1964, 7, 31)
>>> age = now - birthday
>>> age.days
14368
```

## Comparing objects（比较对象）

dart

实现 Comparable 接口表明该对象可以相互比较，通常用来 排序。

- compareTo() 函数对于 小于的值返回 < 0 ；
- 相同的值返回 0 ；
- 大于的值返回 > 0

```dart
class Line implements Comparable { // 隐式接口
  final length;
  const Line(this.length);
  int compareTo(Line other) => length - other.length;
}

main() {
  var short = const Line(1);
  var long = const Line(100);
  assert(short.compareTo(long) < 0);
}
```

go

```go
```

js

```js
```

python

```python
```

## Finding elements

dart

```dart
import 'dart:html';

// Find an element by id (an-id).
Element elem1 = querySelector('#an-id');

// Find an element by class (a-class).
Element elem2 = querySelector('.a-class');

// Find all elements by tag (<div>).
List<Element> elems1 = querySelectorAll('div');

// Find all text inputs.
  List<Element> elems2 =
      querySelectorAll('input[type="text"]');

// Find all elements with the CSS class 'class'
// inside of a <p> that is inside an element with
// the ID 'id'.
List<Element> elems3 = querySelectorAll('#id p.class');
```

go

```go
```

js

```js
```

python

```python
```

## Manipulating elements

dart

```html
<!-- In HTML: -->
<a id="example" href="http://example.com">link text</a>
<p>
  <span class="linux">Words for Linux</span>
  <span class="macos">Words for Mac</span>
  <span class="windows">Words for Windows</span>
</p>
```

```dart
// In Dart:
querySelector('#example').href = 'http://dartlang.org';

final osList = ['macos', 'windows', 'linux'];

// In real code you'd programmatically determine userOs.
var userOs = 'linux';

for (var os in osList) { // For each possible OS...
  bool shouldShow = (os == userOs); // Matches user OS?

  // Find all elements with class=os. For example, if
  // os == 'windows', call querySelectorAll('.windows')
  // to find all elements with the class "windows".
  // Note that '.$os' uses string interpolation.
  for (var elem in querySelectorAll('.$os')) {
    elem.hidden = !shouldShow; // Show or hide.
  }
}

elem.attributes['someAttribute'] = 'someValue';
```

go

```go
```

js

```js
```

python

```python
```

## Creating elements

dart

```dart
var elem = new ParagraphElement();
elem.text = 'Creating is easy!';
var elem2 = new Element.html('<p>Creating <em>is</em> easy!</p>');
document.body.children.add(elem2);
```

go

```go
```

js

```js
```

python

```python
```

## Adding, replacing, and removing nodes

dart

element 也是 node 的一种。
使用 Node 的 nodes 属性可以 获取到当前 node 的所有子元素，
nodes 返回的是 `List<Node>` ( children 属性只包含 Element 类型的 nodes)。

```dart
// 使用 List 的add() 函数可以把一个 node 添加到所有子元素的 最后：
// Find the parent by ID, and add elem as its last child.
querySelector('#inputs').nodes.add(elem);

// 使用 Node 的 replaceWith() 函数可以替换一个 Node：
// Find a node by ID, and replace it in the DOM.
querySelector('#status').replaceWith(elem);

// 使用 Node 的 remove() 函数来删除 node：
// Find a node by ID, and remove it from the DOM.
querySelector('#expendable').remove();
```

go

```go
```

js

```js
```

python

```python
```

## Manipulating CSS styles

dart

```dart
// 下面的示例中给 element 添加了 warning CSS 类样式。
var element = querySelector('#message');
element.classes.add('warning');

// 通过 id 属性你可以动态给一个 Element 指定 一个 ID 值。
var message = new DivElement();
message.id = 'message2';
message.text = 'Please subscribe to the Dart mailing list.';

// 使用级联调用可以减少 需要编写的代码：
var message = new DivElement()
    ..id = 'message2'
    ..text = 'Please subscribe to the Dart mailing list.';

// 直接使用 style 属性
message.style
    ..fontWeight = 'bold'
    ..fontSize = '3em';
```

go

```go
```

js

```js
```

python

```python
```

## Handling events

dart

一些常见的事件：

- change
- blur
- keyDown
- keyUp
- mouseDown
- mouseUp

```dart
// 处理按钮点击的事件：
// Find a button by ID and add an event handler.
querySelector('#submitInfo').onClick.listen((e) {
  // When the button is clicked, it runs this code.
  submitData();
});

//  通过 e.target 可以获取是哪个 element 触发该事件的：
document.body.onClick.listen((e) {
  var clickedElem = e.target;
  print('You clicked the ${clickedElem.id} element.');
});
```

go

```go
```

js

```js
```

python

```python
```

## Getting data from the server

dart

HttpRequest 的静态函数 getString() 可以很方便的从服务器获取资源。

```dart
import 'dart:html';
import 'dart:async';

// A JSON-formatted file next to this page.
var uri = 'data.json';

main() async {
  // Read a JSON file.
  var data = await HttpRequest.getString(uri);
  processString(data);
}

processString(String jsonText) {
  parseText(jsonText);
}

// 使用 try-catch 来指定异常处理代码：
try {
  data = await HttpRequest.getString(jsonUri);
  processString(data);
} catch (e) {
  handleError(e);
}
// ...
handleError(error) {
  print('Uh oh, there was an error.');
  print(error.toString());
}

// 如果除了返回的文本数据以外你还需要 访问 HttpRequest，你可以使用 request() 静态函数。
// 下面 是一个读取 XML 数据的示例：
import 'dart:html';
import 'dart:async';

// An XML-formatted file next to this page.
var xmlUri = 'data.xml';

main() async {
  // Read an XML file.
  try {
    var data = await HttpRequest.request(xmlUri);
    processRequest(data);
  } catch (e) {
    handleError(e);
  }
}

processRequest(HttpRequest request) {
  var xmlDoc = request.responseXml;
  try {
    var license = xmlDoc.querySelector('license').text;
    print('License: $license');
  } catch (e) {
    print("$xmlUri doesn't have correct XML formatting.");
  }
}

// 下面是使用 HttpRequest full API 的常用流程：
// 1.创建 HttpRequest 对象。
// 2.使用 GET 或者 POST 打开一个 URL。
// 3.添加事件处理器。
// 4.发送请求。
import 'dart:html';
// ...
var request = new HttpRequest()
    ..open('POST', dataUrl)
    ..onLoadEnd.listen((_) => requestComplete(request))
    ..send(encodedData);
```

go

```go
```

js

```js
// 浏览器
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function(){
  // 通信成功时，状态值为4
  if (xhr.readyState === 4){
    if (xhr.status === 200){
      console.log(xhr.responseText);
    } else {
      console.error(xhr.statusText);
    }
  }
};
xhr.onerror = function (e) {
  console.error(xhr.statusText);
};
xhr.open('GET', '/endpoint', true);
xhr.send(null);

// node
const http = require('http');
http.get({
  hostname: 'localhost',
  port: 80,
  path: '/',
  agent: false  // 仅为此一个请求创建一个新代理。
}, (res) => {
  // 用响应做些事情。
});

const http = require('http');
const keepAliveAgent = new http.Agent({ keepAlive: true });
options.agent = keepAliveAgent;
http.request(options, onResponseCallback);

// http.get
const http = require('http');
http.get('http://nodejs.cn/index.json', (res) => {
  const { statusCode } = res;
  const contentType = res.headers['content-type'];

  let error;
  if (statusCode !== 200) {
    error = new Error('请求失败\n' +
                      `状态码: ${statusCode}`);
  } else if (!/^application\/json/.test(contentType)) {
    error = new Error('无效的 content-type.\n' +
                      `期望的是 application/json 但接收到的是 ${contentType}`);
  }
  if (error) {
    console.error(error.message);
    // 消费响应数据来释放内存。
    res.resume();
    return;
  }

  res.setEncoding('utf8');
  let rawData = '';
  res.on('data', (chunk) => { rawData += chunk; });
  res.on('end', () => {
    try {
      const parsedData = JSON.parse(rawData);
      console.log(parsedData);
    } catch (e) {
      console.error(e.message);
    }
  });
}).on('error', (e) => {
  console.error(`出现错误: ${e.message}`);
});
```

python

```python
```

## Sending data to the server

dart

```dart
import 'dart:html';

String encodeMap(Map data) {
  return data.keys.map((k) {
    return '${Uri.encodeComponent(k)}=' +
           '${Uri.encodeComponent(data[k])}';
  }).join('&');
}

loadEnd(HttpRequest request) {
  if (request.status != 200) {
    print('Uh oh, error: ${request.status}');
  } else {
    print('Data has been posted');
  }
}

main() async {
  var dataUrl = '/registrations/create';
  var data = {'dart': 'fun', 'editor': 'productive'};
  var encodedData = encodeMap(data);

  var httpRequest = new HttpRequest();
  httpRequest.open('POST', dataUrl);
  httpRequest.setRequestHeader(
      'Content-type',
      'application/x-www-form-urlencoded');
  httpRequest.send(encodedData);
  await httpRequest.onLoadEnd.first;
  loadEnd(httpRequest);
}
```

go

```go
```

js

```js
// http.request
const http = require('http');

const postData = querystring.stringify({
  'msg': '你好世界'
});
const options = {
  hostname: 'nodejs.cn',
  port: 80,
  path: '/upload',
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded',
    'Content-Length': Buffer.byteLength(postData)
  }
};
const req = http.request(options, (res) => {
  console.log(`状态码: ${res.statusCode}`);
  console.log(`响应头: ${JSON.stringify(res.headers)}`);
  res.setEncoding('utf8');
  res.on('data', (chunk) => {
    console.log(`响应主体: ${chunk}`);
  });
  res.on('end', () => {
    console.log('响应中已无数据');
  });
});
req.on('error', (e) => {
  console.error(`请求遇到问题: ${e.message}`);
});
// 将数据写入请求主体。
req.write(postData);
req.end();
```

python

```python
```

## Sending and receiving real-time data with WebSockets

dart

WebSocket 可以让你的 web 应用和服务器持续的交互数据，不用 一直的轮询。
创建 WebSocket 的服务器会监听 ws:// 开头的 URL， 例如 ws://127.0.0.1:1337/ws。 
通过 WebSocket 发送的数据可以是字符串或者 blob。 通常都是使用 JSON 格式的字符串。

```dart
// 先创建 WebSocket 对象
var ws = new WebSocket('ws://echo.websocket.org');

// 使用 send() 函数向 WebSocket 发送数据：
ws.send('Hello from Dart!');

// 要从 WebSocket 接收数据，需要注册一个事件 监听器：
ws.onMessage.listen((MessageEvent e) {
  print('Received message: ${e.data}');
});

// 处理如下的 WebSocket 事件：open, close, error,
void initWebSocket([int retrySeconds = 2]) {
  var reconnectScheduled = false;

  print("Connecting to websocket");
  ws = new WebSocket('ws://echo.websocket.org');

  void scheduleReconnect() {
    if (!reconnectScheduled) {
      new Timer(
          new Duration(milliseconds: 1000 * retrySeconds),
          () => initWebSocket(retrySeconds * 2));
    }
    reconnectScheduled = true;
  }

  ws.onOpen.listen((e) {
    print('Connected');
    ws.send('Hello from Dart!');
  });

  ws.onClose.listen((e) {
    print('Websocket closed, retrying in ' +
          '$retrySeconds seconds');
    scheduleReconnect();
  });

  ws.onError.listen((e) {
    print("Error connecting to ws");
    scheduleReconnect();
  });

  ws.onMessage.listen((MessageEvent e) {
    print('Received message: ${e.data}');
  });
}
```

go

```go
```

js

```js
const http = require('http');

// 创建 HTTP 服务器。
const srv = http.createServer( (req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('响应内容');
});
srv.on('upgrade', (req, socket, head) => {
  socket.write('HTTP/1.1 101 Web Socket Protocol Handshake\r\n' +
               'Upgrade: WebSocket\r\n' +
               'Connection: Upgrade\r\n' +
               '\r\n');

  socket.pipe(socket);
});

// 服务器正在运行。
srv.listen(1337, '127.0.0.1', () => {

  // 发送请求。
  const options = {
    port: 1337,
    host: '127.0.0.1',
    headers: {
      'Connection': 'Upgrade',
      'Upgrade': 'websocket'
    }
  };

  const req = http.request(options);
  req.end();

  req.on('upgrade', (res, socket, upgradeHead) => {
    console.log('接收到响应');
    socket.end();
    process.exit(0);
  });
});
```

python

```python
```

## HTTP server

dart

```dart
import 'dart:io';

main() async {
  dartHandler(HttpRequest request) {
    request.response.headers.contentType =
        new ContentType('text', 'plain');
    request.response.write('Dart is optionally typed');
    request.response.close();
  }

  var requests = await HttpServer.bind('127.0.0.1', 8888);
  await for (var request in requests) {
    print('Got request for ${request.uri.path}');
    if (request.uri.path == '/languages/dart') {
      dartHandler(request);
    } else {
      request.response.write('Not found');
      request.response.close();
    }
  }
}
```

go

```go
```

js

```js
const http = require('http');

const server = http.createServer((req, res) => {
  res.end();
});
server.on('clientError', (err, socket) => {
  socket.end('HTTP/1.1 400 Bad Request\r\n\r\n');
});
server.listen(8000);
```

python

```python
```

## HTTP client

dart

```dart
import 'dart:io';
import 'dart:convert';

main() async {
  var url = Uri.parse(
      'http://127.0.0.1:8888/languages/dart');
  var httpClient = new HttpClient();
  var request = await httpClient.getUrl(url);
  print('have request');
  var response = await request.close();
  print('have response');
  var data = await response.transform(UTF8.decoder).toList();
  var body = data.join('');
  print(body);
  httpClient.close();
}
```

go

```go
```

js

```js
```

python

```python
```

## Reading a file as text 读取整个文本

dart

```dart
import 'dart:io';

main() async {
  var config = new File('config.txt');
  var contents;

  // Put the whole file in a single string.
  contents = await config.readAsString();
  print('The entire file is ${contents.length} characters long.');

  // Put each line of the file into its own string.
  contents = await config.readAsLines();
  print('The entire file is ${contents.length} lines long.');
}

// 异常处理
import 'dart:io';

main() async {
  var config = new File('config.txt');
  try {
    var contents = await config.readAsString();
    print(contents);
  } catch (e) {
    print(e);
  }
}
```

go

```go
```

js

```js
const fs = require('fs');
fs.readFile('/etc/passwd', (err, data) => {
  if (err) throw err;
  console.log(data);
});

fs.open('myfile', 'r', (err, fd) => {
  if (err) {
    if (err.code === 'ENOENT') {
      console.error('myfile 不存在');
      return;
    }
    throw err;
  }
  readMyData(fd);
});
```

python

```python
f = open('workfile', 'w')

# 最好使用 with 关键字。 优点是当子句体结束后文件会正确关闭
with open('workfile') as f:
    read_data = f.read()
```

## Reading a file as binary 把文件数据读取为字节流

dart

```dart
import 'dart:io';

main() async {
  var config = new File('config.txt');

  var contents = await config.readAsBytes();
  print('The entire file is ${contents.length} bytes long');
}
```

go

```go
```

js

```js
const fs = require('fs');
// 从某个字符设备创建一个流。
const stream = fs.createReadStream('/dev/input/event0');
setTimeout(() => {
  stream.close(); // 这可能不会关闭流。
  // 人工标记流末尾，就好像底层资源本身已指示文件结尾一样，允许流关闭。
  // 这不会取消挂起的读取操作，如果存在此类操作，则该过程可能仍无法成功退出，直到完成为止。
  stream.push(null);
  stream.read(0);
}, 100);
```

python

```python
```

## Streaming file contents 一点点的/逐行读取

dart

```dart
import 'dart:io';
import 'dart:convert';
import 'dart:async';

main() async {
  var config = new File('config.txt');
  Stream<List<int>> inputStream = config.openRead();

  var lines = inputStream
      .transform(UTF8.decoder)
      .transform(new LineSplitter());
  try {
    await for (var line in lines) {
      print('Got ${line.length} characters from stream');
    }
    print('file is now closed');
  } catch (e) {
    print(e);
  }
}
```

go

```go
```

js

```js
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

rl.question('你如何看待 Node.js 中文网？', (answer) => {
  // TODO：将答案记录在数据库中。
  console.log(`感谢您的宝贵意见：${answer}`);

  rl.close();
});


// 微型 CLI
// 使用 readline.Interface 类来实现一个小型命令行界面
const readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  prompt: '请输入> '
});

rl.prompt();

rl.on('line', (line) => {
  switch (line.trim()) {
    case 'hello':
      console.log('world!');
      break;
    default:
      console.log(`你输入的是：'${line.trim()}'`);
      break;
  }
  rl.prompt();
}).on('close', () => {
  console.log('再见!');
  process.exit(0);
});


// 逐行读取文件流
const readline = require('readline');
const fs = require('fs');

const rl = readline.createInterface({
  input: fs.createReadStream('sample.txt'),
  crlfDelay: Infinity
});

rl.on('line', (line) => {
  console.log(`文件的每行内容：${line}`);
});
```

python

```python
# 要从文件中读取行，你可以循环遍历文件对象。这是内存高效，快速的，并简化代码:
for line in f:
    print(line, end='')
```

## Writing file contents 写入内容

dart

```dart
// 默认的写模式为 FileMode.WRITE，新写入的数据会完全覆盖 文件之前的内容。
var logFile = new File('log.txt');
var sink = logFile.openWrite();
sink.write('FILE ACCESSED ${new DateTime.now()}\n');
sink.close();

// 如果想在文件末尾追加内容，则可以使用 mode 可选参数，参数取值 为 FileMode.APPEND：
var sink = logFile.openWrite(mode: FileMode.APPEND);
```

go

```go
```

js

```js
const data = new Uint8Array(Buffer.from('Node.js中文网'));
fs.writeFile('文件.txt', data, (err) => {
  if (err) throw err;
  console.log('文件已被保存');
});

fs.writeFile('文件.txt', 'Node.js中文网', 'utf8', callback);

fs.open('message.txt', 'a', (err, fd) => {
  if (err) throw err;
  fs.appendFile(fd, '追加的数据', 'utf8', (err) => {
    fs.close(fd, (err) => {
      if (err) throw err;
    });
    if (err) throw err;
  });
});

fs.open('myfile', 'wx', (err, fd) => {
  if (err) {
    if (err.code === 'EEXIST') {
      console.error('myfile 已存在');
      return;
    }

    throw err;
  }
  writeMyData(fd);
});
```

python

```python
f.write('This is a test\n')
```

## Listing files in a directory 查找目录中的所有文件和子目录

dart

```dart
import 'dart:io';

main() async {
  var dir = new Directory('/tmp');

  try {
    var dirList = dir.list();
    await for (FileSystemEntity f in dirList) {
      if (f is File) {
        print('Found file ${f.path}');
      } else if (f is Directory) {
        print('Found dir ${f.path}');
      }
    }
  } catch (e) {
    print(e.toString());
  }
}
```

go

```go
```

js

```js
```

python

```python
```

## Decoding and encoding JSON

dart

```dart
// 使用 JSON.decode() 函数把 JSON 字符串解码为 Dart 对象：
import 'dart:convert' show JSON;

main() {
  // NOTE: Be sure to use double quotes ("),
  // not single quotes ('), inside the JSON string.
  // This string is JSON, not Dart.
  var jsonString = '''
  [
    {"score": 40},
    {"score": 80}
  ]
  ''';

  var scores = JSON.decode(jsonString);
  assert(scores is List);

  var firstScore = scores[0];
  assert(firstScore is Map);
  assert(firstScore['score'] == 40);
}

// 使用 JSON.encode() 可以把 Dart 对象 编码为 JSON 字符串：
import 'dart:convert' show JSON;

main() {
  var scores = [
    {'score': 40},
    {'score': 80},
    {'score': 100, 'overtime': true, 'special_guest': null}
  ];

  var jsonText = JSON.encode(scores);
  assert(jsonText == '[{"score":40},{"score":80},'
                     '{"score":100,"overtime":true,'
                     '"special_guest":null}]');
}
```

go

```go
```

js

JSON.stringify(value[, replacer [, space]])

- value
  将要序列化成 一个JSON 字符串的值。
- replacer 可选
  如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；
  如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；
  如果该参数为null或者未提供，则对象所有的属性都会被序列化；
  关于该参数更详细的解释和示例，请参考使用原生的 JSON 对象一文。
- space 可选
  指定缩进用的空白字符串，用于美化输出（pretty-print）；
  如果参数是个数字，它代表有多少的空格；
  上限为10。该值若小于1，则意味着没有空格；
  如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；
  如果该参数没有提供（或者为null）将没有空格。

```js
var json = '{"result":true, "count":42}';
obj = JSON.parse(json);

JSON.stringify({});                        // '{}'
JSON.stringify(true);                      // 'true'
JSON.stringify("foo");                     // '"foo"'
JSON.stringify([1, "false", false]);       // '[1,"false",false]'
JSON.stringify({ x: 5 });                  // '{"x":5}'

JSON.stringify({x: 5, y: 6});
// "{"x":5,"y":6}"

JSON.stringify([new Number(1), new String("false"), new Boolean(false)]); 
// '[1,"false",false]'

JSON.stringify({x: undefined, y: Object, z: Symbol("")}); 
// '{}'

JSON.stringify([undefined, Object, Symbol("")]);
// '[null,null,null]' 

JSON.stringify({[Symbol("foo")]: "foo"});
// '{}'

JSON.stringify({[Symbol.for("foo")]: "foo"}, [Symbol.for("foo")]);
// '{}'

JSON.stringify(
    {[Symbol.for("foo")]: "foo"}, 
    function (k, v) {
        if (typeof k === "symbol"){
            return "a symbol";
        }
    }
);
// undefined

// 不可枚举的属性默认会被忽略：
JSON.stringify( 
    Object.create(
        null,
        {
            x: { value: 'x', enumerable: false }, 
            y: { value: 'y', enumerable: true } 
        }
    )
);
// "{"y":"y"}"
```

python

```python
import json
json.dumps([1, 'simple', 'list'])
# dumps() 函数的另一个变体叫做 dump() ，它只是将对象序列化为 text file 
json.dump(x, f)
# 要再次解码对象，如果 f 是一个打开的以供阅读的 text file 对象:
x = json.load(f)
```

```sh
# 对基本的 Python 对象层次结构进行编码：
>>> import json
>>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])
'["foo", {"bar": ["baz", null, 1.0, 2]}]'
>>> print(json.dumps("\"foo\bar"))
"\"foo\bar"
>>> print(json.dumps('\u1234'))
"\u1234"
>>> print(json.dumps('\\'))
"\\"
>>> print(json.dumps({"c": 0, "b": 0, "a": 0}, sort_keys=True))
{"a": 0, "b": 0, "c": 0}
>>> from io import StringIO
>>> io = StringIO()
>>> json.dump(['streaming API'], io)
>>> io.getvalue()
'["streaming API"]'

# 紧凑编码:
>>> import json
>>> json.dumps([1, 2, 3, {'4': 5, '6': 7}], separators=(',', ':'))
'[1,2,3,{"4":5,"6":7}]'

# 美化输出:
>>> import json
>>> print(json.dumps({'4': 5, '6': 7}, sort_keys=True, indent=4))
{
    "4": 5,
    "6": 7
}

# JSON解码:
>>> import json
>>> json.loads('["foo", {"bar":["baz", null, 1.0, 2]}]')
['foo', {'bar': ['baz', None, 1.0, 2]}]
>>> json.loads('"\\"foo\\bar"')
'"foo\x08ar'
>>> from io import StringIO
>>> io = StringIO('["streaming API"]')
>>> json.load(io)
['streaming API']
```

## Decoding and encoding UTF-8 characters

dart

```dart
// 使用 UTF8.decode() 来解码 UTF8-encoded 字节流为 Dart 字符串：
import 'dart:convert' show UTF8;

main() {
  var string = UTF8.decode([
    0xc3, 0x8e, 0xc3, 0xb1, 0xc5, 0xa3, 0xc3, 0xa9,
    0x72, 0xc3, 0xb1, 0xc3, 0xa5, 0xc5, 0xa3, 0xc3,
    0xae, 0xc3, 0xb6, 0xc3, 0xb1, 0xc3, 0xa5, 0xc4,
    0xbc, 0xc3, 0xae, 0xc5, 0xbe, 0xc3, 0xa5, 0xc5,
    0xa3, 0xc3, 0xae, 0xe1, 0xbb, 0x9d, 0xc3, 0xb1
  ]);
  print(string); // 'Îñţérñåţîöñåļîžåţîờñ'
}

// 如果是 stream 字节流则可以在 Stream 的 transform() 函数上指定 UTF8.decoder ：
var lines = inputStream
    .transform(UTF8.decoder)
    .transform(new LineSplitter());
try {
  await for (var line in lines) {
    print('Got ${line.length} characters from stream');
  }
}

// 使用 UTF8.encode() 把字符串编码为 UTF8 字节 流：
import 'dart:convert' show UTF8;

main() {
  List<int> expected = [
    0xc3, 0x8e, 0xc3, 0xb1, 0xc5, 0xa3, 0xc3, 0xa9,
    0x72, 0xc3, 0xb1, 0xc3, 0xa5, 0xc5, 0xa3, 0xc3,
    0xae, 0xc3, 0xb6, 0xc3, 0xb1, 0xc3, 0xa5, 0xc4,
    0xbc, 0xc3, 0xae, 0xc5, 0xbe, 0xc3, 0xa5, 0xc5,
    0xa3, 0xc3, 0xae, 0xe1, 0xbb, 0x9d, 0xc3, 0xb1
  ];

  List<int> encoded = UTF8.encode('Îñţérñåţîöñåļîžåţîờñ');

  assert(() {
    if (encoded.length != expected.length) return false;
    for (int i = 0; i < encoded.length; i++) {
      if (encoded[i] != expected[i]) return false;
    }
    return true;
  });
}
```

go

```go
```

js

JavaScript 使用 Unicode 字符集。
JavaScript 引擎内部，所有字符都用 Unicode 表示。
即将字符写成\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。
比如，\u00A9代表版权符号

每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。
也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节

UTF-16 有两种长度：
对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；
对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），
而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。
举例来说，码点U+1D306对应的字符为𝌆，它写成 UTF-16 就是0xD834 0xDF06。

JavaScript 对 UTF-16 的支持是不完整的，
由于历史原因，只支持两字节的字符，不支持四字节的字符。
这是因为 JavaScript 第一版发布的时候，
Unicode 的码点只编到U+FFFF，因此两字节足够表示了。
后来，Unicode 纳入的字符越来越多，出现了四字节的编码。
但是，JavaScript 的标准此时已经定型了，
统一将字符长度限制在两字节，导致无法识别四字节的字符。

```js
var s = '\u00A9';
s // "©"

var f\u006F\u006F = 'abc';
foo // "abc"

'𝌆'.length // 2
```

python

```python
```

## Base64

![Base64](./images/decimal-to-base64-table.png)

dart

```dart
```

go

```go
```

js

所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。
JavaScript 原生提供两个 Base64 相关的方法。

- btoa()：任意值转为 Base64 编码
- atob()：Base64 编码转为原来的值

```js
var string = 'Hello World!';
btoa(string) // "SGVsbG8gV29ybGQh"
atob('SGVsbG8gV29ybGQh') // "Hello World!"

// 这两个方法不适合非 ASCII 码的字符，会报错。
btoa('你好') // 报错
// 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。
function b64Encode(str) {
  return btoa(encodeURIComponent(str));
}
function b64Decode(str) {
  return decodeURIComponent(atob(str));
}
b64Encode('你好') // "JUU0JUJEJUEwJUU1JUE1JUJE"
b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // "你好"


// 在node中
console.log(Buffer.from("Hello World").toString('base64')); // SGVsbG8gV29ybGQ=
console.log(Buffer.from("SGVsbG8gV29ybGQ=", 'base64').toString('ascii')); // Hello World
// 非 ASCII 码的字符
console.log(Buffer.from(encodeURIComponent("你好")).toString('base64')); // JUU0JUJEJUEwJUU1JUE1JUJE
console.log(decodeURIComponent(Buffer.from("JUU0JUJEJUEwJUU1JUE1JUJE", 'base64').toString('ascii'))); // 你好

let data = 'Hello World';  
let buff = new Buffer(data);  
let base64data = buff.toString('base64'); // SGVsbG8gV29ybGQ=

let data = 'SGVsbG8gV29ybGQ=';  
let buff = new Buffer(data, 'base64');  
let text = buff.toString('ascii');

const fs = require('fs');
let buff = fs.readFileSync('stack-abuse-logo.png');
let base64data = buff.toString('base64');

const fs = require('fs');
let data = 'iVBORw0KGgoAAAANSUhEUgAAABkAAAATCAYAAABlcqYFAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAA' +  
'CA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAAsTAAALEwEAmpwYAAABWWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0' +  
'YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly' +  
'93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAg' +  
'ICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZm' +  
'Y6T3JpZW50YXRpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgpMwidZAAADuUlEQVQ4EbVU' +  
'TUtcZxR+7ufkXp1SZ4iZRE1EDVQRnTAhowsZMFm40I2rNqUIIev8hvoPQroQXBTqwiAWcd0EglEhiZNajVZrQGXAWAzaZpzMnZn7lXPeeIe5Da' +  
'Wb9Ax33vOec8/znI/3vVI6nfbxP4v8b/iSJIGfzyGfkPi+D13XUalUBL6qqmIvy5+8WuX/r2RCkUzAoIuLi2hqaoLrutjb28P6+josyxJkiqJA' +  
'07SQXiqVwHaOZYx/itLc3Px9YIxEIlheXsbExATGxsYwMjIiwEdHRwXA/Pw8EokEcrkcDg4OYJomVlZWMDU1JSqfmZlBR0cHbNsOtVoNCHjlTF' +  
'iSySQMwxAVxONxQbi0tIRMJoPe3l5MT0+jtbUVg4ODYGImY18qlcL4+DhisZjoggCjv1C7uOyenh7Mzs5iY2ND6FQpdnd3sba2JloSjUYxPDyM' +  
'/v5+TE5OYn9/X9jZtrOzg+3t7WqyAUmoEu419/+HBw9E+eVymbJqAJP39fWBCR3HEU+hUMDQ0JCYGc8um81iYGAAjY2N8DwvwBdraCY8tHhDA1' +  
'Y3N9Hd3S2yvH37O7RcbsF7AuUsD9+8wdOFBTx/8QJtbW1C5/nMzc3R0D2UyxXk83lRXcAk1V5GCT5sSUGDbeHxy9/EO98M9OOXzT9wfHISxKC1' +  
'vR0GHfOtrS2g/SouWwU0Xkggu7qO9PUkJFULnbIQyTm6ewu2hF+vnOIIUQwdGlg8f4QF6wvMWBq+pAkaskSnx4FFVUf0CNpcC797KizXQ4oAHh' +  
'VdXJJ81F7j6kwUynPHlXDPdFB2fRj+KVK0KvT2rbp3uKYryJU11Cke8qqMuOoioeeJ1MPDYxM36m1cNSq4GdFx58RAWvbx8TrXnK4IgR16Em5G' +  
'K4iqHi5GHHxLgcSDn97WgZPoND+GGZRpPYH85cgiiRQl1ltXxmFFQ5PuopP8TrW5ZyRcWp7AbmkeZefg5+N6PPnbRJdpw/YlfB0vQiPQZwVdZN' +  
'tFZEVK6D1VTnccJlXzuqTjvOZiq6Rhj2KqLSJsofOHgIl8+t0/qsfDioxmSUWGjrRFzhYi/5Oynrdl3KXHIZDXtF6hil8R6I9FBV/RvDLnXKxS' +  
'bAdVYhNeINXBMwmXWCTQGG2Y+Jj+dFrfEmiMAtmeowpo9ojTvkD+A/L1UJUMmiVfkuz6WTyZhFRJAgP33j3bsM5k/Fng68UP21hYJyyxZwLWuS' +  
'2cKMfUSm3rhD0g4E2g197fwMZ+Bgt8rNe2iP2BhL5dgfFzrx8AfECEDdx45a0AAAAASUVORK5CYII=';
let buff = new Buffer(data, 'base64');  
fs.writeFileSync('stack-abuse-logo-out.png', buff);
```

python

```sh
```

## 操作系统接口

dart

```dart
```

go

```go
```

js

```js
const os = require('os');
```

python

```sh
>>> import os
>>> os.getcwd()      # Return the current working directory
'C:\\Python37'
>>> os.chdir('/server/accesslogs')   # Change current working directory
>>> os.system('mkdir today')   # Run the command mkdir in the system shell
0

>>> import os
>>> dir(os)
<returns a list of all module functions>
>>> help(os)
<returns an extensive manual page created from the module's docstrings>

>>> import shutil
>>> shutil.copyfile('data.db', 'archive.db')
'archive.db'
>>> shutil.move('/build/executables', 'installdir')
'installdir'

# 以下输出来自在命令行运行 python demo.py one two three
>>> import sys
>>> print(sys.argv)
['demo.py', 'one', 'two', 'three']
```

## 模板

dart

```dart
```

go

```go
```

js

```js
```

python

```python
```

## 日志

dart

```dart
```

go

```go
```

js

```js
```

python

```python
import logging
logging.debug('Debugging information')
logging.info('Informational message')
logging.warning('Warning:config file %s not found', 'server.conf')
logging.error('Error occurred')
logging.critical('Critical error -- shutting down')
```
