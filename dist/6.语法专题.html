<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>6.语法专题.md</title>
    <link rel="stylesheet" href="./styles.css" />
    <link rel="stylesheet" href="./highlight/styles/github.css" />
  </head>
  <body>
    <div id="nav">
      <ul>
        <li>
          <a href="#%E8%AF%AD%E6%B3%95%E4%B8%93%E9%A2%98">语法专题</a>
          <ul>
            <li>
              <a href="#Generics%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89"
                >Generics（泛型）</a
              >
            </li>
            <li>
              [Using collection literals（使用集合字面量）](#Using collection
              literals（使用集合字面量）)
            </li>
            <li>
              [Using parameterized types with
              constructors（在构造函数中使用泛型）](#Using parameterized types
              with constructors（在构造函数中使用泛型）)
            </li>
            <li>
              <a href="#%E6%B3%9B%E5%9E%8B%E5%88%A4%E6%96%AD">泛型判断</a>
            </li>
            <li>
              [Restricting the parameterized type（限制泛型类型）](#Restricting
              the parameterized type（限制泛型类型）)
            </li>
            <li>
              [Using generic methods（使用泛型函数）](#Using generic
              methods（使用泛型函数）)
            </li>
            <li>
              [Asynchrony support（异步支持）](#Asynchrony support（异步支持）)
            </li>
            <li>
              [Declaring async functions（声明异步方法）](#Declaring async
              functions（声明异步方法）)
            </li>
            <li>
              [Using await expressions with Futures（使用 await 表达式）](#Using
              await expressions with Futures（使用 await 表达式）)
            </li>
            <li>
              [Using asynchronous for loops with
              Streams（在循环中使用异步）](#Using asynchronous for loops with
              Streams（在循环中使用异步）)
            </li>
            <li>
              <a
                href="#%E5%B9%B6%E5%8F%91/%E5%90%8C%E6%97%B6%E8%A7%A6%E5%8F%91/%E7%AB%9E%E4%BA%89%E8%A7%A6%E5%8F%91"
                >并发/同时触发/竞争触发</a
              >
            </li>
            <li>
              <a
                href="#%E5%BC%82%E6%AD%A5%E7%9A%84%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7"
                >异步的错误捕获</a
              >
            </li>
            <li><a href="#%E7%94%9F%E6%88%90%E5%99%A8">生成器</a></li>
            <li>
              <a
                href="#Metadata%EF%BC%88%E5%85%83%E6%95%B0%E6%8D%AE%EF%BC%89%E6%B3%A8%E8%A7%A3/%E8%A3%85%E9%A5%B0%E5%99%A8"
                >Metadata（元数据）注解/装饰器</a
              >
            </li>
            <li>
              [Regular expressions（正则表达式）](#Regular
              expressions（正则表达式）)
            </li>
            <li>[new 命令](#new 命令)</li>
            <li><a href="#this%E5%85%B3%E9%94%AE%E5%AD%97">this关键字</a></li>
            <li><a href="#%E5%8E%9F%E5%9E%8B%E9%93%BE">原型链</a></li>
            <li>
              <a
                href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7"
                >获取对象的所有属性</a
              >
            </li>
            <li>
              <a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D"
                >对象的拷贝</a
              >
            </li>
          </ul>
        </li>
      </ul>
    </div>
    <div id="content">
      <h1 id="语法专题">语法专题</h1>
      <h2 id="Generics（泛型）">Generics（泛型）</h2>
      <p>dart</p>
      <p>
        如果你查看 List 类型的 API 文档， 则可以看到 实际的类型定义为
        <code>List&lt;E&gt;</code>。 这个 <code>&lt;…&gt;</code> 声明 list
        是一个 泛型 (或者 参数化) 类型。
        通常情况下，使用一个字母来代表类型参数， 例如 E, T, S, K, 和 V 等。
      </p>
      <pre><code class="language-dart">// 一个保存缓存对象 的接口
abstract class ObjectCache {
  Object getByKey(String key);
  setByKey(String key, Object value);
}
// 一个用来缓存字符串的实现
abstract class StringCache {
  String getByKey(String key);
  setByKey(String key, String value);
}
// 泛型可以避免这种重复的代码。 你只需要创建一个接口即可：
abstract class Cache&lt;T&gt; {
  T getByKey(String key);
  setByKey(String key, T value);
}
// 在上面的代码中，T 是一个备用类型。
// 这是一个类型占位符， 在开发者调用该接口的时候会指定具体类型。</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="Using collection literals（使用集合字面量）">
        Using collection literals（使用集合字面量）
      </h2>
      <p>dart</p>
      <p>
        List 和 map 字面量也是可以参数化的。 参数化定义 list 需要在中括号之前
        添加 <code>&lt;type&gt;</code> ， 定义 map 需要在大括号之前 添加
        <code>&lt;keyType, valueType&gt;</code>。
      </p>
      <pre><code class="language-dart">var names = &lt;String&gt;[&#39;Seth&#39;, &#39;Kathy&#39;, &#39;Lars&#39;];
var pages = &lt;String, String&gt;{
  &#39;index.html&#39;: &#39;Homepage&#39;,
  &#39;robots.txt&#39;: &#39;Hints for web robots&#39;,
  &#39;humans.txt&#39;: &#39;We are people, not machines&#39;
};</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2
        id="Using parameterized types with constructors（在构造函数中使用泛型）"
      >
        Using parameterized types with constructors（在构造函数中使用泛型）
      </h2>
      <p>dart</p>
      <pre><code class="language-dart">var names = new List&lt;String&gt;();
names.addAll([&#39;Seth&#39;, &#39;Kathy&#39;, &#39;Lars&#39;]);
var nameSet = new Set&lt;String&gt;.from(names);

// 下面代码创建了一个 key 为 integer， value 为 View 类型 的 map：
var views = new Map&lt;int, View&gt;();</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="泛型判断">泛型判断</h2>
      <p>dart</p>
      <p>Dart 的泛型类型是固化的，在运行时也 可以判断具体的类型。</p>
      <pre><code class="language-dart">var names = new List&lt;String&gt;();
names.addAll([&#39;Seth&#39;, &#39;Kathy&#39;, &#39;Lars&#39;]);
print(names is List&lt;String&gt;); // true</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="Restricting the parameterized type（限制泛型类型）">
        Restricting the parameterized type（限制泛型类型）
      </h2>
      <p>dart</p>
      <pre><code class="language-dart">// T must be SomeBaseClass or one of its descendants.
class Foo&lt;T extends SomeBaseClass&gt; {...}

class Extender extends SomeBaseClass {...}

void main() {
  // It&#39;s OK to use SomeBaseClass or any of its subclasses inside &lt;&gt;.
  var someBaseClassFoo = new Foo&lt;SomeBaseClass&gt;();
  var extenderFoo = new Foo&lt;Extender&gt;();

  // It&#39;s also OK to use no &lt;&gt; at all.
  var foo = new Foo();

  // Specifying any non-SomeBaseClass type results in a warning and, in
  // checked mode, a runtime error.
  // var objectFoo = new Foo&lt;Object&gt;();
}</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="Using generic methods（使用泛型函数）">
        Using generic methods（使用泛型函数）
      </h2>
      <p>dart</p>
      <p>
        一开始，泛型只能在 Dart 类中使用。
        新的语法也支持在函数和方法上使用泛型了。
      </p>
      <p>
        这里的 first (<code>&lt;T&gt;</code>) 泛型可以在如下地方使用 参数 T ：
      </p>
      <ul>
        <li>函数的返回值类型 (T).</li>
        <li>参数的类型 (<code>List&lt;T&gt;</code>).</li>
        <li>局部变量的类型 (T tmp).</li>
      </ul>
      <pre><code class="language-dart">T first&lt;T&gt;(List&lt;T&gt; ts) {
  // ...Do some initial work or error checking, then...
  T tmp ?= ts[0];
  // ...Do some additional checking or processing...
  return tmp;
}</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="Asynchrony support（异步支持）">
        Asynchrony support（异步支持）
      </h2>
      <p>dart</p>
      <p>
        异步编程通常使用回调函数，但是 Dart 提供了另外的 选择：
        <code>Future</code> 和 <code>Stream</code> 对象。 <code>Future</code> 和
        <code>JavaScript</code> 中的 <code>Promise</code> 类似，
        代表在将来某个时刻会返回一个 结果。 Stream
        是一种用来获取一些列数据的方式，例如 事件流。
      </p>
      <p>
        在 Dart 库中随处可见 Future 对象，通常异步函数返回的对象就是一个
        Future。
      </p>
      <p>
        Dart 库中有很多返回 Future 或者 Stream 对象的方法。 这些方法是 异步的：
        这些函数在设置完基本的操作 后就返回了， 而无需等待操作执行完成。
      </p>
      <p>
        Stream 在 Dart API 中也经常出现，代表一些列数据。 例如， HTML
        按钮点击事件就可以使用 stream 来表示。 还可以把读取文件内容当做一个
        Stream。
      </p>
      <p>有两种方式可以使用 Future 对象中的 数据：</p>
      <ul>
        <li>使用 async 和 await</li>
        <li>使用 Future API</li>
      </ul>
      <p><code>Future</code> 类似js中的 <code>Promise</code></p>
      <pre><code class="language-dart">// 要使用 await，其方法必须带有 async 关键字：
checkVersion() async {
  var version = await lookUpVersion();
  if (version == expectedVersion) {
    // Do something.
  } else {
    // Do something else.
  }
}
// 可以使用 try, catch, 和 finally 来处理使用 await 的异常：
try {
  server = await HttpServer.bind(InternetAddress.LOOPBACK_IP_V4, 4044);
} catch (e) {
  // React to inability to bind to the port...
}

// 使用 then() 可以在 Future 完成的时候执行其他代码 来解析返回的数据：
HttpRequest.getString(url).then((String result) {
  print(result);
});
// Should handle errors here.

// 使用 catchError() 来处理 Future 对象可能抛出的 各种异常和错误：
HttpRequest.getString(url).then((String result) {
  print(result);
}).catchError((e) {
  // Handle or ignore the error.
});


// then() 函数返回值为 Future，可以把多个异步调用给串联起来。
// 如果 then() 函数注册的回调函数也返回一个 Future，而 then() 返回一个同样的 Future。
// 如果回调函数返回的是一个其他类型的值， 则 then() 会创建一个新的 Future 对象 并完成这个 future。
Future result = costlyQuery();
return result.then((value) =&gt; expensiveWork())
             .then((value) =&gt; lengthyComputation())
             .then((value) =&gt; print(&#39;done!&#39;))
             .catchError((exception) =&gt; print(&#39;DOH!&#39;));

// 要想在每个数据到达的时候就去处理，则可以选择使用 await for 或者 使用 listen() 函数来订阅事件：
// Find a button by ID and add an event handler.
querySelector(&#39;#submitInfo&#39;).onClick.listen((e) {
  // When the button is clicked, it runs this code.
  submitData();
});

// 经常你需要先转换 stream 里面的数据才能使用。
// 使用 transform() 函数可以生产另外一个数据类型 的 Stream 对象：
var stream = inputStream
    .transform(UTF8.decoder)
    .transform(new LineSplitter());
// 上面的代码使用两种转换器（transformer）。
// 第一个使用 UTF8.decoder 来把整数类型的数据流转换为字符串类型的数据流。
// 然后使用 LineSplitter 把字符串类型数据流转换为按行分割的数据流。</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">const promise = new Promise(function(resolve, reject) {
  // ... some code
  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
promise.then(function(value) {
  // success
}, function(error) {
  // failure
});

// 下面是异步加载图片的例子
function loadImageAsync(url) {
  return new Promise(function(resolve, reject) {
    const image = new Image();
    image.onload = function() {
      resolve(image);
    };
    image.onerror = function() {
      reject(new Error(&#39;Could not load image at &#39; + url));
    };
    image.src = url;
  });
}
const preloadImage = function (path) {
  return new Promise(function (resolve, reject) {
    const image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  });
};

// Promise对象实现的 Ajax 操作的例子
const getJSON = function(url) {
  const promise = new Promise(function(resolve, reject){
    const handler = function() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    const client = new XMLHttpRequest();
    client.open(&quot;GET&quot;, url);
    client.onreadystatechange = handler;
    client.responseType = &quot;json&quot;;
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
    client.send();

  });
  return promise;
};
getJSON(&quot;/posts.json&quot;).then(function(json) {
  console.log(&#39;Contents: &#39; + json);
}, function(error) {
  console.error(&#39;出错了&#39;, error);
});

// 调用resolve或reject并不会终结 Promise 的参数函数的执行
new Promise((resolve, reject) =&gt; {
  resolve(1);
  console.log(2);
}).then(r =&gt; {
  console.log(r);
});
// 2
// 1

// 可以发现reject方法的作用，等同于抛出错误。
// 如果 Promise 状态已经变成resolved，再抛出错误是无效的。
// bad
promise.then(function(data) {
  // success
}, function(err) {
  // error
});

// good
promise.then(function(data) { //cb
  // success
}).catch(function(err) {
  // error
});

// 有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。
Promise.resolve(&#39;foo&#39;)
// 等价于
new Promise(resolve =&gt; resolve(&#39;foo&#39;))

// 顺序执行异步任务的小技巧
const sleep = (ms=1000) =&gt; new Promise((resolve, reject) =&gt; {
  setTimeout(resolve, ms);
});
var sequence = Promise.resolve();
[1,2,3].forEach(item =&gt; {
  sequence = sequence.then(async ()=&gt;{
    console.log(item);
    await sleep();
  })
});

// 顺序执行异步任务的小技巧
// 构建队列
const sleep = (ms=1000) =&gt; new Promise((resolve, reject) =&gt; {
  setTimeout(()=&gt;{
    console.log(ms)
    resolve(ms+1000);
  }, ms);
});
function queue(arr) {
  var sequence = Promise.resolve()
  arr.forEach(function (f) {
    sequence = sequence.then(f)
  })
  return sequence
}
// 执行队列
queue([sleep,sleep,sleep]).then(data =&gt; {
  console.log(&#39;end&#39;,data)
});
// 1000
// 2000
// 3000
// end 4000

// await实现队列任务
const sleep = (ms=1000) =&gt; new Promise((resolve, reject) =&gt; {
  setTimeout(()=&gt;{
    console.log(ms)
    resolve(ms+1000);
  }, ms);
});
async function queue(arr) {
  let res = null
  for (let f of arr) {
    res = await f(res)
  }
  return await res
}
queue([sleep,sleep,sleep]).then(data =&gt; {
  console.log(&#39;end&#39;,data)
});
// null
// 1000
// 2000
// end 3000</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="Declaring async functions（声明异步方法）">
        Declaring async functions（声明异步方法）
      </h2>
      <p>dart</p>
      <p>一个 async 方法 是函数体被标记为 async 的方法。</p>
      <pre><code class="language-dart">checkVersion() async {
  // ...
}
lookUpVersion() async =&gt; /* ... */;

// 下面是一个返回字符串 的同步方法
String lookUpVersionSync() =&gt; &#39;1.0.0&#39;;
// 如果使用 async 关键字，则该方法 返回一个 Future，并且 认为该函数是一个耗时的操作。
// 方法的函数体并不需要使用 Future API。 Dart 会自动在需要的时候创建 Future 对象
Future&lt;String&gt; lookUpVersion() async =&gt; &#39;1.0.0&#39;;</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">// 函数声明
async function foo() {}

// 函数表达式
const foo = async function () {};

// 对象的方法
let obj = { async foo() {} };
obj.foo().then(...)

// Class 的方法
class Storage {
  constructor() {
    this.cachePromise = caches.open(&#39;avatars&#39;);
  }

  async getAvatar(name) {
    const cache = await this.cachePromise;
    return cache.match(`/avatars/${name}.jpg`);
  }
}

const storage = new Storage();
storage.getAvatar(&#39;jake&#39;).then(…);

// 箭头函数
const foo = async () =&gt; {};</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="Using await expressions with Futures（使用 await 表达式）">
        Using await expressions with Futures（使用 await 表达式）
      </h2>
      <p>dart</p>
      <p>
        在 await expression 中， expression 的返回值通常是一个 Future；
        如果返回的值不是 Future，则 Dart 会自动把该值放到 Future 中返回。 Future
        对象代表返回一个对象的承诺（promise）。 await expression
        执行的结果为这个返回的对象。 await expression
        会阻塞住，直到需要的对象返回为止。
      </p>
      <p>
        如果 await 无法正常使用，请确保是在一个 async 方法中。 例如要在 main()
        方法中使用 await， 则 main() 方法的函数体必须标记为 async：
      </p>
      <p>
        异步方法（带有关键字 async 的方法）会返回 Future。
        如果你不想让你的方法返回 future，则 不要使用 async 关键字。
        例如，你可以在你的方法里面调用一个 异步方法。
      </p>
      <pre><code class="language-dart">var entrypoint = await findEntrypoint();
var exitCode = await runExecutable(entrypoint, args);
await flushThenExit(exitCode);

main() async {
  checkVersion();
  print(&#39;In main: version is ${await lookUpVersion()}&#39;);
}

// 使用 Future 的 then() 函数来 执行三个异步方法， 每个方法执行完后才继续执行后一个方法。
runUsingFuture() {
  //...
  findEntrypoint().then((entrypoint) {
    return runExecutable(entrypoint, args);
  }).then(flushThenExit);
}
// 下面是使用 await 表达式实现的同样功能的代码， 看起来更像是同步代码，更加容易理解：
runUsingAsyncAwait() async {
  //...
  var entrypoint = await findEntrypoint();
  var exitCode = await runExecutable(entrypoint, args);
  await flushThenExit(exitCode);
}
// 异步方法可以把 Future 中的错误当做 异常来处理。 例如：
attached() async {
  super.attached();
  try {
    await appObject.start();
  } catch (e) {
    //...handle the error...
  }
}</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="Using asynchronous for loops with Streams（在循环中使用异步）">
        Using asynchronous for loops with Streams（在循环中使用异步）
      </h2>
      <p>dart</p>
      <pre><code class="language-dart">main() async {
  ...
  await for (var request in requestServer) {
    handleRequest(request);
  }
  ...
}

// 使用 Stream 的 listen() 函数来订阅 一些文件，然后使用一个方法参数来 搜索每个文件和目录。
void main(List&lt;String&gt; arguments) {
  // ...
  FileSystemEntity.isDirectory(searchPath).then((isDir) {
    if (isDir) {
      final startingDir = new Directory(searchPath);
      startingDir
          .list(
              recursive: argResults[RECURSIVE],
              followLinks: argResults[FOLLOW_LINKS])
          .listen((entity) {
        if (entity is File) {
          searchFile(entity, searchTerms);
        }
      });
    } else {
      searchFile(new File(searchPath), searchTerms);
    }
  });
}
// 下面是使用 await 表达式和异步 for 循环 实现的等价的代码， 看起来更像是同步代码：
main(List&lt;String&gt; arguments) async {
  // ...
  if (await FileSystemEntity.isDirectory(searchPath)) {
    final startingDir = new Directory(searchPath);
    await for (var entity in startingDir.list(
        recursive: argResults[RECURSIVE],
        followLinks: argResults[FOLLOW_LINKS])) {
      if (entity is File) {
        searchFile(entity, searchTerms);
      }
    }
  } else {
    searchFile(new File(searchPath), searchTerms);
  }
}</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="并发/同时触发/竞争触发">并发/同时触发/竞争触发</h2>
      <p>dart</p>
      <pre><code class="language-dart">// 使用 Future.wait() 这个静态函数来管理多个 Future 并等待所有 Future 执行完成。
Future deleteDone = deleteLotsOfFiles();
Future copyDone = copyLotsOfFiles();
Future checksumDone = checksumLotsOfOtherFiles();

Future.wait([deleteDone, copyDone, checksumDone])
    .then((List values) {
      print(&#39;Done with all the long steps&#39;);
    });</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">// 生成一个Promise对象的数组
const promises = [2, 3, 5, 7, 11, 13].map(function (id) {
  return getJSON(&#39;/post/&#39; + id + &quot;.json&quot;);
});
Promise.all(promises).then(function (posts) {
  // ...
}).catch(function(reason){
  // ...
});

// 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。
const p = Promise.race([p1, p2, p3]);
const p = Promise.race([
  fetch(&#39;/resource-that-may-take-a-while&#39;),
  new Promise(function (resolve, reject) {
    setTimeout(() =&gt; reject(new Error(&#39;request timeout&#39;)), 5000)
  })
]);
p.then(console.log)
.catch(console.error);</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="异步的错误捕获">异步的错误捕获</h2>
      <p>dart</p>
      <pre><code class="language-dart">// 在 stream 关闭后执行的代码位于异步 for 循环 之后。
readFileAwaitFor() async {
  var config = new File(&#39;config.txt&#39;);
  Stream&lt;List&lt;int&gt;&gt; inputStream = config.openRead();

  var lines = inputStream
      .transform(UTF8.decoder)
      .transform(new LineSplitter());
  try {
    await for (var line in lines) {
      print(&#39;Got ${line.length} characters from stream&#39;);
    }
    print(&#39;file is now closed&#39;);
  } catch (e) {
    print(e);
  }
}

// 如果你使用 Stream API，则需要 使用 onError 函数来处理异常。
// stream 完成后执行的代码要通过 onDone 函数 来执行。
var config = new File(&#39;config.txt&#39;);
Stream&lt;List&lt;int&gt;&gt; inputStream = config.openRead();
inputStream
    .transform(UTF8.decoder)
    .transform(new LineSplitter())
    .listen((String line) {
      print(&#39;Got ${line.length} characters from stream&#39;);
    }, onDone: () {
      print(&#39;file is now closed&#39;);
    }, onError: (e) {
      print(e);
    });</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="生成器">生成器</h2>
      <p>dart</p>
      <ul>
        <li>Synchronous generator: Returns an Iterable object.</li>
        <li>Asynchronous generator: Returns a Stream object.</li>
      </ul>
      <pre><code class="language-dart">Iterable&lt;int&gt; naturalsTo(int n) sync* {
  int k = 0;
  while (k &lt; n) yield k++;
}

Stream&lt;int&gt; asynchronousNaturalsTo(int n) async* {
  int k = 0;
  while (k &lt; n) yield k++;
}

// 递归
Iterable&lt;int&gt; naturalsDownFrom(int n) sync* {
  if (n &gt; 0) {
    yield n;
    yield* naturalsDownFrom(n - 1);
  }
}</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <p>
        Generator 是一个用于创建迭代器的简单而强大的工具。
        它们的写法类似标准的函数，但当它们要返回数据时会使用 yield 语句。
        每次对生成器调用 next() 时，
        它会从上次离开位置恢复执行（它会记住上次执行语句时的所有数据值）。
      </p>
      <pre><code class="language-python">def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]
for char in reverse(&#39;golf&#39;):
    print(char)
# f
# l
# o
# g

# 某些简单的生成器可以写成简洁的表达式代码，
# 所用语法类似列表推导式，将外层为圆括号而非方括号。
sum(i*i for i in range(10))</code></pre>
      <h2 id="Metadata（元数据）注解/装饰器">Metadata（元数据）注解/装饰器</h2>
      <p>dart</p>
      <p>
        使用元数据给你的代码添加其他额外信息。 元数据注解是以 @
        字符开头，后面是一个编译时 常量(例如 deprecated)或者
        调用一个常量构造函数。
      </p>
      <p>
        有三个注解所有的 Dart 代码都可以使用： @deprecated、 @override、 和
        @proxy。
      </p>
      <pre><code class="language-dart">lass Television {
  /// _Deprecated: Use [turnOn] instead._
  // 表示弃用此函数
  @deprecated
  void activate() {
    turnOn();
  }

  /// Turns the TV&#39;s power on.
  void turnOn() {
    print(&#39;on!&#39;);
  }
}

// 你还可以定义自己的元数据注解。
// 下面的示例定义了一个带有两个参数的 @todo 注解：
library todo;
class todo {
  final String who;
  final String what;
  const todo(this.who, this.what);
}
// 使用 @todo 注解的示例：
import &#39;todo.dart&#39;;
@todo(&#39;seth&#39;, &#39;make this do something&#39;)
void doSomething() {
  print(&#39;do something&#39;);
}</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python">def log(func):
    def wrapper(*args, **kw):
        print(&#39;call %s():&#39; % func.__name__)
        return func(*args, **kw)
    return wrapper

@log
def now():
    print(&#39;2015-3-25&#39;)

def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print(&#39;%s %s():&#39; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator

@log(&#39;execute&#39;)
def now():
    print(&#39;2015-3-25&#39;)

# 因为返回的那个wrapper()函数名字就是&#39;wrapper&#39;，
# 所以，需要把原始函数的__name__等属性复制到wrapper()函数中，
# 否则，有些依赖函数签名的代码执行就会出错
import functools
def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print(&#39;call %s():&#39; % func.__name__)
        return func(*args, **kw)
    return wrapper

# 或者针对带参数的decorator：
import functools
def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print(&#39;%s %s():&#39; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator

import time
from functools import wraps
def timethis(func):
    &#39;&#39;&#39;
    Decorator that reports the execution time.
    &#39;&#39;&#39;
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(func.__name__, end-start)
        return result
    return wrapper

class Date(object):

    def __init__(self, day=0, month=0, year=0):
        self.day = day
        self.month = month
        self.year = year

    @classmethod
    def from_string(cls, date_as_string):
        day, month, year = map(int, date_as_string.split(&#39;-&#39;))
        date1 = cls(day, month, year)
        return date1

    @staticmethod
    def is_date_valid(date_as_string):
        day, month, year = map(int, date_as_string.split(&#39;-&#39;))
        return day &lt;= 31 and month &lt;= 12 and year &lt;= 3999

date2 = Date.from_string(&#39;11-09-2012&#39;)
is_date = Date.is_date_valid(&#39;11-09-2012&#39;)</code></pre>
      <pre><code class="language-sh">&gt;&gt;&gt; @timethis
... def countdown(n):
...     &#39;&#39;&#39;
...     Counts down
...     &#39;&#39;&#39;
...     while n &gt; 0:
...         n -= 1
...
&gt;&gt;&gt; countdown(100000)
countdown 0.008917808532714844
&gt;&gt;&gt; countdown.__name__
&#39;countdown&#39;
&gt;&gt;&gt; countdown.__doc__
&#39;\n\tCounts down\n\t&#39;
&gt;&gt;&gt; countdown.__annotations__
{&#39;n&#39;: &lt;class &#39;int&#39;&gt;}
&gt;&gt;&gt;</code></pre>
      <h2 id="Regular expressions（正则表达式）">
        Regular expressions（正则表达式）
      </h2>
      <p>dart</p>
      <pre><code class="language-dart">// Here&#39;s a regular expression for one or more digits.
var numbers = new RegExp(r&#39;\d+&#39;);

var allCharacters = &#39;llamas live fifteen to twenty years&#39;;
var someDigits = &#39;llamas live 15 to 20 years&#39;;

// contains() can use a regular expression.
assert(!allCharacters.contains(numbers));
assert(someDigits.contains(numbers));

// Replace every match with another string.
var exedOut = someDigits.replaceAll(numbers, &#39;XX&#39;);
assert(exedOut == &#39;llamas live XX to XX years&#39;);

// 还可以直接操作 RegExp 类。
// Match 类提供了 访问正则表达式匹配到的内容。
var numbers = new RegExp(r&#39;\d+&#39;);
var someDigits = &#39;llamas live 15 to 20 years&#39;;

// Check whether the reg exp has a match in a string.
assert(numbers.hasMatch(someDigits));

// Loop through all matches.
for (var match in numbers.allMatches(someDigits)) {
  print(match.group(0)); // 15, then 20
}</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">// 判断只包含中英文
var reg = /^[a-zA-Z\u4e00-\u9fa5]+$/;
var str = &#39;我1!@$#%23你dsfd~__)&#39;;
reg.test(str); // false
// 过滤非中英文字符
var reg = /[^a-zA-Z\u4e00-\u9fa5]/g;
var str = &#39;我1!@$#%23你dsfd~__)&#39;;
str.replace(reg,&#39;&#39;);</code></pre>
      <p>python</p>
      <pre><code class="language-python">import re
re.findall(r&#39;\bf[a-z]*&#39;, &#39;which foot or hand fell fastest&#39;)
re.sub(r&#39;(\b[a-z]+) \1&#39;, r&#39;\1&#39;, &#39;cat in the the hat&#39;)
# 只需要简单的功能时，首选字符串方法
&#39;tea for too&#39;.replace(&#39;too&#39;, &#39;two&#39;)</code></pre>
      <h2 id="new 命令">new 命令</h2>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <p>使用new命令时，它后面的函数依次执行下面的步骤。</p>
      <ul>
        <li>创建一个空对象，作为将要返回的对象实例。</li>
        <li>将这个空对象的原型，指向构造函数的prototype属性。</li>
        <li>将这个空对象赋值给函数内部的this关键字。</li>
        <li>开始执行构造函数内部的代码。</li>
      </ul>
      <pre><code class="language-js">// new命令简化的内部流程，可以用下面的代码表示。
function _new(/* 构造函数 */ constructor, /* 构造函数参数 */ params) {
  // 将 arguments 对象转为数组
  var args = [].slice.call(arguments);
  // 取出构造函数
  var constructor = args.shift();
  // 创建一个空对象，继承构造函数的 prototype 属性
  var context = Object.create(constructor.prototype);
  // 执行构造函数
  var result = constructor.apply(context, args);
  // 如果返回结果是对象，就直接返回，否则返回 context 对象
  return (typeof result === &#39;object&#39; &amp;&amp; result != null) ? result : context;
}
// 实例
var actor = _new(Person, &#39;张三&#39;, 28);

// 函数内部可以使用new.target属性。
// 如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。
function f() {
  console.log(new.target === f);
}
f() // false
new f() // true

// 使用这个属性，可以判断函数调用的时候，是否使用new命令。
function f() {
  if (!new.target) {
    throw new Error(&#39;请使用 new 命令调用！&#39;);
  }
  // ...
}
f() // Uncaught Error: 请使用 new 命令调用！</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="this关键字">this关键字</h2>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <p>简单说，this就是属性或方法“当前”所在的对象。</p>
      <ul>
        <li>全局环境使用this，它指的就是顶层对象window。</li>
        <li>构造函数中的this，指的是实例对象。</li>
        <li>
          如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。
        </li>
      </ul>
      <pre><code class="language-js">function f() {
  return &#39;姓名：&#39;+ this.name;
}
var A = {
  name: &#39;张三&#39;,
  describe: f
};
var B = {
  name: &#39;李四&#39;,
  describe: f
};
A.describe() // &quot;姓名：张三&quot;
B.describe() // &quot;姓名：李四&quot;

// 情况一
(obj.foo = obj.foo)() // window
// 情况二
(false || obj.foo)() // window
// 情况三
(1, obj.foo)() // window
// 上面代码中，obj.foo就是一个值。这个值真正调用的时候，
// 运行环境已经不是obj了，而是全局环境

var a = {
  p: &#39;Hello&#39;,
  b: {
    m: function() {
      console.log(this.p);
    }
  }
};
a.b.m() // undefined
// 上面代码中，a.b.m方法在a对象的第二层，
// 该方法内部的this不是指向a，而是指向a.b

var a = {
  b: {
    m: function() {
      console.log(this.p);
    },
    p: &#39;Hello&#39;
  }
};
var hello = a.b.m;
hello() // undefined
// 为了避免这个问题，可以只将m所在的对象赋值给hello
var hello = a.b;
hello.m() // Hello


// 绑定 this 的方法
// Function.prototype.call()
// call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。
// 如果参数为空、null和undefined，则默认传入全局对象。
var n = 123;
var obj = { n: 456 };
function a() {
  console.log(this.n);
}
a.call() // 123
a.call(null) // 123
a.call(undefined) // 123
a.call(window) // 123
a.call(obj) // 456

// apply方法的作用与call方法类似
// 唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。
func.apply(thisValue, [arg1, arg2, ...])
// 找出数组最大元素
var a = [10, 2, 4, 15, 9];
Math.max.apply(null, a) // 15
Math.max.call(null, ...a) // 15


// Function.prototype.bind()
// bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。
var d = new Date();
d.getTime() // 1481869925657
var print = d.getTime;
print() // Uncaught TypeError: this is not a Date object.

var print = d.getTime.bind(d);
print() // 1481869925657

var counter = {
  count: 0,
  inc: function () {
    this.count++;
  }
};
var func = counter.inc.bind(counter);
func();
counter.count // 1</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="原型链">原型链</h2>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <ul>
        <li><p>一切（引用类型）都是对象，对象是属性的集合</p></li>
        <li><p>对象是通过函数创建的</p></li>
        <li>
          <p>
            每个（构造）函数都有一个<code>prototype</code>属性，指向<code
              >原型对象</code
            >
          </p>
        </li>
        <li>
          <p>
            每个（原型）对象都应该有一个<code>constructor</code>属性，指向<code
              >构造函数</code
            >
          </p>
        </li>
        <li>
          <p>
            每个（实例）对象都有一个<code>__proto__</code>属性，指向<code
              >原型对象</code
            >
          </p>
        </li>
        <li><p>所有实例对象共享同一个prototype对象</p></li>
        <li><p>函数是有Function创建的，Function是被自身创建的</p></li>
        <li>
          <p>
            Object是作为众多new出来的实例的基类 ， function Object(){ [ native
            code ] }。
          </p>
        </li>
        <li>
          <p>
            Function是作为众多function出来的函数的基类 ，function Function(){ [
            native code ] }。
          </p>
        </li>
        <li>
          <p>
            构造函数的<strong>proto</strong>(包括Function和Object)都指向Function.prototype。
          </p>
        </li>
        <li><p>原型对象的<strong>proto</strong>都指向Object.prototype。</p></li>
        <li><p>Object.prototype.<strong>proto</strong>指向null。</p></li>
        <li>
          <p>
            所有的对象(对象，函数)都有<strong>proto</strong>属性(隐式原型)，指向构造该对象的构造函数的原型。
          </p>
        </li>
        <li>
          <p>
            只有函数function才具有prototype属性(显式原型)。
            这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。
            原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。
          </p>
        </li>
      </ul>
      <p><img src="./images/prototype.png" alt="原型链图示" /></p>
      <pre><code class="language-sh">var F = function () {};
var f = new F();

        F.prototype
|---|  ---------------&gt;   |-------------|
| F |                     |             |
|---|  &lt;---------------   |             |
        o.constructor     |             |
                          |       o     |
                          |             |
|---|   f.__proto__       |             |
| f |  ---------------&gt;   |-------------|
|---|</code></pre>
      <pre><code class="language-js">// 构造函数（Fn）
// 原型对象 (Prototype)
// 实例对象（obj）
function Fn(){}
var obj = new Fn()

Fn.prototype.constructor === Fn // 原型自动获得constructor属性，指向构造函数
obj.__proto__ === Fn.prototype   // __proto__指向原型对象，此属性在非浏览器的环境不一定部署
obj.__proto__.constructor === Fn

obj.constructor === obj.__proto__.constructor // 实例继承原型对象的属性
obj.constructor === Fn // 继承得来


// Object.getPrototypeOf方法返回参数对象的原型。
// 这是获取原型对象的标准方法。
var F = function () {};
var f = new F();
Object.getPrototypeOf(f) === F.prototype // true
// 空对象的原型是 Object.prototype
Object.getPrototypeOf({}) === Object.prototype // true
// Object.prototype 的原型是 null
Object.getPrototypeOf(Object.prototype) === null // true
// 函数的原型是 Function.prototype
function f() {}
Object.getPrototypeOf(f) === Function.prototype // true


// 它接受两个参数，第一个是现有对象，第二个是原型对象。
var a = {};
var b = {x: 1};
Object.setPrototypeOf(a, b);

Object.getPrototypeOf(a) === b // true
a.x // 1


// new命令可以使用Object.setPrototypeOf方法模拟。
var F = function () {
  this.foo = &#39;bar&#39;;
};
var f = new F();
// 等同于
var f = Object.setPrototypeOf({}, F.prototype);
F.call(f);
// 第一步，将一个空对象的原型设为构造函数的prototype属性（上例是F.prototype）；
// 第二步，将构造函数内部的this绑定这个空对象，然后执行构造函数，
// 使得定义在this上面的方法和属性（上例是this.foo），都转移到这个空对象上。


// JavaScript 提供了Object.create方法，用来满足这种需求。
// 该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。
// 该实例完全继承原型对象的属性。

// 原型对象
var A = {
  print: function () {
    console.log(&#39;hello&#39;);
  }
};
// 实例对象
var B = Object.create(A);
Object.getPrototypeOf(B) === A // true
B.print() // hello
B.print === A.print // true

// 实际上，Object.create方法可以用下面的代码代替。
// Object.create方法的实质是新建一个空的构造函数F，
// 然后让F.prototype属性指向参数对象obj，
// 最后返回一个F的实例，从而实现让该实例继承obj的属性。
if (typeof Object.create !== &#39;function&#39;) {
  Object.create = function (obj) {
    function F() {}
    F.prototype = obj;
    return new F();
  };
}

// 下面三种方式生成的新对象是等价的。
var obj1 = Object.create({});
var obj2 = Object.create(Object.prototype);
var obj3 = new Object();

// Object.create方法生成的新对象，动态继承了原型。
// 在原型上添加或修改任何方法，会立刻反映在新对象之上。
var obj1 = { p: 1 };
var obj2 = Object.create(obj1);
obj1.p = 2;
obj2.p // 2

// Object.create方法还可以接受第二个参数
var obj = Object.create({}, {
  p1: {
    value: 123,
    enumerable: true,
    configurable: true,
    writable: true,
  },
  p2: {
    value: &#39;abc&#39;,
    enumerable: true,
    configurable: true,
    writable: true,
  }
});
// 等同于
var obj = Object.create({});
obj.p1 = 123;
obj.p2 = &#39;abc&#39;;

// Object.create方法生成的对象，继承了它的原型对象的构造函数。
function A() {}
var a = new A();
var b = Object.create(a);
b.constructor === A // true
b instanceof A // true

// 实例对象的isPrototypeOf方法，用来判断该对象是否为参数对象的原型。
// o1和o2都是o3的原型。
var o1 = {};
var o2 = Object.create(o1);
var o3 = Object.create(o2);
o2.isPrototypeOf(o3) // true
o1.isPrototypeOf(o3) // true
Object.prototype.isPrototypeOf({}) // true
Object.prototype.isPrototypeOf([]) // true
Object.prototype.isPrototypeOf(/xyz/) // true
Object.prototype.isPrototypeOf(Object.create(null)) // false


// 实例对象的__proto__属性（前后各两个下划线），返回该对象的原型。该属性可读写。
var obj = {};
var p = {};
obj.__proto__ = p;
Object.getPrototypeOf(obj) === p // true

// 原型链可以用__proto__很直观地表示。
var A = {
  name: &#39;张三&#39;
};
var B = {
  name: &#39;李四&#39;
};
var proto = {
  print: function () {
    console.log(this.name);
  }
};
A.__proto__ = proto;
B.__proto__ = proto;
A.print() // 张三
B.print() // 李四
A.print === B.print // true
A.print === proto.print // true
B.print === proto.print // true

// __proto__属性指向当前实例对象的原型对象，即构造函数的prototype属性。
var obj = new Object();
obj.__proto__ === Object.prototype // true
obj.__proto__ === obj.constructor.prototype // true

// 获取实例对象obj的原型对象，有三种方法。
obj.__proto__
obj.constructor.prototype
Object.getPrototypeOf(obj)


var P = function () {};
var p = new P();
var C = function () {};
C.prototype = p;
var c = new C();
c.constructor === p.constructor // true
c.constructor === P // true
c.constructor === C // false
c.constructor.prototype === p // false
// 构造函数C的 prototype 被改成了p，
// 但是实例对象c的 constructor 却没有指向C。
// 所以，在改变原型对象时，一般要同时设置constructor属性
var P = function () {};
var p = new P();
var C = function () {};
C.prototype = p;
C.prototype.constructor = C;
// 或者 p.constructor = C
var c = new C();
c.constructor.prototype === p // true
p.constructor === C // true
p.__proto__.constructor === P // true

// 坏的写法
C.prototype = {
  method1: function (...) { ... },
  // ...
};

// 好的写法
C.prototype = {
  constructor: C,
  method1: function (...) { ... },
  // ...
};

// 更好的写法
C.prototype.method1 = function (...) { ... };</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="获取对象的所有属性">获取对象的所有属性</h2>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">Reflect.ownKeys(&#39;&#39;.__proto__)
Reflect.ownKeys(String.prototype)

// Object.getOwnPropertyNames方法返回一个数组，
// 成员是参数对象本身的所有属性的键名，不包含继承的属性键名。
Object.getOwnPropertyNames(Date)

// 只获取那些可以遍历的属性，使用Object.keys方法。
Object.keys({a:1});

// in运算符返回一个布尔值，表示一个对象是否具有某个属性。
// 它不区分该属性是对象自身的属性，还是继承的属性。
&#39;length&#39; in Date // true
&#39;toString&#39; in Date // true

// 获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用for...in循环。
var o1 = { p1: 123 };
var o2 = Object.create(o1, {
  p2: { value: &quot;abc&quot;, enumerable: true }
});
for (p in o2) {
  console.info(p);
}
// p2
// p1

// 为了在for...in循环中获得对象自身的属性，可以采用hasOwnProperty方法判断一下
for ( var name in object ) {
  if ( object.hasOwnProperty(name) ) {
    /* loop code */
  }
}

// 获得对象的所有属性（不管是自身的还是继承的，也不管是否可枚举），可以使用下面的函数。
function inheritedPropertyNames(obj) {
  var props = {};
  while(obj) {
    Object.getOwnPropertyNames(obj).forEach(function(p) {
      props[p] = true;
    });
    obj = Object.getPrototypeOf(obj);
  }
  return Object.getOwnPropertyNames(props);
}</code></pre>
      <p>python</p>
      <pre><code class="language-python">dir(sys)</code></pre>
      <h2 id="对象的拷贝">对象的拷贝</h2>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <p>如果要拷贝一个对象，需要做到下面两件事情。</p>
      <ul>
        <li>确保拷贝后的对象，与原对象具有同样的原型。</li>
        <li>确保拷贝后的对象，与原对象具有同样的实例属性。</li>
      </ul>
      <pre><code class="language-js">function copyObject(orig) {
  var copy = Object.create(Object.getPrototypeOf(orig));
  copyOwnPropertiesFrom(copy, orig);
  return copy;
}
function copyOwnPropertiesFrom(target, source) {
  Object
    .getOwnPropertyNames(source)
    .forEach(function (propKey) {
      var desc = Object.getOwnPropertyDescriptor(source, propKey);
      Object.defineProperty(target, propKey, desc);
    });
  return target;
}

// 另一种更简单的写法
function copyObject(orig) {
  return Object.create(
    Object.getPrototypeOf(orig),
    Object.getOwnPropertyDescriptors(orig)
  );
}


const originalDict = { one: 1, two: 2, three: 3 }
const newDict = { ...originalDict }
originalDict.one = 100
// one 1
// two 2
// three 3
Object.entries(newDict).forEach(element =&gt; {
  console.log(`${element[0]} ${element[1]}`)
})</code></pre>
      <p>python</p>
      <pre><code class="language-python">original_dict = {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3}
new_dict = original_dict.copy()
original_dict[&quot;one&quot;] = 100

# one 1
# two 2
# three 3
for key, value in new_dict.items():
    print(f&quot;{key} {value}&quot;)</code></pre>
    </div>
    <script src="./highlight/highlight.pack.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>
