<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>3.操作符及流程控制.md</title>
    <link rel="stylesheet" href="./styles.css" />
    <link rel="stylesheet" href="./highlight/styles/github.css" />
  </head>
  <body>
    <div id="nav">
      <ul>
        <li>
          <a
            href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"
            >操作符及流程控制</a
          >
          <ul>
            <li>
              <a href="#%E6%93%8D%E4%BD%9C%E7%AC%A6">操作符</a>
              <ul>
                <li>
                  <a href="#%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6"
                    >算术操作符</a
                  >
                </li>
                <li>
                  <a
                    href="#%E7%9B%B8%E7%AD%89%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C%E7%AC%A6"
                    >相等大小操作符</a
                  >
                </li>
                <li>
                  <a
                    href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E6%93%8D%E4%BD%9C%E7%AC%A6"
                    >类型判断操作符</a
                  >
                </li>
                <li>
                  <a href="#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6"
                    >赋值操作符</a
                  >
                </li>
                <li>
                  <a href="#%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"
                    >逻辑操作符</a
                  >
                </li>
                <li>
                  <a
                    href="#%E4%BD%8D%E5%92%8C%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"
                    >位和移位操作符</a
                  >
                </li>
                <li>
                  <a href="#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"
                    >条件表达式</a
                  >
                </li>
                <li>
                  <a href="#%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C%E7%AC%A6"
                    >级联操作符</a
                  >
                </li>
                <li>
                  <a
                    href="#%E6%9D%A1%E4%BB%B6%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE"
                    >条件成员访问</a
                  >
                </li>
              </ul>
            </li>
            <li>
              <a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">流程控制</a>
              <ul>
                <li><a href="#IfElse">IfElse</a></li>
                <li><a href="#For">For</a></li>
                <li><a href="#range">range</a></li>
                <li><a href="#While">While</a></li>
                <li><a href="#BreakContinue">BreakContinue</a></li>
                <li><a href="#pass">pass</a></li>
                <li><a href="#Switch">Switch</a></li>
                <li><a href="#defer">defer</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </div>
    <div id="content">
      <h1 id="操作符及流程控制">操作符及流程控制</h1>
      <h2 id="操作符">操作符</h2>
      <h3 id="算术操作符">算术操作符</h3>
      <p>dart</p>
      <pre><code class="language-dart">// +, -, /, *
// 位移操作符，&lt;&lt;,&gt;&gt;,&amp;,|
// ~/ 除号，但是返回值为整数
// % 取模</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">// +, -, /, *
// 位移操作符，&lt;&lt;,&gt;&gt;,&amp;,|,~,^

// 指数运算符：x ** y
// 余数运算符：x % y
// 自增运算符：++x 或者 x++
// 自减运算符：--x 或者 x--</code></pre>
      <p>python</p>
      <pre><code class="language-python"># +, -, /, *
# 位移操作符，&lt;&lt;,&gt;&gt;,&amp;,|,~,^

# 除法运算 (/) 永远返回浮点数类型
# 使用 // 运算符得到一个整数结果（忽略小数部分）
# 如果要计算余数，可以使用 %
# 使用 ** 运算符来计算乘方</code></pre>
      <h3 id="相等大小操作符">相等大小操作符</h3>
      <p>dart</p>
      <ul>
        <li>要测试两个对象代表的是否为同样的内容，使用 == 操作符。</li>
        <li>两个对象是否是同一个对象， 使用 identical() 方法。</li>
      </ul>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="类型判断操作符">类型判断操作符</h3>
      <p>dart</p>
      <ul>
        <li>as 类型转换</li>
        <li>is 如果对象是指定的类型返回 True</li>
        <li>is! 如果对象是指定的类型返回 False</li>
      </ul>
      <pre><code class="language-dart">if (emp is Person) { // Type check
  emp.firstName = &#39;Bob&#39;;
}
// 使用 as 操作符可以简化上面的代码：
(emp as Person).firstName = &#39;Bob&#39;;
// 上面这两个代码效果是有区别的。
// 如果 emp 是 null 或者不是 Person 类型， 
// 则第一个示例使用 is 则不会执行条件里面的代码，
// 而第二个情况使用 as 则会抛出一个异常。</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="赋值操作符">赋值操作符</h3>
      <p>dart</p>
      <pre><code class="language-dart">a = value;   // 给 a 变量赋值
b ??= value; // 如果 b 是 null，则赋值给 b；
             // 如果不是 null，则 b 的值保持不变</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="逻辑操作符">逻辑操作符</h3>
      <p>dart</p>
      <ul>
        <li>!expr 对表达式结果取反（true 变为 false ，false 变为 true）</li>
        <li>|| 逻辑 OR</li>
        <li>&amp;&amp; 逻辑 AND</li>
        <li>只能对布尔值进行判断</li>
      </ul>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <ul>
        <li>能够对所有数据类型进行判断，判断时自动转换为布尔值</li>
      </ul>
      <pre><code class="language-js">// yes
if (&#39;abc&#39; === &#39;abc&#39;) {
  console.log(&#39;yes&#39;)
} else {
  console.log(&#39;no&#39;)
}

// yes
if (&#39;abc&#39; !== &#39;def&#39;) {
  console.log(&#39;yes&#39;)
} else {
  console.log(&#39;no&#39;)
}

// no
if (true &amp;&amp; false) {
  console.log(&#39;yes&#39;)
} else {
  console.log(&#39;no&#39;)
}

// yes
if (true || false) {
  console.log(&#39;yes&#39;)
} else {
  console.log(&#39;no&#39;)
}

// yes
if (!false) {
  console.log(&#39;yes&#39;)
} else {
  console.log(&#39;no&#39;)
}

// no
if (0) {
  console.log(&#39;yes&#39;)
} else {
  console.log(&#39;no&#39;)
}

// no
if (&#39;&#39;) {
  console.log(&#39;yes&#39;)
} else {
  console.log(&#39;no&#39;)
}

// no
if (undefined) {
  console.log(&#39;yes&#39;)
} else {
  console.log(&#39;no&#39;)
}

// no
if (null) {
  console.log(&#39;yes&#39;)
} else {
  console.log(&#39;no&#39;)
}

// yes
if (!!!null) {
  console.log(&#39;yes&#39;)
} else {
  console.log(&#39;no&#39;)
}</code></pre>
      <p>python</p>
      <pre><code class="language-python"># yes
if &quot;abc&quot; == &quot;abc&quot;:
    print(&quot;yes&quot;)
else:
    print(&quot;no&quot;)

# yes
if &quot;abc&quot; != &quot;def&quot;:
    print(&quot;yes&quot;)
else:
    print(&quot;no&quot;)

# no
if True and False:
    print(&quot;yes&quot;)
else:
    print(&quot;no&quot;)

# yes
if True or False:
    print(&quot;yes&quot;)
else:
    print(&quot;no&quot;)

# yes
if not False:
    print(&quot;yes&quot;)
else:
    print(&quot;no&quot;)

# no
if 0:
    print(&quot;yes&quot;)
else:
    print(&quot;no&quot;)

# no
if &quot;&quot;:
    print(&quot;yes&quot;)
else:
    print(&quot;no&quot;)

# no
if []:
    print(&quot;yes&quot;)
else:
    print(&quot;no&quot;)

# no
if None:
    print(&quot;yes&quot;)
else:
    print(&quot;no&quot;)

# yes
if not not not None:
    print(&quot;yes&quot;)
else:
    print(&quot;no&quot;)</code></pre>
      <h3 id="位和移位操作符">位和移位操作符</h3>
      <p>dart</p>
      <pre><code class="language-dart">final value = 0x22;
final bitmask = 0x0f;

assert((value &amp; bitmask)  == 0x02);  // AND
assert((value &amp; ~bitmask) == 0x20);  // AND NOT
assert((value | bitmask)  == 0x2f);  // OR
assert((value ^ bitmask)  == 0x2d);  // XOR
assert((value &lt;&lt; 4)       == 0x220); // Shift left
assert((value &gt;&gt; 4)       == 0x02);  // Shift right</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="条件表达式">条件表达式</h3>
      <p>Conditional expressions（条件表达式）/三元操作符</p>
      <p>dart</p>
      <ul>
        <li>
          condition ? expr1 : expr2 如果 condition 是 true，执行 expr1
          (并返回执行的结果)； 否则执行 expr2 并返回其结果。
        </li>
        <li>
          expr1 ?? expr2 如果 expr1 是 non-null，返回其值； 否则执行 expr2
          并返回其结果。
        </li>
      </ul>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">const x = 2
const y = 3

// even
console.log(x % 2 === 0 ? &#39;even&#39; : &#39;odd&#39;)
// odd
console.log(y % 2 === 0 ? &#39;even&#39; : &#39;odd&#39;)</code></pre>
      <p>python</p>
      <pre><code class="language-python">x = 2
y = 3

# even
print(&quot;even&quot; if x % 2 == 0 else &quot;odd&quot;)
# odd
print(&quot;even&quot; if y % 2 == 0 else &quot;odd&quot;)</code></pre>
      <h3 id="级联操作符">级联操作符</h3>
      <p>dart</p>
      <p>
        级联操作符 (..) 可以在同一个对象上 连续调用多个函数以及访问成员变量。
      </p>
      <pre><code class="language-dart">querySelector(&#39;#button&#39;) // Get an object.
  ..text = &#39;Confirm&#39;   // Use its members.
  ..classes.add(&#39;important&#39;)
  ..onClick.listen((e) =&gt; window.alert(&#39;Confirmed!&#39;));
// 上面的代码和下面的代码功能一样：
var button = querySelector(&#39;#button&#39;);
button.text = &#39;Confirm&#39;;
button.classes.add(&#39;important&#39;);
button.onClick.listen((e) =&gt; window.alert(&#39;Confirmed!&#39;));</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="条件成员访问">条件成员访问</h3>
      <p>dart</p>
      <p>
        ?. 和 . 类似，但是左边的操作对象不能为 null， 例如 foo?.bar 如果 foo 为
        null 则返回 null，否则返回 bar 成员
      </p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="流程控制">流程控制</h2>
      <h3 id="IfElse">IfElse</h3>
      <p>dart</p>
      <pre><code class="language-dart">if (isRaining()) {
  you.bringRainCoat();
} else if (isSnowing()) {
  you.wearJacket();
} else {
  car.putTopDown();
}</code></pre>
      <p>go</p>
      <p>
        Go 的 if 语句与 for 循环类似，表达式外无需小括号 ( ) ，而大括号 { }
        则是必须的。
      </p>
      <pre><code class="language-go">package main
import (
  &quot;fmt&quot;
  &quot;math&quot;
)
func sqrt(x float64) string {
  if x &lt; 0 {
    return sqrt(-x) + &quot;i&quot;
  }
  return fmt.Sprint(math.Sqrt(x))
}
func main() {
  fmt.Println(sqrt(2), sqrt(-4)) // 1.4142135623730951 2i
}


// 同 for 一样， if 语句可以在条件表达式前执行一个简单的语句。
// 该语句声明的变量作用域仅在 if 之内。
package main
import (
  &quot;fmt&quot;
  &quot;math&quot;
)
func pow(x, n, lim float64) float64 {
  if v := math.Pow(x, n); v &lt; lim {
    return v
  }
  return lim
}
func main() {
  fmt.Println(
    pow(3, 2, 10),
    pow(3, 3, 20),
  )
}


// 在 if 的简短语句中声明的变量同样可以在任何对应的 else 块中使用。
package main
import (
  &quot;fmt&quot;
  &quot;math&quot;
)
func pow(x, n, lim float64) float64 {
  if v := math.Pow(x, n); v &lt; lim {
    return v
  } else {
    fmt.Printf(&quot;%g &gt;= %g\n&quot;, v, lim)
  }
  // 这里开始就不能使用 v 了
  return lim
}
func main() {
  fmt.Println(
    pow(3, 2, 10),
    pow(3, 3, 20),
  )
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"># 一个 if ... elif ... elif ... 序列
# 可以看作是其他语言中的 switch 或 case 语句的替代
x = int(input(&quot;Please enter an integer: &quot;))

if x &lt; 0:
    x = 0
    print(&#39;Negative changed to zero&#39;)
elif x == 0:
    print(&#39;Zero&#39;)
elif x == 1:
    print(&#39;Single&#39;)
else:
    print(&#39;More&#39;)</code></pre>
      <h3 id="For">For</h3>
      <p>dart</p>
      <pre><code class="language-dart">var message = new StringBuffer(&quot;Dart is fun&quot;);
for (var i = 0; i &lt; 5; i++) {
  message.write(&#39;!&#39;);
}

// art for 循环中的闭包会捕获循环的 index 索引值
var callbacks = [];
for (var i = 0; i &lt; 2; i++) {
  callbacks.add(() =&gt; print(i));
}
callbacks.forEach((c) =&gt; c());

// 如果不需要当前遍历的索引
candidates.forEach((candidate) =&gt; candidate.interview());

// List 和 Set 等实现了 Iterable 接口的类还支持 for-in 形式的 遍历：
var collection = [0, 1, 2];
for (var x in collection) {
  print(x);
}</code></pre>
      <p>go</p>
      <p>
        Go 只有一种循环结构：for 循环。
        初始化语句通常为一句短变量声明，该变量声明仅在 for 语句的作用域中可见。
      </p>
      <ul>
        <li>初始化语句：在第一次迭代前执行</li>
        <li>条件表达式：在每次迭代前求值</li>
        <li>后置语句：在每次迭代的结尾执行</li>
      </ul>
      <p>
        和 C、Java、JavaScript 之类的语言不同， Go 的 for
        语句后面的三个构成部分外没有小括号， 大括号 { } 则是必须的。
      </p>
      <pre><code class="language-go">// 如同C的for循环
for init; condition; post { }

// 如同C的while循环
for condition { }

// 如同C的for(;;)循环
for { }


package main
import &quot;fmt&quot;
func main() {
  sum := 1
  for i := 0; i &lt; 10; i++ {
    sum *= 2
  }
  fmt.Println(sum) // 1024
}


// 初始化语句和后置语句是可选的。
// 相当于while循环
package main
import &quot;fmt&quot;
func main() {
  sum := 1
  for ; sum &lt; 1000; {
    sum += sum
  }
  fmt.Println(sum) // 1024
}

// for 是 Go 中的 “while”
package main
import &quot;fmt&quot;
func main() {
  sum := 1
  for sum &lt; 1000 {
    sum += sum
  }
  fmt.Println(sum)
}

// 无限循环
// 如果省略循环条件，该循环就不会结束
package main
func main() {
  for {
    // ...
  }
}


// 用牛顿法实现平方根函数
package main
import (
  &quot;fmt&quot;
)
func Sqrt(x float64) float64 {
  z := 1.8
  for n:=0; n&lt;10; n++ {
    fmt.Println(z)
    z -= (z*z - x) / (2*z)
  }
  return z
}
func main() {
  fmt.Println(Sqrt(2))
}
// 1.8
// 1.4555555555555555
// 1.4148006785411367
// 1.4142136841942816
// 1.4142135623731005
// 1.414213562373095
// 1.4142135623730951
// 1.414213562373095
// 1.4142135623730951
// 1.414213562373095
// 1.4142135623730951


// range 子句能够帮你轻松实现循环
for key, value := range oldMap {
  newMap[key] = value
}

// 解析UTF-8， 将每个独立的Unicode码点分离出来
for pos, char := range &quot;日本\x80語&quot; { // \x80 是个非法的UTF-8编码
  fmt.Printf(&quot;字符 %#U 始于字节位置 %d\n&quot;, char, pos)
}

// 反转 a
for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 {
  a[i], a[j] = a[j], a[i]
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"># Measure some strings:
words = [&#39;cat&#39;, &#39;window&#39;, &#39;defenestrate&#39;]
for w in words:
    print(w, len(w))

# 如果在循环内需要修改序列中的值（比如重复某些选中的元素），推荐你先拷贝一份副本。
for w in words[:]:  # Loop over a slice copy of the entire list.
    if len(w) &gt; 6:
        words.insert(0, w)
# [&#39;defenestrate&#39;, &#39;cat&#39;, &#39;window&#39;, &#39;defenestrate&#39;]
# 如果写成 for w in words:，这个示例就会创建无限长的列表，
# 一次又一次重复地插入 defenestrate。</code></pre>
      <h3 id="range">range</h3>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <p>
        for 循环的 range 形式可遍历切片或映射。 当使用 for
        循环遍历切片时，每次迭代都会返回两个值。
      </p>
      <ul>
        <li>第一个值为当前元素的下标，</li>
        <li>第二个值为该下标所对应元素的一份副本。</li>
      </ul>
      <pre><code class="language-go">package main
import &quot;fmt&quot;
var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}
func main() {
  for i, v := range pow {
    fmt.Printf(&quot;2**%d = %d\n&quot;, i, v)
  }
}
// 2**0 = 1
// 2**1 = 2
// 2**2 = 4
// 2**3 = 8
// 2**4 = 16
// 2**5 = 32
// 2**6 = 64
// 2**7 = 128


// 可以将下标或值赋予 _ 来忽略它。
package main
import &quot;fmt&quot;
func main() {
  pow := make([]int, 5)
  for i := range pow {
    pow[i] = 1 &lt;&lt; uint(i) // == 2**i
  }
  for _, value := range pow {
    fmt.Printf(&quot;%d\n&quot;, value)
  }
}
// 1
// 2
// 4
// 8
// 16</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-sh"># 内置函数 range() 会派上用场。它生成算术级数:
&gt;&gt;&gt; for i in range(5):
...     print(i)
...
0
1
2
3
4

# range也可以以另一个数字开头，或者以指定的幅度增加
range(5, 10)
   5, 6, 7, 8, 9

range(0, 10, 3)
   0, 3, 6, 9

range(-10, -100, -30)
  -10, -40, -70

# 要以序列的索引来迭代，您可以将 range() 和 len() 组合如下:
# 然而，在大多数这类情况下，使用 enumerate() 函数比较方便
&gt;&gt;&gt; a = [&#39;Mary&#39;, &#39;had&#39;, &#39;a&#39;, &#39;little&#39;, &#39;lamb&#39;]
&gt;&gt;&gt; for i in range(len(a)):
...     print(i, a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb

# range 返回的是一个可迭代对象
&gt;&gt;&gt; print(range(10))
range(0, 10)
&gt;&gt;&gt; list(range(5))
[0, 1, 2, 3, 4]</code></pre>
      <h3 id="While">While</h3>
      <p>dart</p>
      <pre><code class="language-dart">while (!isDone()) {
  doSomething();
}

do {
  printLine();
} while (!atEndOfPage());</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="BreakContinue">BreakContinue</h3>
      <p>dart</p>
      <pre><code class="language-dart">// 使用 break 来终止循环：
while (true) {
  if (shutDownRequested()) break;
  processIncomingRequests();
}
// 使用 continue 来开始下一次循环：
for (int i = 0; i &lt; candidates.length; i++) {
  var candidate = candidates[i];
  if (candidate.yearsExperience &lt; 5) {
    continue;
  }
  candidate.interview();
}
// 上面的代码在实现 Iterable 接口对象上可以使用下面的写法：
candidates.where((c) =&gt; c.yearsExperience &gt;= 5)
          .forEach((c) =&gt; c.interview());</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">// 1
// 2
// Fizz
// 4
// Buzz
for (let i = 1; i &lt;= 100; i = i + 1) {
  if (i === 3) {
    console.log(&#39;Fizz&#39;)
    continue
  }

  if (i === 5) {
    console.log(&#39;Buzz&#39;)
    break
  }

  console.log(i)
}</code></pre>
      <p>python</p>
      <pre><code class="language-python"># 1
# 2
# Fizz
# 4
# Buzz
for number in range(1, 101):
    if number == 3:
        print(&quot;Fizz&quot;)
        continue
    if number == 5:
        print(&quot;Buzz&quot;)
        break
    print(number)</code></pre>
      <pre><code class="language-sh"># 循环语句可能带有一个 else 子句；
# 它会在循环遍历完列表 (使用 for) 或是在条件变为假 (使用 while) 的时候被执行，
# 但是不会在循环被 break 语句终止时被执行。

# 当和循环一起使用时，else 子句与 try 语句中的 else 子句的共同点多于 if 语句中的子句:
# try 语句中的 else 子句会在未发生异常时执行，
# 而循环中的 else 子句则会在未发生 break 时执行。

# 计算质数(素数)
&gt;&gt;&gt; for n in range(2, 10):
...     for x in range(2, n):
...         if n % x == 0:
...             print(n, &#39;equals&#39;, x, &#39;*&#39;, n//x)
...             break
...     else: # else 子句属于 for 循环， 不属于 if 语句。
...         # loop fell through without finding a factor
...         print(n, &#39;is a prime number&#39;)
...
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3

# continue 语句也是借鉴自 C 语言，表示继续循环中的下一次迭代:
&gt;&gt;&gt; for num in range(2, 10):
...     if num % 2 == 0:
...         print(&quot;Found an even number&quot;, num)
...         continue
...     print(&quot;Found a number&quot;, num)
Found an even number 2
Found a number 3
Found an even number 4
Found a number 5
Found an even number 6
Found a number 7
Found an even number 8
Found a number 9</code></pre>
      <h3 id="pass">pass</h3>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python">while True:
    pass  # Busy-wait for keyboard interrupt (Ctrl+C)

class MyEmptyClass:
    pass

def initlog(*args):
    pass   # Remember to implement this!</code></pre>
      <h3 id="Switch">Switch</h3>
      <p>dart</p>
      <p>
        Dart 中的 Switch 语句使用 == 比较 integer、string、或者编译时常量。
        比较的对象必须都是同一个类的实例（并且不是 其子类）
      </p>
      <p>
        每个非空的 case 语句都必须有一个 break 语句。 另外还可以通过 continue、
        throw 或 者 return 来结束非空 case 语句。 当没有 case
        语句匹配的时候，可以使用 default 语句来匹配这种默认情况。
      </p>
      <pre><code class="language-dart">var command = &#39;OPEN&#39;;
switch (command) {
  case &#39;CLOSED&#39;:
    executeClosed();
    break;
  case &#39;PENDING&#39;:
    executePending();
    break;
  case &#39;APPROVED&#39;:
    executeApproved();
    break;
  case &#39;DENIED&#39;:
    executeDenied();
    break;
  case &#39;OPEN&#39;:
    executeOpen();
    break;
  default:
    executeUnknown();
}

// 在 Dart 中的空 case 语句中可以不要 break 语句：
var command = &#39;CLOSED&#39;;
switch (command) {
  case &#39;CLOSED&#39;: // Empty case falls through.
  case &#39;NOW_CLOSED&#39;:
    // Runs for both CLOSED and NOW_CLOSED.
    executeNowClosed();
    break;
}

//  使用 continue 语句跳转到对应的标签（label）处继续执行
var command = &#39;CLOSED&#39;;
switch (command) {
  case &#39;CLOSED&#39;:
    executeClosed();
    continue nowClosed;
    // Continues executing at the nowClosed label.
nowClosed:
  case &#39;NOW_CLOSED&#39;:
    // Runs for both CLOSED and NOW_CLOSED.
    executeNowClosed();
    break;
}</code></pre>
      <p>go</p>
      <p>
        switch 是编写一连串 if - else 语句的简便方法。
        它运行第一个值等于条件表达式的 case 语句。
      </p>
      <p>
        Go 只运行选定的 case，而非之后所有的 case。 Go
        自动提供了在这些语言中每个 case 后面所需的 break 语句。 除非以
        fallthrough 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于
        switch 的 case 无需为常量，且取值不必为整数。
      </p>
      <pre><code class="language-go">package main
import (
  &quot;fmt&quot;
  &quot;runtime&quot;
)
func main() {
  fmt.Print(&quot;Go runs on &quot;)
  switch os := runtime.GOOS; os {
    case &quot;darwin&quot;:
      fmt.Println(&quot;OS X.&quot;)
    case &quot;linux&quot;:
      fmt.Println(&quot;Linux.&quot;)
    default:
      // freebsd, openbsd,
      // plan9, windows...
      fmt.Printf(&quot;%s.\n&quot;, os)
  }
}
// Go runs on Linux.


// switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。
package main
import (
  &quot;fmt&quot;
  &quot;time&quot;
)
func main() {
  fmt.Println(&quot;When&#39;s Saturday?&quot;)
  fmt.Println(time.Now())
  fmt.Println(time.Saturday)
  today := time.Now().Weekday()
  switch time.Saturday {
    case today + 0:
      fmt.Println(&quot;Today.&quot;)
    case today + 1:
      fmt.Println(&quot;Tomorrow.&quot;)
    case today + 2:
      fmt.Println(&quot;In two days.&quot;)
    default:
      fmt.Println(&quot;Too far away.&quot;)
  }
}
// When&#39;s Saturday?
// 2009-11-10 23:00:00 +0000 UTC m=+0.000000001
// Saturday
// Too far away.


// 没有条件的 switch 同 switch true 一样。
// 这种形式能将一长串 if-then-else 写得更加清晰。
package main
import (
  &quot;fmt&quot;
  &quot;time&quot;
)
func main() {
  t := time.Now()
  fmt.Println(t)
  switch {
    case t.Hour() &lt; 12:
      fmt.Println(&quot;Good morning!&quot;)
    case t.Hour() &lt; 17:
      fmt.Println(&quot;Good afternoon.&quot;)
    default:
      fmt.Println(&quot;Good evening.&quot;)
  }
}

func unhex(c byte) byte {
  switch {
  case &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;:
    return c - &#39;0&#39;
  case &#39;a&#39; &lt;= c &amp;&amp; c &lt;= &#39;f&#39;:
    return c - &#39;a&#39; + 10
  case &#39;A&#39; &lt;= c &amp;&amp; c &lt;= &#39;F&#39;:
    return c - &#39;A&#39; + 10
  }
  return 0
}

// switch 并不会自动下溯，但 case 可通过逗号分隔来列举相同的处理条件。
func shouldEscape(c byte) bool {
  switch c {
  case &#39; &#39;, &#39;?&#39;, &#39;&amp;&#39;, &#39;=&#39;, &#39;#&#39;, &#39;+&#39;, &#39;%&#39;:
    return true
  }
  return false
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="defer">defer</h3>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <p>
        defer 语句会将函数推迟到外层函数返回之后执行。
        推迟调用的函数其参数会立即求值，
        但直到外层函数返回前该函数都不会被调用。
      </p>
      <p>
        推迟的函数调用会被压入一个栈中。
        当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。
      </p>
      <pre><code class="language-go">package main
import &quot;fmt&quot;
func main() {
  defer fmt.Println(&quot;world&quot;)
  fmt.Println(&quot;hello&quot;)
}
// hello
// world


// defer 栈
package main
import &quot;fmt&quot;
func main() {
  fmt.Println(&quot;counting&quot;)
  for i := 0; i &lt; 10; i++ {
    defer fmt.Println(i)
  }
  fmt.Println(&quot;done&quot;)
}
// counting
// done
// 9
// 8
// 7
// 6
// 5
// 4
// 3
// 2
// 1
// 0


// Contents 将文件的内容作为字符串返回。
func Contents(filename string) (string, error) {
  f, err := os.Open(filename)
  if err != nil {
    return &quot;&quot;, err
  }
  defer f.Close()  // f.Close 会在我们结束后运行。

  var result []byte
  buf := make([]byte, 100)
  for {
    n, err := f.Read(buf[0:])
    result = append(result, buf[0:n]...) // append 将在后面讨论。
    if err != nil {
      if err == io.EOF {
        break
      }
      return &quot;&quot;, err  // 我们在这里返回后，f 就会被关闭。
    }
  }
  return string(result), nil // 我们在这里返回后，f 就会被关闭。
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
    </div>
    <script src="./highlight/highlight.pack.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>
