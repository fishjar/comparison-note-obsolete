<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>1.基础知识.md</title>
    <link rel="stylesheet" href="./styles.css" />
    <link rel="stylesheet" href="./highlight/styles/github.css" />
  </head>
  <body>
    <div id="nav">
      <ul>
        <li>
          <a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识</a>
          <ul>
            <li><a href="#hello">hello</a></li>
            <li>
              <a href="#helloword">helloword</a>
              <ul>
                <li><a href="#dart">dart</a></li>
                <li><a href="#go">go</a></li>
                <li><a href="#js">js</a></li>
                <li><a href="#python">python</a></li>
              </ul>
            </li>
            <li>
              <a href="#%E6%A6%82%E5%BF%B5">概念</a>
              <ul>
                <li><a href="#%E5%AE%89%E8%A3%85">安装</a></li>
                <li>
                  <a href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">常用命令</a>
                </li>
              </ul>
            </li>
            <li><a href="#%E4%BF%9D%E7%95%99%E5%AD%97">保留字</a></li>
            <li>
              <a href="#%E5%BA%93%E5%8C%85%E6%A8%A1%E5%9D%97">库包模块</a>
              <ul>
                <li>
                  <a href="#%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"
                    >包管理工具</a
                  >
                </li>
                <li>
                  <a href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84">项目结构</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="#%E5%91%BD%E5%90%8D%E9%A3%8E%E6%A0%BC">命名风格</a>
              <ul>
                <li><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6">标识符</a></li>
                <li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li>
                <li><a href="#%E6%89%93%E5%8D%B0">打印</a></li>
                <li><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96">格式化</a></li>
              </ul>
            </li>
            <li>
              <a href="#%E5%8F%98%E9%87%8F">变量</a>
              <ul>
                <li>
                  <a href="#%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F">私有变量</a>
                </li>
                <li><a href="#%E5%B8%B8%E9%87%8F">常量</a></li>
                <li><a href="#%E9%BB%98%E8%AE%A4%E5%80%BC">默认值</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </div>
    <div id="content">
      <h1 id="基础知识">基础知识</h1>
      <h2 id="hello">hello</h2>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="helloword">helloword</h2>
      <h3 id="dart">dart</h3>
      <pre><code class="language-dart">// helloword.dart
// 定义个方法。
printNumber(num aNumber) {
  print(&#39;The number is $aNumber.&#39;); // 在控制台打印内容。
}

// 这是程序执行的入口。
// 每个应用都需要有个顶级的 main() 入口方法才能执行。
// main() 方法的返回值为 void 并且有个可选的 List&lt;String&gt; 参数。
main() {
  var number = 42; // 定义并初始化一个变量。
  printNumber(number); // 调用一个方法。
}</code></pre>
      <pre><code class="language-sh">dart helloword.dart</code></pre>
      <h3 id="go">go</h3>
      <pre><code class="language-go">// helloword.go
package main
import &quot;fmt&quot;
func main() {
  fmt.Println(&quot;Hello, world&quot;)
}

// helloword.go
package main
import (
  &quot;fmt&quot;
  &quot;time&quot;
)
func main() {
  fmt.Println(&quot;Welcome to the playground!&quot;)
  fmt.Println(&quot;The time is&quot;, time.Now())
}</code></pre>
      <pre><code class="language-sh">go run helloword.go</code></pre>
      <h3 id="js">js</h3>
      <pre><code class="language-js">// helloword.js</code></pre>
      <pre><code class="language-sh">node helloword.js</code></pre>
      <h3 id="python">python</h3>
      <pre><code class="language-python">print(&#39;hello, world&#39;)</code></pre>
      <h2 id="概念">概念</h2>
      <p>dart</p>
      <ul>
        <li>
          所有能够使用变量引用的都是对象， 每个对象都是一个类的实例。 在 Dart 中
          甚至连 数字、方法和 null 都是对象。 所有的对象都继承于 Object 类。
        </li>
        <li>没有指定类型的变量的类型为 dynamic</li>
        <li>Dart 支持顶级方法 (例如 main())</li>
        <li>
          Dart 还支持顶级变量，以及 在类中定义变量（静态变量和实例变量）。
          实例变量有时候被称之为域（Fields）或者属性（Properties）
        </li>
        <li>
          Dart 没有 public、 protected、 和 private 关键字。 如果一个标识符以
          (_) 开头，则该标识符 在库内是私有的。
        </li>
      </ul>
      <p>go</p>
      <ul>
        <li>每个 Go 程序都是由包构成的。</li>
        <li>程序从 <code>main</code> 包开始运行。</li>
        <li>
          按照约定，包名与导入路径的最后一个元素一致。
          例如，&quot;math/rand&quot; 包中的源码均以
          <code>package rand</code> 语句开始。
        </li>
      </ul>
      <p>js</p>
      <ul>
        <li>
          ECMAScript 和 JavaScript
          的关系是，前者是后者的规格，后者是前者的一种实现
        </li>
        <li>ES6 这个词的原意，就是指 JavaScript 语言的下一个版本</li>
        <li>
          ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript
          的下一代标准， 涵盖了 ES2015、ES2016、ES2017 等等
        </li>
      </ul>
      <p>JavaScript学习内容包括</p>
      <ul>
        <li>ES5</li>
        <li>ES6</li>
        <li>DOM</li>
        <li>浏览器</li>
        <li>Node.js</li>
        <li>TypeScript</li>
      </ul>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="安装">安装</h3>
      <p>dart</p>
      <pre><code class="language-sh"># Enable HTTPS for apt.
$ sudo apt-get update
$ sudo apt-get install apt-transport-https
# Get the Google Linux package signing key.
$ sudo sh -c &#39;curl https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add -&#39;
# Set up the location of the stable repository.
$ sudo sh -c &#39;curl https://storage.googleapis.com/download.dartlang.org/linux/debian/dart_stable.list &gt; /etc/apt/sources.list.d/dart_stable.list&#39;
$ sudo apt-get update

$ sudo apt-get install dart</code></pre>
      <p>go</p>
      <pre><code class="language-sh"># 卸载旧版本
sudo rm -rf /usr/local/go

# 下载此压缩包并提取到 /usr/local 目录，在 /usr/local/go 中创建Go目录树。
# 该压缩包的名称可能不同，这取决于你安装的Go版本和你的操作系统以及处理器架构。
sudo tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz

# 要将 /usr/local/go/bin 添加到 PATH 环境变量，
# 你需要将此行添加到你的 /etc/profile（全系统安装）或 $HOME/.profile 文件中：
export PATH=$PATH:/usr/local/go/bin

# 安装到指定位置
# GOROOT 仅在安装到指定位置时才需要设置。
export GOROOT=$HOME/go
export PATH=$PATH:$GOROOT/bin

# 测试你的安装
# package main
# import &quot;fmt&quot;
# func main() {
#     fmt.Printf(&quot;hello, world\n&quot;)
# }
go run hello.go

# GOPATH 环境变量
# GOPATH 环境变量指定了你的工作空间位置。
# 注意，它绝对不能和你的Go安装目录相同。
mkdir $HOME/work
export GOPATH=$HOME/work
export PATH=$PATH:$GOPATH/bin</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-sh"># 创建虚拟环境
python3 -m venv tutorial-env
# 创建虚拟环境后，您可以激活它。
source tutorial-env/bin/activate</code></pre>
      <h3 id="常用命令">常用命令</h3>
      <p>dart</p>
      <pre><code class="language-sh"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">Reflect.ownKeys(&#39;&#39;.__proto__)
Reflect.ownKeys(String.prototype)

// Object.getOwnPropertyNames方法返回一个数组，
// 成员是参数对象本身的所有属性的键名，不包含继承的属性键名。
Object.getOwnPropertyNames(Date)</code></pre>
      <p>python</p>
      <pre><code class="language-sh">&gt;&gt;&gt; import fibo, sys
&gt;&gt;&gt; dir(fibo)
[&#39;__name__&#39;, &#39;fib&#39;, &#39;fib2&#39;]
&gt;&gt;&gt; dir(sys)  
[&#39;__displayhook__&#39;, &#39;__doc__&#39;, &#39;__excepthook__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;,
 &#39;__package__&#39;, &#39;__stderr__&#39;, &#39;__stdin__&#39;, &#39;__stdout__&#39;,
 &#39;_clear_type_cache&#39;, &#39;_current_frames&#39;, &#39;_debugmallocstats&#39;, &#39;_getframe&#39;,
 &#39;_home&#39;, &#39;_mercurial&#39;, &#39;_xoptions&#39;, &#39;abiflags&#39;, &#39;api_version&#39;, &#39;argv&#39;,
 &#39;base_exec_prefix&#39;, &#39;base_prefix&#39;, &#39;builtin_module_names&#39;, &#39;byteorder&#39;,
 &#39;call_tracing&#39;, &#39;callstats&#39;, &#39;copyright&#39;, &#39;displayhook&#39;,
 &#39;dont_write_bytecode&#39;, &#39;exc_info&#39;, &#39;excepthook&#39;, &#39;exec_prefix&#39;,
 &#39;executable&#39;, &#39;exit&#39;, &#39;flags&#39;, &#39;float_info&#39;, &#39;float_repr_style&#39;,
 &#39;getcheckinterval&#39;, &#39;getdefaultencoding&#39;, &#39;getdlopenflags&#39;,
 &#39;getfilesystemencoding&#39;, &#39;getobjects&#39;, &#39;getprofile&#39;, &#39;getrecursionlimit&#39;,
 &#39;getrefcount&#39;, &#39;getsizeof&#39;, &#39;getswitchinterval&#39;, &#39;gettotalrefcount&#39;,
 &#39;gettrace&#39;, &#39;hash_info&#39;, &#39;hexversion&#39;, &#39;implementation&#39;, &#39;int_info&#39;,
 &#39;intern&#39;, &#39;maxsize&#39;, &#39;maxunicode&#39;, &#39;meta_path&#39;, &#39;modules&#39;, &#39;path&#39;,
 &#39;path_hooks&#39;, &#39;path_importer_cache&#39;, &#39;platform&#39;, &#39;prefix&#39;, &#39;ps1&#39;,
 &#39;setcheckinterval&#39;, &#39;setdlopenflags&#39;, &#39;setprofile&#39;, &#39;setrecursionlimit&#39;,
 &#39;setswitchinterval&#39;, &#39;settrace&#39;, &#39;stderr&#39;, &#39;stdin&#39;, &#39;stdout&#39;,
 &#39;thread_info&#39;, &#39;version&#39;, &#39;version_info&#39;, &#39;warnoptions&#39;]

# 如果没有参数，dir() 会列出你当前定义的名称:
&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; import fibo
&gt;&gt;&gt; fib = fibo.fib
&gt;&gt;&gt; dir()
[&#39;__builtins__&#39;, &#39;__name__&#39;, &#39;a&#39;, &#39;fib&#39;, &#39;fibo&#39;, &#39;sys&#39;]

# dir() 不会列出内置函数和变量的名称。如果你想要这些，它们的定义是在标准模块 builtins 中:
&gt;&gt;&gt; import builtins
&gt;&gt;&gt; dir(builtins)  
[&#39;ArithmeticError&#39;, &#39;AssertionError&#39;, &#39;AttributeError&#39;, &#39;BaseException&#39;,
 &#39;BlockingIOError&#39;, &#39;BrokenPipeError&#39;, &#39;BufferError&#39;, &#39;BytesWarning&#39;,
 &#39;ChildProcessError&#39;, &#39;ConnectionAbortedError&#39;, &#39;ConnectionError&#39;,
 &#39;ConnectionRefusedError&#39;, &#39;ConnectionResetError&#39;, &#39;DeprecationWarning&#39;,
 &#39;EOFError&#39;, &#39;Ellipsis&#39;, &#39;EnvironmentError&#39;, &#39;Exception&#39;, &#39;False&#39;,
 &#39;FileExistsError&#39;, &#39;FileNotFoundError&#39;, &#39;FloatingPointError&#39;,
 &#39;FutureWarning&#39;, &#39;GeneratorExit&#39;, &#39;IOError&#39;, &#39;ImportError&#39;,
 &#39;ImportWarning&#39;, &#39;IndentationError&#39;, &#39;IndexError&#39;, &#39;InterruptedError&#39;,
 &#39;IsADirectoryError&#39;, &#39;KeyError&#39;, &#39;KeyboardInterrupt&#39;, &#39;LookupError&#39;,
 &#39;MemoryError&#39;, &#39;NameError&#39;, &#39;None&#39;, &#39;NotADirectoryError&#39;, &#39;NotImplemented&#39;,
 &#39;NotImplementedError&#39;, &#39;OSError&#39;, &#39;OverflowError&#39;,
 &#39;PendingDeprecationWarning&#39;, &#39;PermissionError&#39;, &#39;ProcessLookupError&#39;,
 &#39;ReferenceError&#39;, &#39;ResourceWarning&#39;, &#39;RuntimeError&#39;, &#39;RuntimeWarning&#39;,
 &#39;StopIteration&#39;, &#39;SyntaxError&#39;, &#39;SyntaxWarning&#39;, &#39;SystemError&#39;,
 &#39;SystemExit&#39;, &#39;TabError&#39;, &#39;TimeoutError&#39;, &#39;True&#39;, &#39;TypeError&#39;,
 &#39;UnboundLocalError&#39;, &#39;UnicodeDecodeError&#39;, &#39;UnicodeEncodeError&#39;,
 &#39;UnicodeError&#39;, &#39;UnicodeTranslateError&#39;, &#39;UnicodeWarning&#39;, &#39;UserWarning&#39;,
 &#39;ValueError&#39;, &#39;Warning&#39;, &#39;ZeroDivisionError&#39;, &#39;_&#39;, &#39;__build_class__&#39;,
 &#39;__debug__&#39;, &#39;__doc__&#39;, &#39;__import__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;abs&#39;,
 &#39;all&#39;, &#39;any&#39;, &#39;ascii&#39;, &#39;bin&#39;, &#39;bool&#39;, &#39;bytearray&#39;, &#39;bytes&#39;, &#39;callable&#39;,
 &#39;chr&#39;, &#39;classmethod&#39;, &#39;compile&#39;, &#39;complex&#39;, &#39;copyright&#39;, &#39;credits&#39;,
 &#39;delattr&#39;, &#39;dict&#39;, &#39;dir&#39;, &#39;divmod&#39;, &#39;enumerate&#39;, &#39;eval&#39;, &#39;exec&#39;, &#39;exit&#39;,
 &#39;filter&#39;, &#39;float&#39;, &#39;format&#39;, &#39;frozenset&#39;, &#39;getattr&#39;, &#39;globals&#39;, &#39;hasattr&#39;,
 &#39;hash&#39;, &#39;help&#39;, &#39;hex&#39;, &#39;id&#39;, &#39;input&#39;, &#39;int&#39;, &#39;isinstance&#39;, &#39;issubclass&#39;,
 &#39;iter&#39;, &#39;len&#39;, &#39;license&#39;, &#39;list&#39;, &#39;locals&#39;, &#39;map&#39;, &#39;max&#39;, &#39;memoryview&#39;,
 &#39;min&#39;, &#39;next&#39;, &#39;object&#39;, &#39;oct&#39;, &#39;open&#39;, &#39;ord&#39;, &#39;pow&#39;, &#39;print&#39;, &#39;property&#39;,
 &#39;quit&#39;, &#39;range&#39;, &#39;repr&#39;, &#39;reversed&#39;, &#39;round&#39;, &#39;set&#39;, &#39;setattr&#39;, &#39;slice&#39;,
 &#39;sorted&#39;, &#39;staticmethod&#39;, &#39;str&#39;, &#39;sum&#39;, &#39;super&#39;, &#39;tuple&#39;, &#39;type&#39;, &#39;vars&#39;,
 &#39;zip&#39;]</code></pre>
      <h2 id="保留字">保留字</h2>
      <table>
        <thead>
          <tr>
            <th>dart</th>
            <th>go</th>
            <th>js</th>
            <th>python</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>abstract</td>
            <td></td>
            <td>-abstract</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>arguments</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td></td>
            <td>and</td>
          </tr>
          <tr>
            <td>as</td>
            <td></td>
            <td></td>
            <td>as</td>
          </tr>
          <tr>
            <td>assert</td>
            <td></td>
            <td></td>
            <td>assert</td>
          </tr>
          <tr>
            <td>async</td>
            <td></td>
            <td></td>
            <td>async</td>
          </tr>
          <tr>
            <td>async*</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>await</td>
            <td></td>
            <td>await*</td>
            <td>await</td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>-boolean</td>
            <td></td>
          </tr>
          <tr>
            <td>break</td>
            <td>break</td>
            <td>break</td>
            <td>break</td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>-byte</td>
            <td></td>
          </tr>
          <tr>
            <td>case</td>
            <td>case</td>
            <td>case</td>
            <td></td>
          </tr>
          <tr>
            <td>catch</td>
            <td></td>
            <td>catch</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td>chan</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>-char</td>
            <td></td>
          </tr>
          <tr>
            <td>class</td>
            <td></td>
            <td>class</td>
            <td>class</td>
          </tr>
          <tr>
            <td>const</td>
            <td>const</td>
            <td>const</td>
            <td></td>
          </tr>
          <tr>
            <td>continue</td>
            <td>continue</td>
            <td>continue</td>
            <td>continue</td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>debugger</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td></td>
            <td>def</td>
          </tr>
          <tr>
            <td>default</td>
            <td>default</td>
            <td>default</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td>defer</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>deferred</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td></td>
            <td>del</td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>delete</td>
            <td></td>
          </tr>
          <tr>
            <td>do</td>
            <td></td>
            <td>do</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>-double</td>
            <td></td>
          </tr>
          <tr>
            <td>dynamic</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td></td>
            <td>elif</td>
          </tr>
          <tr>
            <td>else</td>
            <td>else</td>
            <td>else</td>
            <td>else</td>
          </tr>
          <tr>
            <td>enum</td>
            <td></td>
            <td>enum</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>eval</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td></td>
            <td>except</td>
          </tr>
          <tr>
            <td>export</td>
            <td></td>
            <td>export</td>
            <td></td>
          </tr>
          <tr>
            <td>extends</td>
            <td></td>
            <td>extends</td>
            <td></td>
          </tr>
          <tr>
            <td>external</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>factory</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td>fallthrough</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>false</td>
            <td></td>
            <td>false</td>
            <td>False</td>
          </tr>
          <tr>
            <td>final</td>
            <td></td>
            <td>-final</td>
            <td></td>
          </tr>
          <tr>
            <td>finally</td>
            <td></td>
            <td>finally</td>
            <td>finally</td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>-float</td>
            <td></td>
          </tr>
          <tr>
            <td>for</td>
            <td>for</td>
            <td>for</td>
            <td>for</td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td></td>
            <td>from</td>
          </tr>
          <tr>
            <td>-</td>
            <td>func</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>function</td>
            <td></td>
          </tr>
          <tr>
            <td>get</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td></td>
            <td>global</td>
          </tr>
          <tr>
            <td>-</td>
            <td>go</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td>goto</td>
            <td>-goto</td>
            <td></td>
          </tr>
          <tr>
            <td>if</td>
            <td>if</td>
            <td>if</td>
            <td>if</td>
          </tr>
          <tr>
            <td>implements</td>
            <td></td>
            <td>implements</td>
            <td></td>
          </tr>
          <tr>
            <td>import</td>
            <td>import</td>
            <td>import</td>
            <td>import</td>
          </tr>
          <tr>
            <td>in</td>
            <td></td>
            <td>in</td>
            <td>in</td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>instanceof</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>-int</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td>interface</td>
            <td>interface</td>
            <td></td>
          </tr>
          <tr>
            <td>is</td>
            <td></td>
            <td></td>
            <td>is</td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td></td>
            <td>lambda</td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>let</td>
            <td></td>
          </tr>
          <tr>
            <td>library</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>-long</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td>map</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>-native</td>
            <td></td>
          </tr>
          <tr>
            <td>new</td>
            <td></td>
            <td>new</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td></td>
            <td>None</td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td></td>
            <td>nonlocal</td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td></td>
            <td>not</td>
          </tr>
          <tr>
            <td>null</td>
            <td></td>
            <td>null</td>
            <td></td>
          </tr>
          <tr>
            <td>operator</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td></td>
            <td>or</td>
          </tr>
          <tr>
            <td>-</td>
            <td>package</td>
            <td>package</td>
            <td></td>
          </tr>
          <tr>
            <td>part</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td></td>
            <td>pass</td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>private</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>protected</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>public</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td></td>
            <td>raise</td>
          </tr>
          <tr>
            <td>-</td>
            <td>range</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>rethrow</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>return</td>
            <td>return</td>
            <td>return</td>
            <td>return</td>
          </tr>
          <tr>
            <td>-</td>
            <td>select</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>set</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>-short</td>
            <td></td>
          </tr>
          <tr>
            <td>static</td>
            <td></td>
            <td>static</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td>struct</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>super</td>
            <td></td>
            <td>super</td>
            <td></td>
          </tr>
          <tr>
            <td>switch</td>
            <td>switch</td>
            <td>switch</td>
            <td></td>
          </tr>
          <tr>
            <td>sync</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>sync*</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>-synchronized</td>
            <td></td>
          </tr>
          <tr>
            <td>this</td>
            <td></td>
            <td>this</td>
            <td></td>
          </tr>
          <tr>
            <td>throw</td>
            <td></td>
            <td>throw</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>-throws</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>-transient</td>
            <td></td>
          </tr>
          <tr>
            <td>true</td>
            <td></td>
            <td>true</td>
            <td>True</td>
          </tr>
          <tr>
            <td>try</td>
            <td></td>
            <td>try</td>
            <td>try</td>
          </tr>
          <tr>
            <td>-</td>
            <td>type</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>typedef</td>
            <td></td>
            <td>typeof</td>
            <td></td>
          </tr>
          <tr>
            <td>var</td>
            <td>var</td>
            <td>var</td>
            <td></td>
          </tr>
          <tr>
            <td>void</td>
            <td></td>
            <td>void</td>
            <td></td>
          </tr>
          <tr>
            <td>-</td>
            <td></td>
            <td>-volatile</td>
            <td></td>
          </tr>
          <tr>
            <td>while</td>
            <td></td>
            <td>while</td>
            <td>while</td>
          </tr>
          <tr>
            <td>with</td>
            <td></td>
            <td>with</td>
            <td>with</td>
          </tr>
          <tr>
            <td>yield</td>
            <td></td>
            <td>yield</td>
            <td>yield</td>
          </tr>
          <tr>
            <td>yield*</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
        </tbody>
      </table>
      <h2 id="库包模块">库包模块</h2>
      <p>dart</p>
      <p>Dart 有两种类型的包： 应用 包 和 库 包。</p>
      <p>
        最简单的库包的 目录结构： 通常情况下都把实现代码放到
        <code>lib/src</code> 目录中。 位于
        <code>lib/src</code> 下面的代码被认为是私有的； 其他包不应该直接导入
        <code>src/...</code> 里面的代码。
      </p>
      <p>
        要分享 lib/src 下的 API，你可以在 lib 目录下 创建一个文件，
        在这个文件中导入 lib/src 中的代码。
      </p>
      <pre><code class="language-sh">root ------lib-----file.dart
        |--pubspec.yaml</code></pre>
      <ul>
        <li>
          库不仅仅提供 API， 还是一个私有单元： 以下划线 (_)
          开头的标识符只有在库 内部可见。 每个 Dart app 都是一个库，
          即使没有使用 library 命令也是一个库
        </li>
        <li>
          import 必须参数为库 的 URI。 对于内置的库，URI 使用特殊的 dart:
          scheme。 对于其他的库，你可以使用文件系统路径或者 package: scheme。
          package: scheme 指定的库通过包管理器来提供， 例如 pub 工具。
        </li>
      </ul>
      <pre><code class="language-dart">import &#39;dart:html&#39;;
import &#39;dart:io&#39;;
import &#39;package:mylib/mylib.dart&#39;;
import &#39;package:utils/utils.dart&#39;;

// Specifying a library prefix（指定库前缀）
import &#39;package:lib1/lib1.dart&#39;;
import &#39;package:lib2/lib2.dart&#39; as lib2;
// ...
Element element1 = new Element();           // Uses Element from lib1.
lib2.Element element2 = new lib2.Element(); // Uses Element from lib2.

// Importing only part of a library（导入库的一部分）
// Import only foo.
import &#39;package:lib1/lib1.dart&#39; show foo;
// Import all names EXCEPT foo.
import &#39;package:lib2/lib2.dart&#39; hide foo;

// Lazily loading a library（延迟载入库）
// 可以多次调用 loadLibrary() 函数。 但是该库只是载入一次
import &#39;package:deferred/hello.dart&#39; deferred as hello;
greet() async {
  await hello.loadLibrary();
  hello.printGreeting();
}


import &#39;french.dart&#39;;
export &#39;french.dart&#39; show hello;

// 引入某个库的多个对象
import &#39;package:flutter/material.dart&#39; show StatefulWidget, StatelessWidget;</code></pre>
      <p>go</p>
      <p>
        此代码用圆括号组合了导入，这是“分组”形式的导入语句。
        不过使用分组导入语句是更好的形式。
      </p>
      <p>
        在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。 例如，Pizza
        就是个已导出名，Pi 也同样，它导出自 math 包。 pizza 和 pi
        并未以大写字母开头，所以它们是未导出的。
        在导入一个包时，你只能引用其中已导出的名字。
        任何“未导出”的名字在该包外均无法访问。
      </p>
      <p>言外之意，</p>
      <ul>
        <li><p>大写字母开头的变量会导出给其他包使用，</p></li>
        <li><p>小写字母开头的变量为包内私有，不会导出</p></li>
        <li>
          <p>Go源文件中的第一个语句必须是 <code>package 名称</code></p>
        </li>
        <li>
          <p>
            这里的 名称 即为导入该包时使用的默认名称。
            （一个包中的所有文件都必须使用相同的 名称。）
          </p>
        </li>
        <li>
          <p>
            Go的约定是包名为导入路径的最后一个元素：作为 “crypto/rot13”
            导入的包应命名为 rot13。
          </p>
        </li>
        <li>
          <p>可执行命令必须使用 <code>package main</code>。</p>
        </li>
        <li>
          <p>
            链接成单个二进制文件的所有包，其包名无需是唯一的，只有导入路径（它们的完整文件名）
            才是唯一的。
          </p>
        </li>
      </ul>
      <p>
        在 <code>src/pkg/encoding/base64</code> 中的包应作为
        <code>encoding/base64</code> 导入，
      </p>
      <pre><code class="language-go">import (
  &quot;fmt&quot;
  &quot;math&quot;
)
// 等同于
import &quot;fmt&quot;
import &quot;math&quot;

// math包内的Pi即为导出的
func main() {
  fmt.Println(math.Pi)
}</code></pre>
      <pre><code class="language-sh"># 若你在包的导入路径中包含了代码仓库的URL，go get 就会自动地获取、 构建并安装它：
$ go get github.com/golang/example/hello
$ $GOPATH/bin/hello
Hello, Go examples!

# 在执行完上面的go get 命令后，工作空间的目录树看起来应该是这样的：
bin/
    hello                           # command executable
src/
    github.com/golang/example/
        .git/                       # Git repository metadata
        hello/
            hello.go                # command source
        stringutil/
            reverse.go              # package source
            reverse_test.go         # test source
    github.com/user/
        hello/
            hello.go                # command source
        stringutil/
            reverse.go              # package source
            reverse_test.go         # test source</code></pre>
      <p>js</p>
      <ul>
        <li>一个Node.js文件就是一个模块</li>
        <li>
          包是在模块基础上更深一步的抽象，使用npm来解决包的发布和获取，
          <code>package.json</code>必须在包的顶层目录下
        </li>
      </ul>
      <pre><code class="language-js">import { stat, exists, readFile } from &#39;fs&#39;;
import _, { each, forEach } from &#39;lodash&#39;;
// 整体加载的写法
import * as circle from &#39;./circle&#39;;

// profile.js
export var firstName = &#39;Michael&#39;;
export var lastName = &#39;Jackson&#39;;
export var year = 1958;

// profile.js
var firstName = &#39;Michael&#39;;
var lastName = &#39;Jackson&#39;;
var year = 1958;
export { firstName, lastName, year };

// export-default.js
export default function () {
  console.log(&#39;foo&#39;);
}
// import-default.js
import customName from &#39;./export-default&#39;;
customName(); // &#39;foo&#39;

export { foo, bar } from &#39;my_module&#39;;
// 可以简单理解为
import { foo, bar } from &#39;my_module&#39;;
export { foo, bar };</code></pre>
      <p>python</p>
      <ul>
        <li>module：一个文件就是一个模块</li>
        <li>
          package：包是一个包含<strong>init</strong>.py 文件的目录
          包是一种通过用“带点号的模块名”来构造 Python 模块命名空间的方法。
        </li>
        <li>lib：库是完成一定功能的代码集合，在python中是包和模块的形式</li>
      </ul>
      <p>
        当一个名为 spam 的模块被导入的时候，
        解释器首先寻找具有该名称的内置模块。 如果没有找到，然后解释器从 sys.path
        变量给出的目录列表里寻找名为 spam.py 的文件。 sys.path
        初始有这些目录地址:
      </p>
      <ul>
        <li>包含输入脚本的目录（或者未指定文件时的当前目录）。</li>
        <li>
          PYTHONPATH （一个包含目录名称的列表，它和shell变量 PATH
          有一样的语法）。
        </li>
        <li>取决于安装的默认设置</li>
      </ul>
      <pre><code class="language-python"># fibo.py
def fib(n):    # write Fibonacci series up to n
  a, b = 0, 1
  while a &lt; n:
    print(a, end=&#39; &#39;)
    a, b = b, a+b
  print()
def fib2(n):   # return Fibonacci series up to n
  result = []
  a, b = 0, 1
  while a &lt; n:
    result.append(a)
    a, b = b, a+b
  return result

#
import fibo
fibo.fib(1000)
#
from fibo import fib, fib2
fib(1000)
#
from fibo import *
fib(1000)
#
import fibo as fib
fib.fib(500)
#
from fibo import fib as fibonacci
fibonacci(500)

# 以脚本的方式执行模块
# python fibo.py &lt;arguments&gt;
if __name__ == &quot;__main__&quot;:
    import sys
    fib(int(sys.argv[1]))

# 子包参考
from . import echo
from .. import formats
from ..filters import equalizer</code></pre>
      <h3 id="包管理工具">包管理工具</h3>
      <p>dart</p>
      <p>You can use <code>pub</code> to manage Dart packages.</p>
      <pre><code class="language-yaml"># pubspec.yaml
name: my_app
dependencies:
  js: ^0.3.0
  intl: ^0.12.4</code></pre>
      <pre><code class="language-sh"># Installing packages
cd &lt;path-to-my_app&gt;
pub get

# Upgrading a dependency
pub upgrade
# 升级特定的依赖
pub upgrade transmogrify</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-sh">pip search astronomy
pip install novas
pip install requests==2.6.0
pip install --upgrade requests
pip show requests
pip list
pip freeze &gt; requirements.txt
pip install -r requirements.txt</code></pre>
      <h3 id="项目结构">项目结构</h3>
      <p>dart</p>
      <p>
        库包的代码位于 lib 目录中， 在其他包中可以访问这里面的代码。 在 lib
        目录下可以创建任意的目录结构。 通常情况下都把实现代码放到 lib/src
        目录中。 位于 lib/src 下面的代码被认为是私有的； 其他包不应该直接导入
        src/... 里面的代码。 要分享 lib/src 下的 API，你可以在 lib 目录下
        创建一个文件， 在这个文件中导入 lib/src 中的代码。
      </p>
      <p>
        最简单的库包的 目录结构
        <img
          src="images/simple-lib2-81ebdc20fdb53d3abbc4364956141eb0f6f8f275d1636064fc3e1db959b93c1a.png"
          alt="最简单的库包的 目录结构"
        />
      </p>

      <p>
        shelf 库的目录结构
        <img
          src="images/shelf-02e5fd43b660fcef7dbe6a883c40159e0379c8ee2088288ca60ed7dc8781bafd.png"
          alt="shelf 库的目录结构"
        />
      </p>

      <p>
        在 lib 和 web 库中如何导入 lib/src/foo/a.dart
        <img
          src="images/import-lib-rules-fa353f6fddc6e69fe19da41bffff4f6ec7b561eeead24840bacce032759b8473.png"
          alt="在 lib 和 web 库中如何导入 lib/src/foo/a.dart "
        />
      </p>

      <p>go</p>
      <p>Go代码必须放在工作空间内。它其实就是一个目录，其中包含三个子目录：</p>
      <ul>
        <li>
          src 目录包含Go的源文件，它们被组织成包（每个目录都对应一个包），
        </li>
        <li>pkg 目录包含包对象，</li>
        <li>bin 目录包含可执行命令。</li>
      </ul>
      <p>
        go 工具用于构建源码包，并将其生成的二进制文件安装到 pkg 和 bin 目录中。
        src 子目录通常包会含多种版本控制的代码仓库（例如Git或Mercurial），
        以此来跟踪一个或多个源码包的开发。
      </p>
      <pre><code class="language-sh"># 此工作空间包含三个代码库（goauth2、streak 和 todo），
# 两个命令（streak 和 todo） 以及两个库（oauth 和 task）。
bin/
  streak                         # 可执行命令
  todo                           # 可执行命令
pkg/
  linux_amd64/
    code.google.com/p/goauth2/
      oauth.a                # 包对象
    github.com/nf/todo/
      task.a                 # 包对象
src/
  code.google.com/p/goauth2/
    .hg/                       # mercurial 代码库元数据
    oauth/
      oauth.go               # 包源码
      oauth_test.go          # 测试源码
  github.com/nf/
    streak/
      .git/                      # git 代码库元数据
      oauth.go               # 命令源码
      streak.go              # 命令源码
    todo/
      .git/                      # git 代码库元数据
      task/
        task.go            # 包源码
      todo.go                # 命令源码</code></pre>
      <pre><code class="language-go">// hello.go
package main
import (
  &quot;fmt&quot;
  &quot;github.com/user/stringutil&quot;
)
func main() {
  fmt.Printf(stringutil.Reverse(&quot;!oG ,olleH&quot;))
}

// reverse.go
// stringutil 包含有用于处理字符串的工具函数。
package stringutil
// Reverse 将其实参字符串以符文为单位左右反转。
func Reverse(s string) string {
  r := []rune(s)
  for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 {
    r[i], r[j] = r[j], r[i]
  }
  return string(r)
}</code></pre>
      <pre><code class="language-sh"># 你的第一个程序
bin/
  hello                 # 可执行命令
pkg/
  linux_amd64/          # 这里会反映出你的操作系统和架构
    github.com/user/
      stringutil.a  # 包对象
src/
  github.com/user/
    hello/
      hello.go      # 命令源码
    stringutil/
      reverse.go       # 包源码


# 创建目录
mkdir $GOPATH/src/github.com/user/hello

# 用 go build 命令来测试该包
# 它会将包的对象放到工作空间的 pkg 目录中
# 这不会产生输出文件。想要输出的话，必须使用 go install 命令
go build github.com/user/stringutil
# 若你在该包的源码目录中，只需执行
go build

# 用 go 工具构建并安装此程序
# 此命令会构建 hello 命令，产生一个可执行的二进制文件。
# 接着它会将该二进制文件作为 hello（在 Windows 下则为 hello.exe）安装到工作空间的 bin 目录中。
# go 工具只有在发生错误时才会打印输出
go install github.com/user/hello
# 或者
cd $GOPATH/src/github.com/user/hello
go install

# 现在，你可以在命令行下输入它的完整路径来运行它了：
$GOPATH/bin/hello
# 若你已经将 $GOPATH/bin 添加到 PATH 中了
hello</code></pre>
      <pre><code class="language-sh">bin/
    hello                          # command executable
    outyet                         # command executable
src/
    github.com/golang/example/
        .git/                      # Git repository metadata
  hello/
      hello.go               # command source
  outyet/
      main.go                # command source
      main_test.go           # test source
  stringutil/
      reverse.go             # package source
      reverse_test.go        # test source
    golang.org/x/image/
        .git/                      # Git repository metadata
  bmp/
      reader.go              # package source
      writer.go              # package source
    ... (many more repositories and packages omitted) ...</code></pre>
      <p>js</p>
      <p>常见包结构</p>
      <pre><code class="language-sh">├── root
│   ├── src
│   ├── lib
│   ├── dist
│   ├── node_modules
│   ├── package.json</code></pre>
      <p>python</p>
      <pre><code class="language-sh">sound/                          Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...</code></pre>
      <pre><code class="language-python"># 包的用户可以从包中导入单个模块，例如:
import sound.effects.echo
sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)

# 导入子模块的另一种方法是
from sound.effects import echo
echo.echofilter(input, output, delay=0.7, atten=4)

# 另一种形式是直接导入所需的函数或变量:
from sound.effects.echo import echofilter
echofilter(input, output, delay=0.7, atten=4)

# 文件 sound/effects/__init__.py 可以包含以下代码:
__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]
# 当用户写
from sound.effects import *
# 意味着 from sound.effects import * 将导入 sound 包的三个命名子模块</code></pre>
      <h2 id="命名风格">命名风格</h2>
      <p>dart</p>
      <ul>
        <li>UpperCamelCase</li>
        <li>lowerCamelCase</li>
        <li>lowercase_with_underscores</li>
      </ul>
      <p>go</p>
      <ul>
        <li>
          只包含一个方法的接口应当以该方法的名称加上-er后缀来命名， 如
          Reader、Writer、 Formatter、CloseNotifier 等。
        </li>
      </ul>
      <h3 id="标识符">标识符</h3>
      <p>dart</p>
      <ul>
        <li>包应当以小写的单个单词来命名，且不应使用下划线或驼峰记法。</li>
        <li>
          标识符可以以字母或者 _ 下划线开头，后面可以是 其他字符和数字的组合。
        </li>
      </ul>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <ul>
        <li>
          第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），
          以及美元符号（$）和下划线（_）。
        </li>
        <li>
          第二个字符及后面的字符，除了 Unicode
          字母、美元符号和下划线，还可以用数字0-9。
        </li>
      </ul>
      <p>python</p>
      <ul>
        <li>
          大写和小写字母 A 至 Z，下划线 _ 以及数字 0 至 9，但不可以数字打头。
        </li>
        <li>标识符的长度没有限制。对大小写敏感。</li>
      </ul>
      <pre><code class="language-dart">// 要使用 UpperCamelCase 风格来命名类型名称
class SliderMenu { ... }
class HttpRequest { ... }
typedef bool Predicate&lt;T&gt;(T value);

class Foo {
  const Foo([arg]);
}
@Foo(anArg)
class A { ... }
@Foo()
class B { ... }

const foo = const Foo();
@foo
class C { ... }


// 要使用 lowercase_with_underscores 风格来命名库和文件名名字
library peg_parser.source_scanner;
import &#39;file_system.dart&#39;;
import &#39;slider_menu.dart&#39;;

import &#39;dart:json&#39; as json;
import &#39;dart:math&#39; as math;
import &#39;package:javascript_utils/javascript_utils.dart&#39; as js_utils;
import &#39;package:js/js.dart&#39; as js;


// 要使用 lowerCamelCase 风格来命名其他的标识符
var item;
HttpRequest httpRequest;
align(clearItems) {
  // ...
}</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="注释">注释</h3>
      <p>dart</p>
      <ul>
        <li>单行注释以 // 开始。</li>
        <li>多行注释以 /* 开始， */ 结尾。 多行注释 可以 嵌套。</li>
        <li>文档注释可以使用 /// 开始， 也可以使用 /** 开始 并以 */ 结束。</li>
      </ul>
      <pre><code class="language-dart">main() {
  // TODO: refactor into an AbstractLlamaGreetingFactory?
  print(&#39;Welcome to my Llama farm!&#39;);
}

main() {
  /*
   * This is a lot of work. Consider raising chickens.

  Llama larry = new Llama();
  larry.feed();
  larry.exercise();
  larry.clean();
   */
}

/// A domesticated South American camelid (Lama glama).
///
/// Andean cultures have used llamas as meat and pack
/// animals since pre-Hispanic times.
class Llama {
  String name;

  /// Feeds your llama [Food].
  ///
  /// The typical llama eats one bale of hay per week.
  void feed(Food food) {
    // ...
  }

  /// Exercises your llama with an [activity] for
  /// [timeLimit] minutes.
  void exercise(Activity activity, int timeLimit) {
    // ...
  }
}</code></pre>
      <p>go</p>
      <p>Go语言支持C风格的块注释 /* */ 和C++风格的行注释 //。</p>
      <ul>
        <li>每个包都应包含一段包注释，即放置在包子句前的一个块注释。</li>
        <li>对于包含多个文件的包， 包注释只需出现在其中的任一文件中即可。</li>
        <li>包注释应在整体上对该包进行介绍，并提供包的相关信息。</li>
      </ul>
      <pre><code class="language-go">/*
  regexp 包为正则表达式实现了一个简单的库。

  该库接受的正则表达式语法为：

  正则表达式:
    串联 { &#39;|&#39; 串联 }
  串联:
    { 闭包 }
  闭包:
    条目 [ &#39;*&#39; | &#39;+&#39; | &#39;?&#39; ]
  条目:
    &#39;^&#39;
    &#39;$&#39;
    &#39;.&#39;
    字符
    &#39;[&#39; [ &#39;^&#39; ] 字符遍历 &#39;]&#39;
    &#39;(&#39; 正则表达式 &#39;)&#39;
*/
package regexp
// path 包实现了一些常用的工具，以便于操作用反斜杠分隔的路径.

// 表达式解析失败后返回错误代码。
var (
  ErrInternal      = errors.New(&quot;regexp: internal error&quot;)
  ErrUnmatchedLpar = errors.New(&quot;regexp: unmatched &#39;(&#39;&quot;)
  ErrUnmatchedRpar = errors.New(&quot;regexp: unmatched &#39;)&#39;&quot;)
  // ...
)</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"># 一个多行文档字符串的例子:
def my_function():
    &quot;&quot;&quot;Do nothing, but document it.

    No, really, it doesn&#39;t do anything.
    &quot;&quot;&quot;
    pass

print(my_function.__doc__)
# Do nothing, but document it.

#     No, really, it doesn&#39;t do anything.</code></pre>
      <h3 id="打印">打印</h3>
      <p>dart</p>
      <pre><code class="language-dart">print(&#39;The number is $aNumber.&#39;); // 在控制台打印内容。</code></pre>
      <p>go</p>
      <pre><code class="language-go">fmt.Printf(&quot;Hello %d\n&quot;, 23)
fmt.Fprint(os.Stdout, &quot;Hello &quot;, 23, &quot;\n&quot;)
fmt.Println(&quot;Hello&quot;, 23)
fmt.Println(fmt.Sprint(&quot;Hello &quot;, 23))

var x uint64 = 1&lt;&lt;64 - 1
fmt.Printf(&quot;%d %x; %d %x\n&quot;, x, x, int64(x), int64(x))

// 若你只想要默认的转换，如使用十进制的整数，你可以使用通用的格式 %v（对应“值”）；
// 其结果与 Print 和 Println 的输出完全相同。
// 此外，这种格式还能打印任意值，甚至包括数组、结构体和映射。
fmt.Printf(&quot;%v\n&quot;, timeZone)  // 或只用 fmt.Println(timeZone)

// 改进的格式 %+v 会为结构体的每个字段添上字段名，
// 而另一种格式 %#v 将完全按照Go的语法打印值。
type T struct {
  a int
  b float64
  c string
}
t := &amp;T{ 7, -2.35, &quot;abc\tdef&quot; }
fmt.Printf(&quot;%v\n&quot;, t)
fmt.Printf(&quot;%+v\n&quot;, t)
fmt.Printf(&quot;%#v\n&quot;, t)
fmt.Printf(&quot;%#v\n&quot;, timeZone)
// &amp;{7 -2.35 abc   def}
// &amp;{a:7 b:-2.35 c:abc     def}
// &amp;main.T{a:7, b:-2.35, c:&quot;abc\tdef&quot;}
// map[string] int{&quot;CST&quot;:-21600, &quot;PST&quot;:-28800, &quot;EST&quot;:-18000, &quot;UTC&quot;:0, &quot;MST&quot;:-25200}</code></pre>
      <p>js</p>
      <pre><code class="language-js">console.log(`The number is ${aNumber}.`)
var number = 11 * 9;
var color = &#39;red&#39;;
console.log(&#39;%d %s balloons&#39;, number, color);

console.log(&#39; %s + %s &#39;, 1, 1, &#39;= 2&#39;)
// 1 + 1  = 2

console.log({foo: &#39;bar&#39;})
// Object {foo: &quot;bar&quot;}
console.log(Date)
// function Date() { [native code] }

var languages = [
  { name: &quot;JavaScript&quot;, fileExtension: &quot;.js&quot; },
  { name: &quot;TypeScript&quot;, fileExtension: &quot;.ts&quot; },
  { name: &quot;CoffeeScript&quot;, fileExtension: &quot;.coffee&quot; }
];
console.table(languages);

var languages = {
  csharp: { name: &quot;C#&quot;, paradigm: &quot;object-oriented&quot; },
  fsharp: { name: &quot;F#&quot;, paradigm: &quot;functional&quot; }
};
console.table(languages);

console.assert(false, &#39;判断条件不成立&#39;)
// Assertion failed: 判断条件不成立
// 相当于
try {
  if (!false) {
    throw new Error(&#39;判断条件不成立&#39;);
  }
} catch(e) {
  console.error(e);
}</code></pre>
      <p>python</p>
      <pre><code class="language-python">print(&#39;The number is {}.&#39;.format(aNumber)) #打印</code></pre>
      <h3 id="格式化">格式化</h3>
      <p>dart</p>
      <pre><code class="language-sh">pub global activate dart_style
dartfmt test.dart</code></pre>
      <p>go</p>
      <pre><code class="language-sh">go fmt &lt;文件名&gt;.go
# go fmt是gofmt的上层一个包装的命令
gofmt</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="变量">变量</h2>
      <p>dart</p>
      <pre><code class="language-dart">// 不要 显式的把变量初始化为 null
int _nextId;
assert(_nextId == null);

// 没有明确类型
var name = &#39;Bob&#39;;
Object name = &#39;Bob&#39;;
dynamic name = &#39;Bob&#39;;

// 可以选择加上具体 类型
// 对于局部变量，这里准守 代码风格推荐 部分的建议，
// 使用 var 而不是具体的类型来定义局部变量。
String name2 = &#39;Bob&#39;;

// 定义集合
var points = [];
var addresses = {};
// 如果有必要还可以提供泛型类型
var points = &lt;Point&gt;[];
var addresses = &lt;String, Address&gt;{};</code></pre>
      <p>go</p>
      <p>var 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。</p>
      <pre><code class="language-go">package main
import &quot;fmt&quot;
var c, python, java bool
func main() {
  var i int
  fmt.Println(i, c, python, java)
}


// 变量声明可以包含初始值，每个变量对应一个。
// 如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。
package main
import &quot;fmt&quot;
var i, j int = 1,0
func main() {
  var c, python, java = true, false, &quot;no!&quot; // 自动获得类型
  fmt.Println(i, j, c, python, java) // 1 0 true false no!
}


// 在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。
// 函数外的每个语句都必须以关键字开始（var, func 等等），
// 因此 := 结构不能在函数外使用。
package main
import &quot;fmt&quot;
func main() {
  var i, j int = 1, 2
  k := 3
  c, python, java := true, false, &quot;no!&quot;
  fmt.Println(i, j, k, c, python, java) // 1 2 3 true false no!
}</code></pre>
      <p>js</p>
      <pre><code class="language-js">// var name = &#39;Bob&#39;;
let name = &#39;Bob&#39;;


// 分组声明
import(
  &quot;fmt&quot;
  &quot;os&quot;
)

const(
  i = 100
  pi = 3.1415
  prefix = &quot;Go_&quot;
)

var(
  i int
  pi float32
  prefix string
)</code></pre>
      <p>python</p>
      <pre><code class="language-python">name = &#39;Bob&#39;</code></pre>
      <h3 id="私有变量">私有变量</h3>
      <p>dart</p>
      <pre><code class="language-dart">// 变量名以&quot;_&quot;开头意味着对它的 lib 是私有的
var _name = &#39;Bob&#39;;</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="常量">常量</h3>
      <p>dart</p>
      <ul>
        <li>
          dart的<code>final</code>类似于js中的const，只能定义一次，但可运行时才确定值，
          如果是复杂对象，内存地址不变，但是对象的成员是可变的。
        </li>
        <li>
          dart的<code>const</code>比final限制更严格，在编译时需有确定值，运行时不可变，
          不但内存地址不变，对象的成员也都不可变。
        </li>
      </ul>
      <pre><code class="language-dart">// 一个 final 变量只能赋值一次
final name = &#39;Bob&#39;;
final String name = &#39;Bob&#39;;
// 一个 const 变量是编译时常量
const bar = 1000000;
var varList = const [];</code></pre>
      <p>go</p>
      <p>程序编译阶段就确定下来的值，而程序在运行时无法改变该值。</p>
      <ul>
        <li>常量的声明与变量类似，只不过是使用 const 关键字。</li>
        <li>常量可以是字符、字符串、布尔值或数值。</li>
        <li>常量不能用 := 语法声明。</li>
        <li>它们在编译时创建</li>
        <li>定义它们的表达式必须也是可被编译器求值的常量表达式</li>
      </ul>
      <pre><code class="language-go">package main
import &quot;fmt&quot;
const Pi = 3.14
func main() {
  const World = &quot;世界&quot;
  fmt.Println(&quot;Hello&quot;, World)
  fmt.Println(&quot;Happy&quot;, Pi, &quot;Day&quot;)
  const Truth = true
  fmt.Println(&quot;Go rules?&quot;, Truth)
}


// 数值常量是高精度的 值。
package main
import &quot;fmt&quot;
const (
  // 将 1 左移 100 位来创建一个非常大的数字
  // 即这个数的二进制是 1 后面跟着 100 个 0
  Big = 1 &lt;&lt; 100
  // 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2
  Small = Big &gt;&gt; 99
)
func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
  return x * 0.1
}
func main() {
  fmt.Println(needInt(Small))
  fmt.Println(needFloat(Small))
  fmt.Println(needFloat(Big))
}</code></pre>
      <p>js</p>
      <ul>
        <li>js的<code>const</code>类似与dart的final，声明一个只读的常量。</li>
        <li>
          对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。
        </li>
        <li>
          但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，
          保存的只是一个指向实际数据的指针，
          const只能保证这个指针是固定的（即总是指向另一个固定的地址），
          至于它指向的数据结构是不是可变的，就完全不能控制了
        </li>
      </ul>
      <pre><code class="language-js">const name = &#39;Bob&#39;;</code></pre>
      <p>python</p>
      <pre><code class="language-python"># 自定义
class Const:
  class ConstError(TypeError) :
    pass
  class ConstCaseError(ConstError):
    pass

  def __setattr__(self, name, value):
    if name in self.__dict__:
      raise self.ConstError, &quot;Can&#39;t change const value!&quot;
    if not name.isupper():
      raise self.ConstCaseError, &#39;const &quot;%s&quot; is not all letters are capitalized&#39; %name
    self.__dict__[name] = value

import sys
sys.modules[__name__] = Const()

# 使用
import constant
constant.MAX_COUNT=1</code></pre>
      <h3 id="默认值">默认值</h3>
      <p>也叫零值。 未初始化的变量自动获取的值</p>
      <p>dart</p>
      <pre><code class="language-dart">int lineCount;
print(lineCount);
// null</code></pre>
      <p>go</p>
      <p>没有明确初始值的变量声明会被赋予它们的 零值:</p>
      <ul>
        <li>数值类型为 0，</li>
        <li>布尔类型为 false，</li>
        <li>字符串为 &quot;&quot;（空字符串）。</li>
        <li>指针零值为 nil</li>
        <li>切片的零值是 nil</li>
      </ul>
      <pre><code class="language-go">package main
import &quot;fmt&quot;
func main() {
  var i int
  var f float64
  var b bool
  var s string
  fmt.Printf(&quot;%v %v %v %q\n&quot;, i, f, b, s) // 0 0 false &quot;&quot;
}

int     0
int8    0
int32   0
int64   0
uint    0x0
rune    0 //rune的实际类型是 int32
byte    0x0 // byte的实际类型是 uint8
float32 0 //长度为 4 byte
float64 0 //长度为 8 byte
bool    false
string  &quot;&quot;</code></pre>
      <p>js</p>
      <pre><code class="language-js">let lineCount;
console.log(lineCount);
// undefined</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
    </div>
    <script src="./highlight/highlight.pack.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>
