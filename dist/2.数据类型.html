<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>2.数据类型.md</title>
    <link rel="stylesheet" href="./styles.css" />
    <link rel="stylesheet" href="./highlight/styles/github.css" />
  </head>
  <body>
    <div id="nav">
      <ul>
        <li>
          <a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a>
          <ul>
            <li>
              <a href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">内置类型</a>
              <ul>
                <li>
                  <a href="#%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%9E%8B">默认类型</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD">类型判断</a>
              <ul>
                <li>
                  <a
                    href="#%E6%A3%80%E6%9F%A5%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8%E6%98%AF%E5%90%A6%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1"
                    >检查两个引用是否指向同一个对象</a
                  >
                </li>
              </ul>
            </li>
            <li>
              <a href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">基本类型</a>
              <ul>
                <li>
                  <a href="#%E6%95%B0%E5%80%BC">数值</a>
                  <ul>
                    <li>
                      <a href="#%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C"
                        >数值操作</a
                      >
                    </li>
                    <li>
                      <a
                        href="#%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC"
                        >计算最大值和最小值</a
                      >
                    </li>
                    <li>
                      <a href="#%E6%95%B0%E5%AD%A6%E5%B8%B8%E9%87%8F"
                        >数学常量</a
                      >
                    </li>
                    <li>
                      <a href="#%E9%9A%8F%E6%9C%BA%E6%95%B0">随机数</a>
                      <ul>
                        <li>
                          <a
                            href="#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B4%E6%95%B0"
                            >生成随机整数</a
                          >
                        </li>
                        <li>
                          <a
                            href="#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%B8%83%E5%B0%94%E5%80%BC"
                            >生成随机布尔值</a
                          >
                        </li>
                        <li>
                          <a
                            href="#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"
                            >生成随机字符串</a
                          >
                        </li>
                        <li>
                          <a
                            href="#%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9%E5%AD%90%E5%AF%B9%E8%B1%A1"
                            >随机选择子对象</a
                          >
                        </li>
                      </ul>
                    </li>
                    <li>
                      <a href="#%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0"
                        >三角函数</a
                      >
                    </li>
                    <li>
                      <a
                        href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97"
                        >十进制浮点运算</a
                      >
                    </li>
                    <li>
                      <a href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"
                        >进制转换</a
                      >
                    </li>
                  </ul>
                </li>
                <li>
                  <a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>
                  <ul>
                    <li>
                      <a href="#%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"
                        >多行字符串</a
                      >
                    </li>
                    <li>
                      <a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80"
                        >字符串前缀</a
                      >
                      <ul>
                        <li>
                          <a
                            href="#%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2"
                            >原始字符串</a
                          >
                        </li>
                      </ul>
                    </li>
                    <li>
                      <a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2"
                        >字符串搜索</a
                      >
                    </li>
                    <li>
                      <a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96"
                        >字符串截取</a
                      >
                    </li>
                    <li>
                      <a href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"
                        >大小写转换</a
                      >
                    </li>
                    <li>
                      <a
                        href="#%E8%A3%81%E5%89%AA%E5%92%8C%E5%88%A4%E6%96%AD%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"
                        >裁剪和判断空字符串</a
                      >
                    </li>
                    <li>
                      <a
                        href="#%E6%9B%BF%E6%8D%A2%E9%83%A8%E5%88%86%E5%AD%97%E7%AC%A6"
                        >替换部分字符</a
                      >
                    </li>
                    <li>
                      <a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"
                        >格式化输出</a
                      >
                    </li>
                  </ul>
                </li>
                <li><a href="#Symbols">Symbols</a></li>
                <li>
                  <a
                    href="#%E5%85%B6%E4%BB%96%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"
                    >其他基本类型</a
                  >
                  <ul>
                    <li><a href="#null">null</a></li>
                    <li><a href="#undefined">undefined</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>
              <a href="#%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B">复杂类型</a>
              <ul>
                <li>
                  <a href="#%E5%88%97%E8%A1%A8">列表</a>
                  <ul>
                    <li>
                      <a href="#%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE"
                        >列表查找</a
                      >
                    </li>
                    <li>
                      <a href="#%E5%88%97%E8%A1%A8%E6%8E%92%E5%BA%8F"
                        >列表排序</a
                      >
                    </li>
                    <li>
                      <a href="#%E5%88%97%E8%A1%A8%E6%88%AA%E5%8F%96"
                        >列表截取</a
                      >
                    </li>
                    <li>
                      <a href="#%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F"
                        >列表推导式</a
                      >
                    </li>
                    <li>
                      <a
                        href="#%E5%88%97%E8%A1%A8%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"
                        >列表高阶函数</a
                      >
                    </li>
                  </ul>
                </li>
                <li><a href="#%E5%88%87%E7%89%87">切片</a></li>
                <li><a href="#%E5%85%83%E7%BB%84">元组</a></li>
                <li>
                  <a href="#%E5%AD%97%E5%85%B8">字典</a>
                  <ul>
                    <li>
                      <a href="#%E5%AD%97%E5%85%B8%E5%88%A0%E9%99%A4"
                        >字典删除</a
                      >
                    </li>
                    <li>
                      <a href="#%E5%AD%97%E5%85%B8%E9%81%8D%E5%8E%86"
                        >字典遍历</a
                      >
                    </li>
                    <li>
                      <a href="#%E5%AD%97%E5%85%B8%E5%88%A4%E6%96%AD"
                        >字典判断</a
                      >
                    </li>
                  </ul>
                </li>
                <li>
                  <a href="#%E9%9B%86%E5%90%88">集合</a>
                  <ul>
                    <li>
                      <a
                        href="#%E5%88%A4%E6%96%AD%E9%9B%86%E5%90%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"
                        >判断集合是否为空</a
                      >
                    </li>
                    <li>
                      <a href="#%E9%9B%86%E5%90%88%E7%9A%84%E6%AF%94%E8%BE%83"
                        >集合的比较</a
                      >
                    </li>
                  </ul>
                </li>
                <li><a href="#%E6%8C%87%E9%92%88">指针</a></li>
                <li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93">结构体</a></li>
                <li>
                  <a href="#%E4%BF%A1%E9%81%93">信道</a>
                  <ul>
                    <li><a href="#select%E8%AF%AD%E5%8F%A5">select语句</a></li>
                    <li><a href="#%E4%BA%92%E6%96%A5%E9%94%81">互斥锁</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>
              <a href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a>
              <ul>
                <li>
                  <a
                    href="#%E6%95%B0%E5%80%BC%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"
                    >数值转字符串</a
                  >
                </li>
                <li>
                  <a
                    href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E5%80%BC"
                    >字符串转数值</a
                  >
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </div>
    <div id="content">
      <h1 id="数据类型">数据类型</h1>
      <h2 id="内置类型">内置类型</h2>
      <table>
        <thead>
          <tr>
            <th>name</th>
            <th>dart</th>
            <th>go</th>
            <th>js</th>
            <th>python</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>numbers</td>
            <td>num</td>
            <td></td>
            <td>Number</td>
            <td>Numbers</td>
          </tr>
          <tr>
            <td>numbers</td>
            <td>int</td>
            <td>int</td>
            <td></td>
            <td>-int</td>
          </tr>
          <tr>
            <td>numbers</td>
            <td></td>
            <td>int8</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>numbers</td>
            <td></td>
            <td>int16</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>numbers</td>
            <td></td>
            <td>int32/rune</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>numbers</td>
            <td></td>
            <td>int64</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>numbers</td>
            <td></td>
            <td>uint</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>numbers</td>
            <td></td>
            <td>uint8/byte</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>numbers</td>
            <td></td>
            <td>uint16</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>numbers</td>
            <td></td>
            <td>uint32</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>numbers</td>
            <td></td>
            <td>uint64</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>numbers</td>
            <td></td>
            <td>uintptr</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>numbers</td>
            <td>double</td>
            <td>float32</td>
            <td></td>
            <td>-float</td>
          </tr>
          <tr>
            <td>numbers</td>
            <td></td>
            <td>float64</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>numbers</td>
            <td></td>
            <td>complex64</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>numbers</td>
            <td></td>
            <td>complex128</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>complex</td>
            <td></td>
            <td></td>
            <td></td>
            <td>complex</td>
          </tr>
          <tr>
            <td>strings</td>
            <td>String</td>
            <td>string</td>
            <td>String</td>
            <td>str</td>
          </tr>
          <tr>
            <td>booleans</td>
            <td>bool(true/false)</td>
            <td>bool</td>
            <td>Boolean(true/false)</td>
            <td>bool(True/False)</td>
          </tr>
          <tr>
            <td>lists/arrays</td>
            <td>List</td>
            <td></td>
            <td>-Array</td>
            <td>list</td>
          </tr>
          <tr>
            <td>maps</td>
            <td>map</td>
            <td></td>
            <td>-Map</td>
            <td>dict</td>
          </tr>
          <tr>
            <td>runes</td>
            <td>runes</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>symbols</td>
            <td>symbol</td>
            <td></td>
            <td>Symbol</td>
            <td></td>
          </tr>
          <tr>
            <td>Null</td>
            <td>-null</td>
            <td></td>
            <td>Null(null)</td>
            <td></td>
          </tr>
          <tr>
            <td>Undefined</td>
            <td></td>
            <td></td>
            <td>Undefined(undefined)</td>
            <td></td>
          </tr>
          <tr>
            <td>Object</td>
            <td>Object</td>
            <td></td>
            <td>Object</td>
            <td></td>
          </tr>
          <tr>
            <td>Set</td>
            <td>Set</td>
            <td></td>
            <td>-Set</td>
            <td>set</td>
          </tr>
          <tr>
            <td>ArrayBuffer</td>
            <td></td>
            <td></td>
            <td>-ArrayBuffer</td>
            <td>bytearray</td>
          </tr>
          <tr>
            <td>Tuples</td>
            <td></td>
            <td></td>
            <td></td>
            <td>tuple</td>
          </tr>
          <tr>
            <td>range</td>
            <td></td>
            <td></td>
            <td></td>
            <td>range</td>
          </tr>
          <tr>
            <td>Function</td>
            <td>-Function</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>dynamic</td>
            <td>dynamic</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
        </tbody>
      </table>
      <p>go</p>
      <p>
        int, uint 和 uintptr 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64
        位宽。 当你需要一个整数值时应使用 int
        类型，除非你有特殊的理由使用固定大小或无符号的整数类型。
      </p>
      <h3 id="默认类型">默认类型</h3>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go">// 在声明一个变量而不指定其类型时（即使用不带类型的 := 语法或 var = 表达式语法），
// 变量的类型由右值推导得出。
var i int
j := i // j 也是一个 int

// 不过当右边包含未指明类型的数值常量时，
// 新变量的类型就可能是 int, float64 或 complex128 了，
// 这取决于常量的精度：
i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <h2 id="类型判断">类型判断</h2>
      <p>dart</p>
      <pre><code class="language-dart">// as 类型转换
// is 如果对象是指定的类型返回 True
// is! 如果对象是指定的类型返回 False

if (emp is Person) { // Type check
  emp.firstName = &#39;Bob&#39;;
}
// 使用 as 操作符可以简化上面的代码：
(emp as Person).firstName = &#39;Bob&#39;;

// 可以使用 Object 的 runtimeType 属性来判断实例 的类型，
// 该属性 返回一个 Type 对象。
var msg = &#39;false&#39;;
print(&#39;The type of a is ${msg.runtimeType}&#39;);

// 其他方式
import &#39;dart:mirrors&#39;;
getTypeName(dynamic obj) {
  return reflect(obj).type.reflectedType.toString();
}</code></pre>
      <p>go</p>
      <pre><code class="language-go">var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
  default:
    fmt.Printf(&quot;unexpected type %T&quot;, t)       // %T 输出 t 是什么类型
  case bool:
    fmt.Printf(&quot;boolean %t\n&quot;, t)             // t 是 bool 类型
  case int:
    fmt.Printf(&quot;integer %d\n&quot;, t)             // t 是 int 类型
  case *bool:
    fmt.Printf(&quot;pointer to boolean %t\n&quot;, *t) // t 是 *bool 类型
  case *int:
    fmt.Printf(&quot;pointer to integer %d\n&quot;, *t) // t 是 *int 类型
}</code></pre>
      <p>js</p>
      <pre><code class="language-js">typeof undefined; // undefined
typeof []; // object
typeof &#39;123&#39;; // string
typeof null; // object

// instanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例。
const s = new String(&#39;123&#39;);
s instanceof String; // true
s instanceof Object; // true

v instanceof Vehicle
// 等同于
Vehicle.prototype.isPrototypeOf(v)


Object.prototype.toString.call(2) // &quot;[object Number]&quot;
Object.prototype.toString.call(&#39;&#39;) // &quot;[object String]&quot;
Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;
Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;
Object.prototype.toString.call(null) // &quot;[object Null]&quot;
Object.prototype.toString.call(Math) // &quot;[object Math]&quot;
Object.prototype.toString.call({}) // &quot;[object Object]&quot;
Object.prototype.toString.call([]) // &quot;[object Array]&quot;

var type = function (o){
  var s = Object.prototype.toString.call(o);
  return s.match(/\[object (.*?)\]/)[1].toLowerCase();
};
type({}); // &quot;object&quot;
type([]); // &quot;array&quot;
type(5); // &quot;number&quot;
type(null); // &quot;null&quot;
type(); // &quot;undefined&quot;
type(/abcd/); // &quot;regex&quot;
type(new Date()); // &quot;date&quot;

[&#39;Null&#39;,
 &#39;Undefined&#39;,
 &#39;Object&#39;,
 &#39;Array&#39;,
 &#39;String&#39;,
 &#39;Number&#39;,
 &#39;Boolean&#39;,
 &#39;Function&#39;,
 &#39;RegExp&#39;
].forEach(function (t) {
  type[&#39;is&#39; + t] = function (o) {
    return type(o) === t.toLowerCase();
  };
});
type.isObject({}) // true
type.isNumber(NaN) // true
type.isRegExp(/abc/) // true


function type (obj) {
  return Reflect.apply(Object.prototype.toString, obj, []).replace(/^\[object\s(\w+)\]$/, &#39;$1&#39;).toLowerCase()
}
type(new String(&#39;123&#39;)) // string</code></pre>
      <p>python</p>
      <pre><code class="language-python">import types
type(myInt) is types.IntType
type(myInt) is type(1)
isinstance(myInt, int)</code></pre>
      <h3 id="检查两个引用是否指向同一个对象">
        检查两个引用是否指向同一个对象
      </h3>
      <p>检查两个引用是否指向同一个对象(内存地址)</p>
      <p>dart</p>
      <pre><code class="language-dart">bool identical(Object a, Object b)</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <p>
        ES5
        比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。
        它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。
      </p>
      <pre><code class="language-js">Object.is(&#39;foo&#39;, &#39;foo&#39;)
// true
Object.is({}, {})
// false</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="基本类型">基本类型</h2>
      <h3 id="数值">数值</h3>
      <h4 id="数值操作">数值操作</h4>
      <p>dart</p>
      <pre><code class="language-dart">assert(int.parse(&#39;42&#39;) == 42);
assert(int.parse(&#39;0x42&#39;) == 66);
assert(double.parse(&#39;0.50&#39;) == 0.5);

assert(num.parse(&#39;42&#39;) is int);
assert(num.parse(&#39;0x42&#39;) is int);
assert(num.parse(&#39;0.50&#39;) is double);

assert(int.parse(&#39;42&#39;, radix: 16) == 66);

// Convert an int to a string.
assert(42.toString() == &#39;42&#39;);
// Convert a double to a string.
assert(123.456.toString() == &#39;123.456&#39;);
// Specify the number of digits after the decimal.
assert(123.456.toStringAsFixed(2) == &#39;123.46&#39;);
// Specify the number of significant figures.
assert(123.456.toStringAsPrecision(2) == &#39;1.2e+2&#39;);
assert(double.parse(&#39;1.2e+2&#39;) == 120.0);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">parseInt(&#39;v8&#39;,32) // 1000

const string1 = &#39;1&#39;
const number1 = parseInt(string1)
// 3
console.log(number1 + 2)</code></pre>
      <p>python</p>
      <pre><code class="language-python">string_1 = &quot;1&quot;
number_1 = int(string_1)
# 3
print(number_1 + 2)</code></pre>
      <h4 id="计算最大值和最小值">计算最大值和最小值</h4>
      <p>dart</p>
      <pre><code class="language-dart">assert(math.max(1, 1000) == 1000);
assert(math.min(1, -1000) == -1000);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">const a = [10,5,11,7,8,9];
Math.max(...a) - Math.min(...a)</code></pre>
      <p>python</p>
      <pre><code class="language-python"># 100
print(max(100, 50))
# 40
print(min(80, 40))</code></pre>
      <h4 id="数学常量">数学常量</h4>
      <p>dart</p>
      <pre><code class="language-dart">import &#39;dart:math&#39; as math;

print(math.E);     // 2.718281828459045
print(math.PI);    // 3.141592653589793
print(math.SQRT2); // 1.4142135623730951</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">Math.E // 2.718281828459045
Math.LN2 // 0.6931471805599453
Math.LN10 // 2.302585092994046
Math.LOG2E // 1.4426950408889634
Math.LOG10E // 0.4342944819032518
Math.PI // 3.141592653589793
Math.SQRT1_2 // 0.7071067811865476
Math.SQRT2 // 1.4142135623730951</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h4 id="随机数">随机数</h4>
      <p>dart</p>
      <pre><code class="language-dart">import &#39;dart:math&#39; as math;

var random = new math.Random();
random.nextDouble(); // Between 0.0 and 1.0: [0, 1)
random.nextInt(10);  // Between 0 and 9.

var random = new math.Random();
random.nextBool();  // true or false</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">// Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。
Math.random() // 0.7151307314634323

// 任意范围的随机数生成函数
function getRandomArbitrary(min, max) {
  return Math.random() * (max - min) + min;
}
getRandomArbitrary(1.5, 6.5)
// 2.4942810038223864

// 任意范围的随机整数生成函数
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
getRandomInt(1, 6) // 5

// 返回随机字符的例子
function random_str(length) {
  var ALPHABET = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;;
  ALPHABET += &#39;abcdefghijklmnopqrstuvwxyz&#39;;
  ALPHABET += &#39;0123456789-_&#39;;
  var str = &#39;&#39;;
  for (var i=0; i &lt; length; ++i) {
    var rand = Math.floor(Math.random() * ALPHABET.length);
    str += ALPHABET.substring(rand, rand + 1);
  }
  return str;
}
random_str(6) // &quot;NdQKOr&quot;

// 返回随机字符另一个实现
const str = &#39;abcdefghijklmnopqrstuvwxyz9876543210&#39;;
const l = 6;
// [...Array(l)].map(()=&gt;str.charAt(Math.floor(Math.random() * str.length))).join(&#39;&#39;);
[...Array(l)].map(()=&gt;str[~~(Math.random() * str.length)]).join(&#39;&#39;);</code></pre>
      <p>python</p>
      <pre><code class="language-sh">&gt;&gt;&gt; import random
&gt;&gt;&gt; random.choice([&#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;])
&#39;apple&#39;
&gt;&gt;&gt; random.sample(range(100), 10)   # sampling without replacement
[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
&gt;&gt;&gt; random.random()    # random float
0.17970987693706186
&gt;&gt;&gt; random.randrange(6)    # random integer chosen from range(6)
4

# statistics 模块计算数值数据的基本统计属性（均值，中位数，方差等）:
&gt;&gt;&gt; import statistics
&gt;&gt;&gt; data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]
&gt;&gt;&gt; statistics.mean(data)
1.6071428571428572
&gt;&gt;&gt; statistics.median(data)
1.25
&gt;&gt;&gt; statistics.variance(data)
1.3720238095238095</code></pre>
      <h5 id="生成随机整数">生成随机整数</h5>
      <p>dart</p>
      <pre><code class="language-dart">import &#39;dart:math&#39; as math;
var random = new math.Random();
random.nextInt(10);  // Between 0 and 9.</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">// 任意范围的随机整数生成函数
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
getRandomInt(1, 6) // 5</code></pre>
      <p>python</p>
      <pre><code class="language-sh">&gt;&gt;&gt; import random
&gt;&gt;&gt; random.randrange(6)    # random integer chosen from range(6)
4</code></pre>
      <h5 id="生成随机布尔值">生成随机布尔值</h5>
      <p>dart</p>
      <pre><code class="language-dart">import &#39;dart:math&#39; as math;

var random = new math.Random();
random.nextBool();  // true or false</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h5 id="生成随机字符串">生成随机字符串</h5>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">// 返回随机字符的例子
function random_str(length) {
  var ALPHABET = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;;
  ALPHABET += &#39;abcdefghijklmnopqrstuvwxyz&#39;;
  ALPHABET += &#39;0123456789-_&#39;;
  var str = &#39;&#39;;
  for (var i=0; i &lt; length; ++i) {
    var rand = Math.floor(Math.random() * ALPHABET.length);
    str += ALPHABET.substring(rand, rand + 1);
  }
  return str;
}
random_str(6) // &quot;NdQKOr&quot;

// 返回随机字符另一个实现
const str = &#39;abcdefghijklmnopqrstuvwxyz9876543210&#39;;
const l = 6;
// [...Array(l)].map(()=&gt;str.charAt(Math.floor(Math.random() * str.length))).join(&#39;&#39;);
[...Array(l)].map(()=&gt;str[~~(Math.random() * str.length)]).join(&#39;&#39;);</code></pre>
      <p>python</p>
      <pre><code class="language-sh"></code></pre>
      <h5 id="随机选择子对象">随机选择子对象</h5>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-sh">&gt;&gt;&gt; import random
&gt;&gt;&gt; random.choice([&#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;])
&#39;apple&#39;</code></pre>
      <h4 id="三角函数">三角函数</h4>
      <p>dart</p>
      <pre><code class="language-dart">import &#39;dart:math&#39; as math;

// Cosine
assert(math.cos(math.PI) == -1.0);

// Sine
var degrees = 30;
var radians = degrees * (math.PI / 180);
// radians is now 0.52359.
var sinOf30degrees = math.sin(radians);
// sin 30° = 0.5
assert((sinOf30degrees - 0.5).abs() &lt; 0.01);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">Math.sin(0) // 0
Math.cos(0) // 1
Math.tan(0) // 0

Math.sin(Math.PI / 2) // 1

Math.asin(1) // 1.5707963267948966
Math.acos(1) // 0
Math.atan(1) // 0.7853981633974483</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h4 id="十进制浮点运算">十进制浮点运算</h4>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">// 小数点截取
(10).toFixed(2) // &quot;10.00&quot;
10.005.toFixed(2) // &quot;10.01&quot;

// 2
console.log(Math.ceil(1.5))
// 1
console.log(Math.floor(1.5))
// 2
console.log(Math.round(1.5))</code></pre>
      <p>python</p>
      <pre><code class="language-python">import math

# 2
print(math.ceil(1.5))
# 1
print(math.floor(1.5))
# 2
print(round(1.5))</code></pre>
      <h4 id="进制转换">进制转换</h4>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">// 10进制转为32进制
(1000).toString(32) // &#39;v8&#39;
// 32进制转为10进制
parseInt(&#39;v8&#39;,32) // 1000</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="字符串">字符串</h3>
      <p>dart</p>
      <p>
        Dart 字符串是 UTF-16 编码的字符序列。
        可以使用单引号或者双引号来创建字符串：
      </p>
      <pre><code class="language-dart">var s1 = &#39;Single quotes work well for string literals.&#39;;
var s2 = &quot;Double quotes work just as well.&quot;;
var s3 = &#39;It\&#39;s easy to escape the string delimiter.&#39;;
var s4 = &quot;It&#39;s even easier to use the other delimiter.&quot;;</code></pre>
      <p>go</p>
      <p>
        Go中的字符串都是采用UTF-8字符集编码。
        字符串是用一对双引号（&quot;&quot;）或反引号（`` ）括起来定义
      </p>
      <pre><code class="language-go">var frenchHello string  // 声明变量为字符串的一般方法
var emptyString string = &quot;&quot;  // 声明了一个字符串变量，初始化为空字符串
func test() {
  no, yes, maybe := &quot;no&quot;, &quot;yes&quot;, &quot;maybe&quot;  // 简短声明，同时声明多个变量
  japaneseHello := &quot;Konichiwa&quot;  // 同上
  frenchHello = &quot;Bonjour&quot;  // 常规赋值
}


// Go中字符串是不可变的
var s string = &quot;hello&quot;
s[0] = &#39;c&#39; // 出错！！！！

s := &quot;hello&quot;
c := []byte(s)  // 将字符串 s 转换为 []byte 类型
c[0] = &#39;c&#39;
s2 := string(c)  // 再转换回 string 类型
fmt.Printf(&quot;%s\n&quot;, s2)</code></pre>
      <p>js</p>
      <pre><code class="language-js">const someString = &#39;abcd&#39;
// 4
console.log(someString.length)</code></pre>
      <p>python</p>
      <pre><code class="language-python">some_string = &quot;abcd&quot;
# 4
print(len(some_string))

&#39;spam eggs&#39;  # single quotes
&#39;doesn\&#39;t&#39;  # use \&#39; to escape the single quote...
&quot;doesn&#39;t&quot;  # ...or use double quotes instead
&#39;&quot;Yes,&quot; they said.&#39;
&quot;\&quot;Yes,\&quot; they said.&quot;
&#39;&quot;Isn\&#39;t,&quot; they said.&#39;

print(&#39;C:\some\name&#39;)  # here \n means newline!
print(r&#39;C:\some\name&#39;)  # note the r before the quote

# 字符串可以用 + 进行连接（粘到一起），也可以用 * 进行重复:
# 3 times &#39;un&#39;, followed by &#39;ium&#39;
3 * &#39;un&#39; + &#39;ium&#39;

# 相邻的两个或多个 字符串字面值 （引号引起来的字符）将会自动连接到一起.
&#39;Py&#39; &#39;thon&#39;</code></pre>
      <pre><code class="language-sh"># 字符串是可以被 索引 （下标访问）的，第一个字符索引是 0。
&gt;&gt;&gt; word = &#39;Python&#39;
&gt;&gt;&gt; word[0]  # character in position 0
&#39;P&#39;
&gt;&gt;&gt; word[5]  # character in position 5
&#39;n&#39;

# 索引也可以用负数，这种会从右边开始数:
&gt;&gt;&gt; word[-1]  # last character
&#39;n&#39;
&gt;&gt;&gt; word[-2]  # second-last character
&#39;o&#39;
&gt;&gt;&gt; word[-6]
&#39;P&#39;

# 除了索引，字符串还支持 切片。
&gt;&gt;&gt; word[0:2]  # characters from position 0 (included) to 2 (excluded)
&#39;Py&#39;
&gt;&gt;&gt; word[2:5]  # characters from position 2 (included) to 5 (excluded)
&#39;tho&#39;
&gt;&gt;&gt; word[:2] + word[2:]
&#39;Python&#39;
&gt;&gt;&gt; word[:4] + word[4:]
&#39;Python&#39;</code></pre>
      <h4 id="多行字符串">多行字符串</h4>
      <p>dart</p>
      <p>使用三个单引号或者双引号也可以 创建多行字符串对象：</p>
      <pre><code class="language-dart">var s1 = &#39;&#39;&#39;
You can create
multi-line strings like this one.
&#39;&#39;&#39;;

var s2 = &quot;&quot;&quot;This is also a
multi-line string.&quot;&quot;&quot;;</code></pre>
      <p>go</p>
      <p>
        `` 括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，
        它没有字符转义，换行也将原样输出
      </p>
      <pre><code class="language-go">m := `hello
  world`</code></pre>
      <p>js</p>
      <pre><code class="language-js">const x = `------
Line 1
Line 2
Line 3
------`</code></pre>
      <p>python</p>
      <pre><code class="language-python">x = &quot;&quot;&quot;------
Line 1
Line 2
Line 3
------&quot;&quot;&quot;

print(&quot;&quot;&quot;\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
&quot;&quot;&quot;)

text = (&#39;Put several strings within parentheses &#39;
        &#39;to have them joined together.&#39;)</code></pre>
      <h4 id="字符串前缀">字符串前缀</h4>
      <h5 id="原始字符串">原始字符串</h5>
      <p>dart</p>
      <pre><code class="language-dart">var s = r&quot;In a raw string, even \n isn&#39;t special.&quot;;</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python">print(r&#39;C:\some\name&#39;)  # note the r before the quote</code></pre>
      <h4 id="字符串搜索">字符串搜索</h4>
      <p>dart</p>
      <pre><code class="language-dart">// Check whether a string contains another string.
assert(&#39;Never odd or even&#39;.contains(&#39;odd&#39;));

// Does a string start with another string?
assert(&#39;Never odd or even&#39;.startsWith(&#39;Never&#39;));

// Does a string end with another string?
assert(&#39;Never odd or even&#39;.endsWith(&#39;even&#39;));

// Find the location of a string inside a string.
assert(&#39;Never odd or even&#39;.indexOf(&#39;odd&#39;) == 6);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">let s = &#39;Hello world!&#39;;
s.startsWith(&#39;Hello&#39;) // true
s.endsWith(&#39;!&#39;) // true
s.includes(&#39;o&#39;) // true

let s = &#39;Hello world!&#39;;
s.startsWith(&#39;world&#39;, 6) // true
s.endsWith(&#39;Hello&#39;, 5) // true
s.includes(&#39;Hello&#39;, 6) // false

&#39;hello world&#39;.indexOf(&#39;o&#39;) // 4
&#39;JavaScript&#39;.indexOf(&#39;script&#39;) // -1
&#39;hello world&#39;.indexOf(&#39;o&#39;, 6) // 7

&#39;hello world&#39;.lastIndexOf(&#39;o&#39;) // 7
&#39;hello world&#39;.lastIndexOf(&#39;o&#39;, 6) // 4

&#39;cat, bat, sat, fat&#39;.search(&#39;at&#39;) // 1
// replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。
&#39;aaa&#39;.replace(&#39;a&#39;, &#39;b&#39;) // &quot;baa&quot;

// 2 is in the string
if (&#39;123&#39;.includes(&#39;2&#39;)) {
  console.log(&#39;2 is in the string&#39;)
}

// 2 is not in the string
if (!&#39;456&#39;.includes(&#39;2&#39;)) {
  console.log(&#39;2 is not in the string&#39;)
}

// Has a number
if (&#39;iphone 8&#39;.match(/\d/g)) {
  console.log(&#39;Has a number&#39;)
}

// Doesn&#39;t have a number
if (!&#39;iphone x&#39;.match(/\d/g)) {
  console.log(&quot;Doesn&#39;t have a number&quot;)
}</code></pre>
      <p>python</p>
      <pre><code class="language-python"># 2 is in the string
if &quot;2&quot; in &quot;123&quot;:
    print(&quot;2 is in the string&quot;)

# 2 is not in the string
if &quot;2&quot; not in &quot;456&quot;:
    print(&quot;2 is not in the string&quot;)


import re

# Has a number
if re.search(r&quot;\d&quot;, &quot;iphone 8&quot;):
    print(&quot;Has a number&quot;)

# Doesn&#39;t have a number
if not re.search(r&quot;\d&quot;, &quot;iphone x&quot;):
    print(&quot;Doesn&#39;t have a number&quot;)</code></pre>
      <h4 id="字符串截取">字符串截取</h4>
      <p>dart</p>
      <pre><code class="language-dart">// Grab a substring.
assert(&#39;Never odd or even&#39;.substring(6, 9) == &#39;odd&#39;);

// Split a string using a string pattern.
var parts = &#39;structured web apps&#39;.split(&#39; &#39;);
assert(parts.length == 3);
assert(parts[0] == &#39;structured&#39;);

// Get a UTF-16 code unit (as a string) by index.
assert(&#39;Never odd or even&#39;[0] == &#39;N&#39;);

// Use split() with an empty string parameter to get
// a list of all characters (as Strings); good for
// iterating.
for (var char in &#39;hello&#39;.split(&#39;&#39;)) {
  print(char);
}

// Get all the UTF-16 code units in the string.
var codeUnitList = &#39;Never odd or even&#39;.codeUnits.toList();
assert(codeUnitList[0] == 78);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">&#39;a|b|c&#39;.split(&#39;|&#39;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
&#39;a||c&#39;.split(&#39;|&#39;) // [&#39;a&#39;, &#39;&#39;, &#39;c&#39;]

// slice方法用于从原字符串取出子字符串并返回，不改变原字符串。
// 它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。

// substring方法跟slice方法很相像
// 不建议使用substring方法，应该优先使用slice
&#39;JavaScript&#39;.slice(0, 4) // &quot;Java&quot;
&#39;JavaScript&#39;.slice(-6) // &quot;Script&quot;
&#39;JavaScript&#39;.slice(0, -6) // &quot;Java&quot;
&#39;JavaScript&#39;.slice(-2, -1) // &quot;p&quot;

// substr方法的第一个参数是子字符串的开始位置（从0开始计算），第二个参数是子字符串的长度。
// 如果省略第二个参数，则表示子字符串一直到原字符串的结束。
// 如果第一个参数是负数，表示倒数计算的字符位置。
// 如果第二个参数是负数，将被自动转为0，因此会返回空字符串。
&#39;JavaScript&#39;.substr(4, 6) // &quot;Script&quot;
&#39;JavaScript&#39;.substr(-6) // &quot;Script&quot;
&#39;JavaScript&#39;.substr(4, -1) // &quot;&quot;

const someString = &#39;0123456&#39;
// 234
console.log(someString.substring(2, 5))


const someString = &#39;a,b,c&#39;
const someStringSplit = someString.split(&#39;,&#39;)
// a
console.log(someStringSplit[0])
// b
console.log(someStringSplit[1])
// c
console.log(someStringSplit[2])</code></pre>
      <p>python</p>
      <pre><code class="language-python">some_string = &quot;0123456&quot;
# 234
print(some_string[2:5])


some_string = &quot;a,b,c&quot;
some_string_split = some_string.split(&quot;,&quot;)
# a
print(some_string_split[0])
# b
print(some_string_split[1])
# c
print(some_string_split[2])</code></pre>
      <h4 id="大小写转换">大小写转换</h4>
      <p>dart</p>
      <pre><code class="language-dart">// Convert to uppercase.
assert(&#39;structured web apps&#39;.toUpperCase() == &#39;STRUCTURED WEB APPS&#39;);

// Convert to lowercase.
assert(&#39;STRUCTURED WEB APPS&#39;.toLowerCase() == &#39;structured web apps&#39;);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">&#39;Hello World&#39;.toLowerCase()
// &quot;hello world&quot;

&#39;Hello World&#39;.toUpperCase()
// &quot;HELLO WORLD&quot;</code></pre>
      <p>python</p>
      <pre><code class="language-python"># 返回原字符串的副本，其中大写字符转换为小写，小写转为大写
# 请注意 s.swapcase().swapcase() == s 并不一定为真值。
str.swapcase()
# 返回原字符串的副本，其中所有区分大小写的字符 [4] 均转换为大写
str.upper()
# 返回原字符串的副本，其所有区分大小写的字符 [4] 均转换为小写
str.lower()</code></pre>
      <h4 id="裁剪和判断空字符串">裁剪和判断空字符串</h4>
      <p>dart</p>
      <pre><code class="language-dart">// Trim a string.
assert(&#39;  hello  &#39;.trim() == &#39;hello&#39;);

// Check whether a string is empty.
assert(&#39;&#39;.isEmpty);

// Strings with only white space are not empty.
assert(!&#39;  &#39;.isEmpty);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">&#39;  hello world  &#39;.trim()
// &quot;hello world&quot;

const s = &#39;  abc  &#39;;
s.trim() // &quot;abc&quot;
s.trimStart() // &quot;abc  &quot;
s.trimEnd() // &quot;  abc&quot;</code></pre>
      <p>python</p>
      <pre><code class="language-python">some_string = &quot;   abc   &quot;
# abc
print(some_string.strip())</code></pre>
      <h4 id="替换部分字符">替换部分字符</h4>
      <p>dart</p>
      <pre><code class="language-dart">var greetingTemplate = &#39;Hello, NAME!&#39;;
var greeting = greetingTemplate
    .replaceAll(new RegExp(&#39;NAME&#39;), &#39;Bob&#39;);

assert(greeting !=
    greetingTemplate); // greetingTemplate didn&#39;t change.</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">// replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。
&#39;aaa&#39;.replace(&#39;a&#39;, &#39;b&#39;) // &quot;baa&quot;


const someString = &#39;a b c d e&#39;
// Only changes the first space
// a,b c d e
// console.log(someString.replace(&#39; &#39;, &#39;,&#39;))

// Use / /g instead of &#39; &#39; to change every space
console.log(someString.replace(/ /g, &#39;,&#39;))</code></pre>
      <p>python</p>
      <pre><code class="language-python">some_string = &quot;a b c d e&quot;
# a,b,c,d,e
print(some_string.replace(&quot; &quot;, &quot;,&quot;))</code></pre>
      <h4 id="格式化输出">格式化输出</h4>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">const x = &#39;Hello&#39;
// Hello World
console.log(`${x} World`)</code></pre>
      <p>python</p>
      <pre><code class="language-python">x = &quot;Hello&quot;
# Hello World
print(f&quot;{x} World&quot;)</code></pre>
      <pre><code class="language-sh">&gt;&gt;&gt; year = 2016
&gt;&gt;&gt; event = &#39;Referendum&#39;
&gt;&gt;&gt; f&#39;Results of the {year} {event}&#39;
&#39;Results of the 2016 Referendum&#39;

&gt;&gt;&gt; yes_votes = 42_572_654
&gt;&gt;&gt; no_votes = 43_132_495
&gt;&gt;&gt; percentage = yes_votes / (yes_votes + no_votes)
&gt;&gt;&gt; &#39;{:-9} YES votes  {:2.2%}&#39;.format(yes_votes, percentage)
&#39; 42572654 YES votes  49.67%&#39;

# 当你不需要花哨的输出而只是想快速显示某些变量以进行调试时，
# 可以使用 repr() or str() 函数将任何值转化为字符串。
&gt;&gt;&gt; s = &#39;Hello, world.&#39;
&gt;&gt;&gt; str(s)
&#39;Hello, world.&#39;
&gt;&gt;&gt; repr(s)
&quot;&#39;Hello, world.&#39;&quot;
&gt;&gt;&gt; str(1/7)
&#39;0.14285714285714285&#39;
&gt;&gt;&gt; x = 10 * 3.25
&gt;&gt;&gt; y = 200 * 200
&gt;&gt;&gt; s = &#39;The value of x is &#39; + repr(x) + &#39;, and y is &#39; + repr(y) + &#39;...&#39;
&gt;&gt;&gt; print(s)
The value of x is 32.5, and y is 40000...
&gt;&gt;&gt; # The repr() of a string adds string quotes and backslashes:
... hello = &#39;hello, world\n&#39;
&gt;&gt;&gt; hellos = repr(hello)
&gt;&gt;&gt; print(hellos)
&#39;hello, world\n&#39;
&gt;&gt;&gt; # The argument to repr() may be any Python object:
... repr((x, y, (&#39;spam&#39;, &#39;eggs&#39;)))
&quot;(32.5, 40000, (&#39;spam&#39;, &#39;eggs&#39;))&quot;

# 将pi舍入到小数点后三位:
&gt;&gt;&gt; import math
&gt;&gt;&gt; print(f&#39;The value of pi is approximately {math.pi:.3f}.&#39;)
The value of pi is approximately 3.142.

# 在 &#39;:&#39; 后传递一个整数可以让该字段成为最小字符宽度。这在使列对齐时很有用。
&gt;&gt;&gt; table = {&#39;Sjoerd&#39;: 4127, &#39;Jack&#39;: 4098, &#39;Dcab&#39;: 7678}
&gt;&gt;&gt; for name, phone in table.items():
...     print(f&#39;{name:10} ==&gt; {phone:10d}&#39;)
...
Sjoerd     ==&gt;       4127
Jack       ==&gt;       4098
Dcab       ==&gt;       7678

# 其他的修饰符可用于在格式化之前转化值。
# &#39;!a&#39; 应用 ascii() ，&#39;!s&#39; 应用 str()，还有 &#39;!r&#39; 应用 repr():
&gt;&gt;&gt; animals = &#39;eels&#39;
&gt;&gt;&gt; print(f&#39;My hovercraft is full of {animals}.&#39;)
My hovercraft is full of eels.
&gt;&gt;&gt; print(f&#39;My hovercraft is full of {animals!r}.&#39;)
My hovercraft is full of &#39;eels&#39;.

# 字符串的 format() 方法
&gt;&gt;&gt; print(&#39;We are the {} who say &quot;{}!&quot;&#39;.format(&#39;knights&#39;, &#39;Ni&#39;))
We are the knights who say &quot;Ni!&quot;

&gt;&gt;&gt; print(&#39;{0} and {1}&#39;.format(&#39;spam&#39;, &#39;eggs&#39;))
spam and eggs
&gt;&gt;&gt; print(&#39;{1} and {0}&#39;.format(&#39;spam&#39;, &#39;eggs&#39;))
eggs and spam

&gt;&gt;&gt; print(&#39;This {food} is {adjective}.&#39;.format(
...       food=&#39;spam&#39;, adjective=&#39;absolutely horrible&#39;))
This spam is absolutely horrible.

&gt;&gt;&gt; print(&#39;The story of {0}, {1}, and {other}.&#39;.format(&#39;Bill&#39;, &#39;Manfred&#39;,
                                                       other=&#39;Georg&#39;))
The story of Bill, Manfred, and Georg.

&gt;&gt;&gt; for x in range(1, 11):
...     print(&#39;{0:2d} {1:3d} {2:4d}&#39;.format(x, x*x, x*x*x))
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000

# str.zfill() ，它会在数字字符串的左边填充零。它能识别正负号:
&gt;&gt;&gt; &#39;12&#39;.zfill(5)
&#39;00012&#39;
&gt;&gt;&gt; &#39;-3.14&#39;.zfill(7)
&#39;-003.14&#39;
&gt;&gt;&gt; &#39;3.14159265359&#39;.zfill(5)
&#39;3.14159265359&#39;

# 旧的字符串格式化方法
&gt;&gt;&gt; import math
&gt;&gt;&gt; print(&#39;The value of pi is approximately %5.3f.&#39; % math.pi)
The value of pi is approximately 3.142.

&gt;&gt;&gt; import reprlib
&gt;&gt;&gt; reprlib.repr(set(&#39;supercalifragilisticexpialidocious&#39;))
&quot;{&#39;a&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, ...}&quot;

&gt;&gt;&gt; import pprint
&gt;&gt;&gt; t = [[[[&#39;black&#39;, &#39;cyan&#39;], &#39;white&#39;, [&#39;green&#39;, &#39;red&#39;]], [[&#39;magenta&#39;,
...     &#39;yellow&#39;], &#39;blue&#39;]]]
...
&gt;&gt;&gt; pprint.pprint(t, width=30)
[[[[&#39;black&#39;, &#39;cyan&#39;],
   &#39;white&#39;,
   [&#39;green&#39;, &#39;red&#39;]],
  [[&#39;magenta&#39;, &#39;yellow&#39;],
   &#39;blue&#39;]]]

&gt;&gt;&gt; import textwrap
&gt;&gt;&gt; doc = &quot;&quot;&quot;The wrap() method is just like fill() except that it returns
... a list of strings instead of one big string with newlines to separate
... the wrapped lines.&quot;&quot;&quot;
...
&gt;&gt;&gt; print(textwrap.fill(doc, width=40))
The wrap() method is just like fill()
except that it returns a list of strings
instead of one big string with newlines
to separate the wrapped lines.</code></pre>
      <h3 id="Symbols">Symbols</h3>
      <p>dart</p>
      <p>
        mirror 系统使用 Symbol 类对象 来表达定义的 Dart 标识符名字。 Symbols
        在混淆后的代码也可以 使用。
      </p>
      <p>
        如果在写代码的时候，已经知道 symbol 的名字了，则可以使用 #符号名字
        的方式直接使用。 直接使用的 symbol
        对象是编译时常量，多次定义引用的是同一个对象。
        如果名字不知道，则可以通过 Symbol 构造函数来 创建
      </p>
      <pre><code class="language-dart">import &#39;dart:mirrors&#39;;

// If the symbol name is known at compile time.
const className = #MyClass;

// If the symbol name is dynamically determined.
var userInput = askUserForNameOfFunction();
var functionName = new Symbol(userInput);

// 要获取原来的 symbol 名字，使用 MirrorSystem.getName() 函数。
import &#39;dart:mirrors&#39;;
const className = #MyClass;
assert(&#39;MyClass&#39; == MirrorSystem.getName(className));</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <p>
        ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。 它是 JavaScript
        语言的第七种数据类型，
        前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。
      </p>
      <p>
        除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol
        值，指向语言内部使用的方法。
      </p>
      <pre><code class="language-js">let s = Symbol();
typeof s
// &quot;symbol&quot;

let s1 = Symbol(&#39;foo&#39;);
let s2 = Symbol(&#39;bar&#39;);
s1 // Symbol(foo)
s2 // Symbol(bar)
s1.toString() // &quot;Symbol(foo)&quot;
s2.toString() // &quot;Symbol(bar)&quot;

// 没有参数的情况
let s1 = Symbol();
let s2 = Symbol();
s1 === s2 // false

// 有参数的情况
let s1 = Symbol(&#39;foo&#39;);
let s2 = Symbol(&#39;foo&#39;);
s1 === s2 // false

const mySymbol = Symbol();
const a = {};
a.mySymbol = &#39;Hello!&#39;;
a[mySymbol] // undefined
a[&#39;mySymbol&#39;] // &quot;Hello!&quot;

let s1 = Symbol.for(&#39;foo&#39;);
let s2 = Symbol.for(&#39;foo&#39;);
s1 === s2 // true</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="其他基本类型">其他基本类型</h3>
      <h4 id="null">null</h4>
      <h4 id="undefined">undefined</h4>
      <h2 id="复杂类型">复杂类型</h2>
      <h3 id="列表">列表</h3>
      <p>list/array列表/数组定义及操作</p>
      <p>dart</p>
      <pre><code class="language-dart">var l = [1, 2, 3];

// 在 list 字面量之前添加 const 关键字，
// 可以 定义一个不变的 list 对象（编译时常量）
var constantList = const [1, 2, 3];
var names = &lt;String&gt;[&#39;Seth&#39;, &#39;Kathy&#39;, &#39;Lars&#39;];

// Use a List constructor.
var vegetables = new List();

// Or simply use a list literal.
var fruits = [&#39;apples&#39;, &#39;oranges&#39;];

// Add to a list.
fruits.add(&#39;kiwis&#39;);

// Add multiple items to a list.
fruits.addAll([&#39;grapes&#39;, &#39;bananas&#39;]);

// Get the list length.
assert(fruits.length == 5);

// Remove a single item.
var appleIndex = fruits.indexOf(&#39;apples&#39;);
fruits.removeAt(appleIndex);
assert(fruits.length == 4);

// Remove all elements from a list.
fruits.clear();
assert(fruits.length == 0);

// 使用 indexOf() 来查找 list 中对象的索引
var fruits = [&#39;apples&#39;, &#39;oranges&#39;];
// Access a list item by index.
assert(fruits[0] == &#39;apples&#39;);
// Find an item in a list.
assert(fruits.indexOf(&#39;apples&#39;) == 0);

// 排序
var fruits = [&#39;bananas&#39;, &#39;apples&#39;, &#39;oranges&#39;];
// Sort a list.
fruits.sort((a, b) =&gt; a.compareTo(b));
assert(fruits[0] == &#39;apples&#39;);

// 可以使用 map().toList() 或者 map().toSet() 来 强制立刻执行 map 的方法：
var loudTeaList = teas
    .map((tea) =&gt; tea.toUpperCase())
    .toList();</code></pre>
      <p>go</p>
      <p>
        类型 [n]T 表示拥有 n 个 T 类型的值的数组。
        数组的长度是其类型的一部分，因此数组不能改变大小。
      </p>
      <p>
        表达式: <code>var a [10]int</code>， 会将变量 a 声明为拥有 10
        个整数的数组。
      </p>
      <pre><code class="language-go">package main
import &quot;fmt&quot;
func main() {
  var a [2]string
  a[0] = &quot;Hello&quot;
  a[1] = &quot;World&quot;
  fmt.Println(a[0], a[1])
  fmt.Println(a)
  primes := [6]int{2, 3, 5, 7, 11}
  fmt.Println(primes)
}
// Hello World
// [Hello World]
// [2 3 5 7 11 0]</code></pre>
      <p>js</p>
      <pre><code class="language-js">let l = [1, 2, 3];

var arr = [1, 2, 3];
typeof arr // &quot;object&quot;
Array.isArray(arr) // true

var arr = [1, 2, 3];
arr.valueOf() // [1, 2, 3]

var arr = [1, 2, 3];
arr.toString() // &quot;1,2,3&quot;
var arr = [1, 2, 3, [4, 5, 6]];
arr.toString() // &quot;1,2,3,4,5,6&quot;

var arr = [];
arr.push(1, 2);
arr.push(3);
arr.pop();
arr // [1, 2]

var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.shift() // &#39;a&#39;
a // [&#39;b&#39;, &#39;c&#39;]

var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.unshift(&#39;x&#39;); // 4
a // [&#39;x&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

var a = [1, 2, 3, 4];
a.join(&#39; &#39;) // &#39;1 2 3 4&#39;
a.join(&#39; | &#39;) // &quot;1 | 2 | 3 | 4&quot;
a.join() // &quot;1,2,3,4&quot;

[&#39;hello&#39;].concat([&#39;world&#39;])
// [&quot;hello&quot;, &quot;world&quot;]
[&#39;hello&#39;].concat([&#39;world&#39;], [&#39;!&#39;])
// [&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;]
[1, 2, 3].concat(4, 5, 6)
// [1, 2, 3, 4, 5, 6]

var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.reverse() // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
a // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]

// arr.slice(start, end);
var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.slice(0) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
a.slice(1) // [&quot;b&quot;, &quot;c&quot;]
a.slice(1, 2) // [&quot;b&quot;]
a.slice(2, 6) // [&quot;c&quot;]
a.slice() // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.slice(-2) // [&quot;b&quot;, &quot;c&quot;]
a.slice(-2, -1) // [&quot;b&quot;]

var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.slice(4) // []
a.slice(2, 1) // []

// arr.splice(start, count, addElement1, addElement2, ...);
var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;];
a.splice(4, 2) // [&quot;e&quot;, &quot;f&quot;]
a // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]

// sort方法对数组成员进行排序，默认是按照字典顺序排序
// 排序后，原数组将被改变。
[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;].sort()
// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
[11, 101].sort()
// [101, 11]

[10111, 1101, 111].sort(function (a, b) {
  return a - b;
})
// [111, 1101, 10111]

[
  { name: &quot;张三&quot;, age: 30 },
  { name: &quot;李四&quot;, age: 24 },
  { name: &quot;王五&quot;, age: 28  }
].sort(function (o1, o2) {
  return o1.age - o2.age;
})
// [
//   { name: &quot;李四&quot;, age: 24 },
//   { name: &quot;王五&quot;, age: 28  },
//   { name: &quot;张三&quot;, age: 30 }
// ]

var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.indexOf(&#39;b&#39;) // 1
a.indexOf(&#39;y&#39;) // -1

var users = [
  {name: &#39;tom&#39;, email: &#39;tom@example.com&#39;},
  {name: &#39;peter&#39;, email: &#39;peter@example.com&#39;}
];
users
  .map(function (user) {
    return user.email;
  })
  .filter(function (email) {
    return /^t/.test(email);
  })
  .forEach(function (email) {
    console.log(email);
  });
// &quot;tom@example.com&quot;

const someList = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
// a,b,c
console.log(someList.join(&#39;,&#39;))


const someList = [6, 3, 5]
console.log(someList.length)
// 6
// 3
// 5
someList.forEach(element =&gt; {
  console.log(element)
})

// 2 is in the list
if ([1, 2, 3].includes(2)) {
  console.log(&#39;2 is in the list&#39;)
}

// 2 is not in the list
if (![4, 5, 6].includes(2)) {
  console.log(&#39;2 is not in the list&#39;)
}

const someList = [1, 2, 3, 4]
someList.reverse()

// 4
// 3
// 2
// 1
someList.forEach(element =&gt; {
  console.log(element)
})


const someList = [1]
someList.push(...[2, 3])
// 1
// 2
// 3
someList.forEach(element =&gt; {
  console.log(element)
})


const originalList = [1]
const newList = originalList.concat([2, 3])
originalList[0] = 5
// 1
// 2
// 3
newList.forEach(element =&gt; {
  console.log(element)
})


const someList = [4, 5]
someList.unshift(3)
// 3
// 4
// 5
someList.forEach(element =&gt; {
  console.log(element)
})


const someList = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
someList.splice(1, 1)
// a
// c
someList.forEach(element =&gt; {
  console.log(element)
})


const someList = [1, 2, 3, 4]
// 4
console.log(someList.pop())
// 1
console.log(someList.shift())
// 2
// 3
someList.forEach(element =&gt; {
  console.log(element)
})


const someList = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
// 2
console.log(someList.indexOf(&#39;c&#39;))


const originalList = [1, 2, 3]
const newList = [...originalList]
originalList[2] = 4

// 1
// 2
// 3
newList.forEach(element =&gt; {
  console.log(element)
})


const someList = [1, 2, 3]
const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue
// 6
console.log(someList.reduce(reducer))</code></pre>
      <p>python</p>
      <pre><code class="language-python">some_list = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
# a,b,c
print(&quot;,&quot;.join(some_list))

some_list = [6, 3, 5]
print(len(some_list))
# 6
# 3
# 5
for item in some_list:
    print(item)

# 2 is in the list
if 2 in [1, 2, 3]:
    print(&quot;2 is in the list&quot;)

# 2 is not in the list
if 2 not in [4, 5, 6]:
    print(&quot;2 is not in the list&quot;)

some_list = [1, 2, 3, 4]
# reversed(some_list) is just an iterable.
# To convert an iterable into a list, use list()
reversed_list = list(reversed(some_list))
# 4
# 3
# 2
# 1
for item in reversed_list:
    print(item)
# You can use an iterable instead of a list in a for loop
# for item in reversed(some_list):


some_list = [1]
some_list.extend([2, 3])

# 1
# 2
# 3
for x in some_list:
    print(x)


original_list = [1]
new_list = original_list + [2, 3]
original_list[0] = 5
# 1
# 2
# 3
for x in new_list:
    print(x)


some_list = [4, 5]
some_list.insert(0, 3)
# 3
# 4
# 5
for x in some_list:
    print(x)


some_list = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
del some_list[1]
# a
# c
for x in some_list:
    print(x)


some_list = [1, 2, 3, 4]
# 4
print(some_list.pop())
# 1
print(some_list.pop(0))
# 2
# 3
for x in some_list:
    print(x)


some_list = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
# 2
print(some_list.index(&quot;c&quot;))


original_list = [1, 2, 3]
new_list = original_list[:]  # or original_list.copy()
original_list[2] = 4
# 1
# 2
# 3
for x in new_list:
    print(x)


some_list = [1, 2, 3]
# 6
print(sum(some_list))</code></pre>
      <pre><code class="language-sh">&gt;&gt;&gt; squares = [1, 4, 9, 16, 25]
&gt;&gt;&gt; squares
[1, 4, 9, 16, 25]

# 列表也支持索引和切片:
&gt;&gt;&gt; squares[0]  # indexing returns the item
1
&gt;&gt;&gt; squares[-1]
25
&gt;&gt;&gt; squares[-3:]  # slicing returns a new list
[9, 16, 25]

# 切片会返回列表的一个新的(浅)拷贝:
&gt;&gt;&gt; squares[:]
[1, 4, 9, 16, 25]

# 列表同样支持拼接操作:
&gt;&gt;&gt; squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# 与 immutable 的字符串不同, 列表是一个 mutable 类型，
# 就是说，它自己的内容可以改变:
&gt;&gt;&gt; cubes = [1, 8, 27, 65, 125]  # something&#39;s wrong here
&gt;&gt;&gt; 4 ** 3  # the cube of 4 is 64, not 65!
64
&gt;&gt;&gt; cubes[3] = 64  # replace the wrong value
&gt;&gt;&gt; cubes
[1, 8, 27, 64, 125]

# 通过 append() 方法 添加新元素
&gt;&gt;&gt; cubes.append(216)  # add the cube of 6
&gt;&gt;&gt; cubes.append(7 ** 3)  # and the cube of 7
&gt;&gt;&gt; cubes
[1, 8, 27, 64, 125, 216, 343]

# 给切片赋值也是可以的，这样甚至可以改变列表大小，或者把列表整个清空:
&gt;&gt;&gt; letters = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]
&gt;&gt;&gt; letters
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]
&gt;&gt;&gt; # replace some values
&gt;&gt;&gt; letters[2:5] = [&#39;C&#39;, &#39;D&#39;, &#39;E&#39;]
&gt;&gt;&gt; letters
[&#39;a&#39;, &#39;b&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;f&#39;, &#39;g&#39;]
&gt;&gt;&gt; # now remove them
&gt;&gt;&gt; letters[2:5] = []
&gt;&gt;&gt; letters
[&#39;a&#39;, &#39;b&#39;, &#39;f&#39;, &#39;g&#39;]
&gt;&gt;&gt; # clear the list by replacing all the elements with an empty list
&gt;&gt;&gt; letters[:] = []
&gt;&gt;&gt; letters
[]

# 内置函数 len() 也可以作用到列表上:
&gt;&gt;&gt; letters = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
&gt;&gt;&gt; len(letters)
4

# 也可以嵌套列表 (创建包含其他列表的列表), 比如说:
&gt;&gt;&gt; a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; n = [1, 2, 3]
&gt;&gt;&gt; x = [a, n]
&gt;&gt;&gt; x
[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [1, 2, 3]]
&gt;&gt;&gt; x[0]
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; x[0][1]
&#39;b&#39;</code></pre>
      <pre><code class="language-sh"># insert ，remove 或者 sort 方法，只修改列表，没有打印出返回值
&gt;&gt;&gt; fruits = [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;]
&gt;&gt;&gt; fruits.count(&#39;apple&#39;)
2
&gt;&gt;&gt; fruits.count(&#39;tangerine&#39;)
0
&gt;&gt;&gt; fruits.index(&#39;banana&#39;)
3
&gt;&gt;&gt; fruits.index(&#39;banana&#39;, 4)  # Find next banana starting a position 4
6
&gt;&gt;&gt; fruits.reverse()
&gt;&gt;&gt; fruits
[&#39;banana&#39;, &#39;apple&#39;, &#39;kiwi&#39;, &#39;banana&#39;, &#39;pear&#39;, &#39;apple&#39;, &#39;orange&#39;]
&gt;&gt;&gt; fruits.append(&#39;grape&#39;)
&gt;&gt;&gt; fruits
[&#39;banana&#39;, &#39;apple&#39;, &#39;kiwi&#39;, &#39;banana&#39;, &#39;pear&#39;, &#39;apple&#39;, &#39;orange&#39;, &#39;grape&#39;]
&gt;&gt;&gt; fruits.sort()
&gt;&gt;&gt; fruits
[&#39;apple&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;grape&#39;, &#39;kiwi&#39;, &#39;orange&#39;, &#39;pear&#39;]
&gt;&gt;&gt; fruits.pop()
&#39;pear&#39;

# 列表作为栈使用
&gt;&gt;&gt; stack = [3, 4, 5]
&gt;&gt;&gt; stack.append(6)
&gt;&gt;&gt; stack.append(7)
&gt;&gt;&gt; stack
[3, 4, 5, 6, 7]
&gt;&gt;&gt; stack.pop()
7
&gt;&gt;&gt; stack
[3, 4, 5, 6]
&gt;&gt;&gt; stack.pop()
6
&gt;&gt;&gt; stack.pop()
5
&gt;&gt;&gt; stack
[3, 4]

# 列表作为队列使用
&gt;&gt;&gt; from collections import deque
&gt;&gt;&gt; queue = deque([&quot;Eric&quot;, &quot;John&quot;, &quot;Michael&quot;])
&gt;&gt;&gt; queue.append(&quot;Terry&quot;)           # Terry arrives
&gt;&gt;&gt; queue.append(&quot;Graham&quot;)          # Graham arrives
&gt;&gt;&gt; queue.popleft()                 # The first to arrive now leaves
&#39;Eric&#39;
&gt;&gt;&gt; queue.popleft()                 # The second to arrive now leaves
&#39;John&#39;
&gt;&gt;&gt; queue                           # Remaining queue in order of arrival
deque([&#39;Michael&#39;, &#39;Terry&#39;, &#39;Graham&#39;])

# del语句
&gt;&gt;&gt; a = [-1, 1, 66.25, 333, 333, 1234.5]
&gt;&gt;&gt; del a[0]
&gt;&gt;&gt; a
[1, 66.25, 333, 333, 1234.5]
&gt;&gt;&gt; del a[2:4]
&gt;&gt;&gt; a
[1, 66.25, 1234.5]
&gt;&gt;&gt; del a[:]
&gt;&gt;&gt; a
[]

# del 也可以被用来删除整个变量
&gt;&gt;&gt; del a</code></pre>
      <h4 id="列表查找">列表查找</h4>
      <p>dart</p>
      <pre><code class="language-dart">// 使用 indexOf() 来查找 list 中对象的索引
var fruits = [&#39;apples&#39;, &#39;oranges&#39;];
// Access a list item by index.
assert(fruits[0] == &#39;apples&#39;);
// Find an item in a list.
assert(fruits.indexOf(&#39;apples&#39;) == 0);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.indexOf(&#39;b&#39;) // 1
a.indexOf(&#39;y&#39;) // -1

// 2 is in the list
if ([1, 2, 3].includes(2)) {
  console.log(&#39;2 is in the list&#39;)
}

// 2 is not in the list
if (![4, 5, 6].includes(2)) {
  console.log(&#39;2 is not in the list&#39;)
}


const someList = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
// 2
console.log(someList.indexOf(&#39;c&#39;))


const originalList = [1, 2, 3]
const newList = [...originalList]
originalList[2] = 4
</code></pre>
      <p>python</p>
      <pre><code class="language-python"># 2 is in the list
if 2 in [1, 2, 3]:
    print(&quot;2 is in the list&quot;)

# 2 is not in the list
if 2 not in [4, 5, 6]:
    print(&quot;2 is not in the list&quot;)


some_list = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
# 2
print(some_list.index(&quot;c&quot;))</code></pre>
      <pre><code class="language-sh">&gt;&gt;&gt; squares = [1, 4, 9, 16, 25]
&gt;&gt;&gt; squares
[1, 4, 9, 16, 25]

# 列表也支持索引和切片:
&gt;&gt;&gt; squares[0]  # indexing returns the item
1

# insert ，remove 或者 sort 方法，只修改列表，没有打印出返回值
&gt;&gt;&gt; fruits = [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;]
&gt;&gt;&gt; fruits.index(&#39;banana&#39;)
3
&gt;&gt;&gt; fruits.index(&#39;banana&#39;, 4)  # Find next banana starting a position 4
6</code></pre>
      <h4 id="列表排序">列表排序</h4>
      <p>dart</p>
      <pre><code class="language-dart">// 排序
var fruits = [&#39;bananas&#39;, &#39;apples&#39;, &#39;oranges&#39;];
// Sort a list.
fruits.sort((a, b) =&gt; a.compareTo(b));
assert(fruits[0] == &#39;apples&#39;);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">// sort方法对数组成员进行排序，默认是按照字典顺序排序
// 排序后，原数组将被改变。
[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;].sort()
// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
[11, 101].sort()
// [101, 11]

[10111, 1101, 111].sort(function (a, b) {
  return a - b;
})
// [111, 1101, 10111]

[
  { name: &quot;张三&quot;, age: 30 },
  { name: &quot;李四&quot;, age: 24 },
  { name: &quot;王五&quot;, age: 28  }
].sort(function (o1, o2) {
  return o1.age - o2.age;
})
// [
//   { name: &quot;李四&quot;, age: 24 },
//   { name: &quot;王五&quot;, age: 28  },
//   { name: &quot;张三&quot;, age: 30 }
// ]


const someList = [1, 2, 3, 4]
someList.reverse()</code></pre>
      <p>python</p>
      <pre><code class="language-python">
some_list = [1, 2, 3, 4]
# reversed(some_list) is just an iterable.
# To convert an iterable into a list, use list()
reversed_list = list(reversed(some_list))
# 4
# 3
# 2
# 1
for item in reversed_list:
    print(item)
# You can use an iterable instead of a list in a for loop
# for item in reversed(some_list):</code></pre>
      <pre><code class="language-sh"># insert ，remove 或者 sort 方法，只修改列表，没有打印出返回值
&gt;&gt;&gt; fruits = [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;]
&gt;&gt;&gt; fruits.reverse()
&gt;&gt;&gt; fruits.sort()</code></pre>
      <h4 id="列表截取">列表截取</h4>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">// arr.slice(start, end);
var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.slice(0) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
a.slice(1) // [&quot;b&quot;, &quot;c&quot;]
a.slice(1, 2) // [&quot;b&quot;]
a.slice(2, 6) // [&quot;c&quot;]
a.slice() // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.slice(-2) // [&quot;b&quot;, &quot;c&quot;]
a.slice(-2, -1) // [&quot;b&quot;]

var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
a.slice(4) // []
a.slice(2, 1) // []

// arr.splice(start, count, addElement1, addElement2, ...);
var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;];
a.splice(4, 2) // [&quot;e&quot;, &quot;f&quot;]
a // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]


const someList = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
someList.splice(1, 1)
// a
// c
someList.forEach(element =&gt; {
  console.log(element)
})</code></pre>
      <p>python</p>
      <pre><code class="language-python">original_list = [1, 2, 3]
new_list = original_list[:]  # or original_list.copy()
original_list[2] = 4
# 1
# 2
# 3
for x in new_list:
    print(x)</code></pre>
      <pre><code class="language-sh">&gt;&gt;&gt; squares = [1, 4, 9, 16, 25]
&gt;&gt;&gt; squares
[1, 4, 9, 16, 25]

# 列表也支持索引和切片:
&gt;&gt;&gt; squares[0]  # indexing returns the item
1
&gt;&gt;&gt; squares[-1]
25
&gt;&gt;&gt; squares[-3:]  # slicing returns a new list
[9, 16, 25]

# 切片会返回列表的一个新的(浅)拷贝:
&gt;&gt;&gt; squares[:]
[1, 4, 9, 16, 25]

# del语句
&gt;&gt;&gt; a = [-1, 1, 66.25, 333, 333, 1234.5]
&gt;&gt;&gt; del a[0]
&gt;&gt;&gt; a
[1, 66.25, 333, 333, 1234.5]
&gt;&gt;&gt; del a[2:4]
&gt;&gt;&gt; a
[1, 66.25, 1234.5]
&gt;&gt;&gt; del a[:]
&gt;&gt;&gt; a
[]

# del 也可以被用来删除整个变量
&gt;&gt;&gt; del a</code></pre>
      <h4 id="列表推导式">列表推导式</h4>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">const originalList = [1, 2, 3]
// You can also do this:
// const newList = originalList.map(x =&gt; { return x * 2 })
const newList = originalList.map(x =&gt; x * 2)
// 2
// 4
// 6
newList.forEach(element =&gt; {
  console.log(element)
})


const firstList = [1, 3]
const secondList = [3, 4]
// const conbinedList = firstList.map(x =&gt; {
//   return secondList.map(y =&gt; {
//     return x + y
//   })
// })
const conbinedList = firstList.map(x =&gt; secondList.map(y =&gt; x + y))
// 4
console.log(conbinedList[0][0])
// 5
console.log(conbinedList[0][1])
// 6
console.log(conbinedList[1][0])
// 7
console.log(conbinedList[1][1])


const originalList = [1, 2, 3, 4, 5, 6]
const newList = originalList.filter(x =&gt; x % 2 == 0)
// 2
// 4
// 6
newList.forEach(element =&gt; {
  console.log(element)
})</code></pre>
      <p>python</p>
      <pre><code class="language-python">original_list = [1, 2, 3]
new_list = [x * 2 for x in original_list]
# 2
# 4
# 6
for x in new_list:
    print(x)


first_list = [1, 3]
second_list = [3, 4]
combined_list = [[x + y for y in second_list] for x in first_list]
# 4
print(combined_list[0][0])
# 5
print(combined_list[0][1])
# 6
print(combined_list[1][0])
# 7
print(combined_list[1][1])


original_list = [1, 2, 3, 4, 5, 6]
new_list = [x for x in original_list if x % 2 == 0]
# 2
# 4
# 6
for x in new_list:
    print(x)


squares = []
for x in range(10):
    squares.append(x**2)
# 等价于
squares = list(map(lambda x: x**2, range(10)))
# 或者，等价于
squares = [x**2 for x in range(10)]

[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
# 等价于
combs = []
for x in [1,2,3]:
    for y in [3,1,4]:
        if x != y:
            combs.append((x, y))</code></pre>
      <pre><code class="language-sh">&gt;&gt;&gt; vec = [-4, -2, 0, 2, 4]
&gt;&gt;&gt; # create a new list with the values doubled
&gt;&gt;&gt; [x*2 for x in vec]
[-8, -4, 0, 4, 8]
&gt;&gt;&gt; # filter the list to exclude negative numbers
&gt;&gt;&gt; [x for x in vec if x &gt;= 0]
[0, 2, 4]
&gt;&gt;&gt; # apply a function to all the elements
&gt;&gt;&gt; [abs(x) for x in vec]
[4, 2, 0, 2, 4]
&gt;&gt;&gt; # call a method on each element
&gt;&gt;&gt; freshfruit = [&#39;  banana&#39;, &#39;  loganberry &#39;, &#39;passion fruit  &#39;]
&gt;&gt;&gt; [weapon.strip() for weapon in freshfruit]
[&#39;banana&#39;, &#39;loganberry&#39;, &#39;passion fruit&#39;]
&gt;&gt;&gt; # create a list of 2-tuples like (number, square)
&gt;&gt;&gt; [(x, x**2) for x in range(6)]
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
&gt;&gt;&gt; # the tuple must be parenthesized, otherwise an error is raised
&gt;&gt;&gt; [x, x**2 for x in range(6)]
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    [x, x**2 for x in range(6)]
               ^
SyntaxError: invalid syntax
&gt;&gt;&gt; # flatten a list using a listcomp with two &#39;for&#39;
&gt;&gt;&gt; vec = [[1,2,3], [4,5,6], [7,8,9]]
&gt;&gt;&gt; [num for elem in vec for num in elem]
[1, 2, 3, 4, 5, 6, 7, 8, 9]

# 列表推导式可以使用复杂的表达式和嵌套函数
&gt;&gt;&gt; from math import pi
&gt;&gt;&gt; [str(round(pi, i)) for i in range(1, 6)]
[&#39;3.1&#39;, &#39;3.14&#39;, &#39;3.142&#39;, &#39;3.1416&#39;, &#39;3.14159&#39;]</code></pre>
      <pre><code class="language-python">matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
]
# 下面的列表推导式将交换其行和列
[[row[i] for row in matrix] for i in range(4)]
# [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
# 等价于
transposed = []
for i in range(4):
    transposed.append([row[i] for row in matrix])
# 也等价于
transposed = []
for i in range(4):
    # the following 3 lines implement the nested listcomp
    transposed_row = []
    for row in matrix:
        transposed_row.append(row[i])
    transposed.append(transposed_row)

# 实际应用中，你应该会更喜欢使用内置函数去组成复杂的流程语句。
# zip() 函数将会很好地处理这种情况
list(zip(*matrix))
# [(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]</code></pre>
      <h4 id="列表高阶函数">列表高阶函数</h4>
      <p>dart</p>
      <pre><code class="language-dart">// 使用 forEach() 函数可以对集合中的每个数据都应用 一个方法：
var teas = [&#39;green&#39;, &#39;black&#39;, &#39;chamomile&#39;, &#39;earl grey&#39;];
teas.forEach((tea) =&gt; print(&#39;I drink $tea&#39;));

// 在 Map 上使用 forEach() 的时候，方法需要能 接收两个参数（key 和 value）：
hawaiianBeaches.forEach((k, v) {
  print(&#39;I want to visit $k and swim at $v&#39;);
  // I want to visit Oahu and swim at
  // [Waikiki, Kailua, Waimanalo], etc.
});

// Iterables 也有一个 map() 函数，这个函数返回一个包含所有数据的对象：
var teas = [&#39;green&#39;, &#39;black&#39;, &#39;chamomile&#39;, &#39;earl grey&#39;];
var loudTeas = teas.map((tea) =&gt; tea.toUpperCase());
loudTeas.forEach(print);
// map() 函数返回的对象也是一个 Iterable，该对象是懒求值（lazily evaluated） 的，
// 只有当访问里面的值的时候， map 的方法才被调用。
// 可以使用 map().toList() 或者 map().toSet() 来 强制立刻执行 map 的方法：
var loudTeaList = teas
    .map((tea) =&gt; tea.toUpperCase())
    .toList();

// Iterable 的 where() 函数可以返回所有满足特定条件的数据。
// any() 判断是否有数据满足特定条件，
// every() 判断是否所有数据都满足 特定条件。

var teas = [&#39;green&#39;, &#39;black&#39;, &#39;chamomile&#39;, &#39;earl grey&#39;];

// Chamomile is not caffeinated.
bool isDecaffeinated(String teaName) =&gt;
    teaName == &#39;chamomile&#39;;

// Use where() to find only the items that return true
// from the provided function.
var decaffeinatedTeas = teas
    .where((tea) =&gt; isDecaffeinated(tea));
// or teas.where(isDecaffeinated)

// Use any() to check whether at least one item in the
// collection satisfies a condition.
assert(teas.any(isDecaffeinated));

// Use every() to check whether all the items in a
// collection satisfy a condition.
assert(!teas.every(isDecaffeinated));</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">var numbers = [1, 2, 3];
numbers.map(function (n) {
  return n + 1;
});
// [2, 3, 4]

function log(element, index, array) {
  console.log(&#39;[&#39; + index + &#39;] = &#39; + element);
}
[2, 5, 9].forEach(log);
// [0] = 2
// [1] = 5
// [2] = 9

var out = [];
[1, 2, 3].forEach(function(elem) {
  this.push(elem * elem);
}, out);
out // [1, 4, 9]

[1, 2, 3, 4, 5].filter(function (elem) {
  return (elem &gt; 3);
})
// [4, 5]

var arr = [0, 1, &#39;a&#39;, false];
arr.filter(Boolean)
// [1, &quot;a&quot;]

var arr = [1, 2, 3, 4, 5];
arr.some(function (elem, index, arr) {
  return elem &gt;= 3;
});
// true

var arr = [1, 2, 3, 4, 5];
arr.every(function (elem, index, arr) {
  return elem &gt;= 3;
});
// false

// 注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。
function isEven(x) { return x % 2 === 0 }
[].some(isEven) // false
[].every(isEven) // true

[1, 2, 3, 4, 5].reduce(function (a, b) {
  console.log(a, b);
  return a + b;
})
// 1 2
// 3 3
// 6 4
// 10 5
//最后结果：15

function subtract(prev, cur) {
  return prev - cur;
}
[3, 2, 1].reduce(subtract) // 0
[3, 2, 1].reduceRight(subtract) // -4</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="切片">切片</h3>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <p>
        每个数组的大小都是固定的。
        而切片则为数组元素提供动态大小的、灵活的视角。
        在实践中，切片比数组更常用。 类型 <code>[]T</code> 表示一个元素类型为 T
        的切片。
      </p>
      <p>
        <code>a[low : high]</code>
        它会选择一个半开区间，包括第一个元素，但排除最后一个元素。
      </p>
      <p><img src="images/slice.png" alt="切片与数组示意图" /></p>
      <pre><code class="language-go">// 以下表达式创建了一个切片，
// 它包含 a 中下标从 1 到 3 的元素：
package main
import &quot;fmt&quot;
func main() {
  primes := [6]int{2, 3, 5, 7, 11, 13}
  fmt.Println(primes)
  var s []int = primes[1:4]
  fmt.Println(s)
}
// [2 3 5 7 11 13]
// [3 5 7]


// 切片就像数组的引用
// - 切片并不存储任何数据，它只是描述了底层数组中的一段。
// - 更改切片的元素会修改其底层数组中对应的元素。
// - 与它共享底层数组的切片都会观测到这些修改。
package main
import &quot;fmt&quot;
func main() {
  names := [4]string{
    &quot;John&quot;,
    &quot;Paul&quot;,
    &quot;George&quot;,
    &quot;Ringo&quot;,
  }
  fmt.Println(names)
  a := names[0:2]
  b := names[1:3]
  fmt.Println(a, b)
  b[0] = &quot;XXX&quot;
  fmt.Println(a, b)
  fmt.Println(names)
}
// [John Paul George Ringo]
// [John Paul] [Paul George]
// [John XXX] [XXX George]
// [John XXX George Ringo]


// 这是一个数组文法：
[3]bool{true, true, false}

// 切片文法类似于没有长度的数组文法。
// 下面这样则会创建一个和上面相同的数组，
// 然后构建一个引用了它的切片：
[]bool{true, true, false}


package main
import &quot;fmt&quot;
func main() {
  q := []int{2, 3, 5, 7, 11, 13}
  fmt.Println(q)
  r := []bool{true, false, true, true, false, true}
  fmt.Println(r)
  s := []struct {
    i int
    b bool
  }{
    {2, true},
    {3, false},
    {5, true},
    {7, true},
    {11, false},
    {13, true},
  }
  fmt.Println(s)
}
// [2 3 5 7 11 13]
// [true false true true false true]
// [{2 true} {3 false} {5 true} {7 true} {11 false} {13 true}]


// 在进行切片时，你可以利用它的默认行为来忽略上下界。
// 切片下界的默认值为 0，上界则是该切片的长度。
var a [10]int
// 以下切片是等价的：
a[0:10]
a[:10]
a[0:]
a[:]

package main
import &quot;fmt&quot;
func main() {
  s := []int{2, 3, 5, 7, 11, 13}
  s = s[1:4]
  fmt.Println(s)
  s = s[:2]
  fmt.Println(s)
  s = s[1:]
  fmt.Println(s)
}
// [3 5 7]
// [3 5]
// [5]


// 切片拥有 长度 和 容量。
// 切片的长度就是它所包含的元素个数。
// 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。
// 切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。
// 你可以通过重新切片来扩展一个切片，给它提供足够的容量。
package main

import &quot;fmt&quot;

func main() {
  s := []int{2, 3, 5, 7, 11, 13}
  printSlice(s)

  // 截取切片使其长度为 0
  s = s[:0]
  printSlice(s)

  // 拓展其长度
  s = s[:4]
  printSlice(s)

  // 舍弃前两个值
  s = s[2:]
  printSlice(s)

  s = s[0:4]
  printSlice(s)

  s = s[0:6]
  printSlice(s)
}
func printSlice(s []int) {
  fmt.Printf(&quot;len=%d cap=%d %v\n&quot;, len(s), cap(s), s)
}
// len=6 cap=6 [2 3 5 7 11 13]
// len=0 cap=6 []
// len=4 cap=6 [2 3 5 7]
// len=2 cap=4 [5 7]
// len=4 cap=4 [5 7 11 13]
// panic: runtime error: slice bounds out of range


// 切片的零值是 nil。
// nil 切片的长度和容量为 0 且没有底层数组。
package main
import &quot;fmt&quot;
func main() {
  var s []int
  fmt.Println(s, len(s), cap(s))
  if s == nil {
    fmt.Println(&quot;nil!&quot;)
  }
}
// [] 0 0
// nil!


// 切片可以用内建函数 make 来创建，这也是你创建动态数组的方式。
// make 函数会分配一个元素为零值的数组并返回一个引用了它的切片：
// 要指定它的容量，需向 make 传入第三个参数：
package main
import &quot;fmt&quot;
func main() {
  a := make([]int, 5)
  printSlice(&quot;a&quot;, a)

  b := make([]int, 0, 5)
  printSlice(&quot;b&quot;, b)

  c := b[:2]
  printSlice(&quot;c&quot;, c)

  d := c[2:5]
  printSlice(&quot;d&quot;, d)
}
func printSlice(s string, x []int) {
  fmt.Printf(&quot;%s len=%d cap=%d %v\n&quot;,
    s, len(x), cap(x), x)
}
// a len=5 cap=5 [0 0 0 0 0]
// b len=0 cap=5 []
// c len=2 cap=5 [0 0]
// d len=3 cap=3 [0 0 0]


// 切片可包含任何类型，甚至包括其它的切片。
package main
import (
  &quot;fmt&quot;
  &quot;strings&quot;
)
func main() {
  // 创建一个井字板（经典游戏）
  board := [][]string{
    []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;},
    []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;},
    []string{&quot;_&quot;, &quot;_&quot;, &quot;_&quot;},
  }
  // 两个玩家轮流打上 X 和 O
  board[0][0] = &quot;X&quot;
  board[2][2] = &quot;O&quot;
  board[1][2] = &quot;X&quot;
  board[1][0] = &quot;O&quot;
  board[0][2] = &quot;X&quot;
  for i := 0; i &lt; len(board); i++ {
    fmt.Printf(&quot;%s\n&quot;, strings.Join(board[i], &quot; &quot;))
  }
}
// X _ X
// O _ X
// _ _ O


// 为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 append 函数。
// append 的结果是一个包含原切片所有元素加上新添加元素的切片。
// 当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。
// 返回的切片会指向这个新分配的数组。
package main
import &quot;fmt&quot;
func main() {
  var s []int
  printSlice(s)
  // 添加一个空切片
  s = append(s, 0)
  printSlice(s)
  // 这个切片会按需增长
  s = append(s, 1)
  printSlice(s)
  // 可以一次性添加多个元素
  s = append(s, 2, 3, 4)
  printSlice(s)
}
func printSlice(s []int) {
  fmt.Printf(&quot;len=%d cap=%d %v\n&quot;, len(s), cap(s), s)
}
// len=0 cap=0 []
// len=1 cap=2 [0]
// len=2 cap=2 [0 1]
// len=5 cap=8 [0 1 2 3 4]


// 实现 Pic。
// 它应当返回一个长度为 dy 的切片，
// 其中每个元素是一个长度为 dx，元素类型为 uint8 的切片。
// 当你运行此程序时，它会将每个整数解释为灰度值（好吧，其实是蓝度值）并显示它所对应的图像。
package main
import &quot;golang.org/x/tour/pic&quot;
//import &quot;fmt&quot;
func Pic(dx, dy int) [][]uint8 {
  //fmt.Println(dx, dy)
  qie := make([][]uint8, dy)
  // fmt.Println(qie)
  for i := 0; i &lt; dy; i++ {
    qie[i] = make([]uint8, dx)
    for j := 0; j &lt; dx; j++ {
      qie[i][j] = uint8(i-j)
    }
  }
  return qie
}
func main() {
  pic.Show(Pic)
}


// 将一个切片追加到另一个切片中
x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="元组">元组</h3>
      <p>tuple元组</p>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <p>
        一个元组由几个被逗号隔开的值组成。
        元组在输出时总是被圆括号包围的，以便正确表示嵌套元组。
        输入时圆括号可有可无，不过经常会是必须的。
        给元组中的一个单独的元素赋值是不允许的。
        当然你可以创建包含可变对象的元组，例如列表。
      </p>
      <ul>
        <li>
          元组是 immutable （不可变的），其序列通常包含不同种类的元素，
          并且通过解包（这一节下面会解释）或者索引来访问（如果是 namedtuples
          的话甚至还可以通过属性访问）。
        </li>
        <li>
          列表是 mutable
          （可变的），并且列表中的元素一般是同种类型的，并且通过迭代访问。
        </li>
      </ul>
      <p>
        空元组可以直接被一对空圆括号创建，
        含有一个元素的元组可以通过在这个元素后添加一个逗号来构建
      </p>
      <pre><code class="language-sh">&gt;&gt;&gt; empty = ()
&gt;&gt;&gt; singleton = &#39;hello&#39;,    # &lt;-- note trailing comma
&gt;&gt;&gt; len(empty)
0
&gt;&gt;&gt; len(singleton)
1
&gt;&gt;&gt; singleton
(&#39;hello&#39;,)
# 元组打包
t = 12345, 54321, &#39;hello!&#39;
# 逆操作
&gt;&gt;&gt; x, y, z = t</code></pre>
      <h3 id="字典">字典</h3>
      <p>Maps/dict(字典)</p>
      <p>dart</p>
      <pre><code class="language-dart">var gifts = {
  &#39;first&#39; : &#39;partridge&#39;,
  &#39;second&#39;: &#39;turtledoves&#39;,
  &#39;fifth&#39; : &#39;golden rings&#39;
};

var gifts = new Map();
gifts[&#39;first&#39;] = &#39;partridge&#39;;
gifts[&#39;second&#39;] = &#39;turtledoves&#39;;
gifts[&#39;fifth&#39;] = &#39;golden rings&#39;;

var gifts = {&#39;first&#39;: &#39;partridge&#39;};
gifts[&#39;fourth&#39;] = &#39;calling birds&#39;;

final constantMap = const {
  2: &#39;helium&#39;,
  10: &#39;neon&#39;,
  18: &#39;argon&#39;,
};

var pages = &lt;String, String&gt;{
  &#39;index.html&#39;: &#39;Homepage&#39;,
  &#39;robots.txt&#39;: &#39;Hints for web robots&#39;,
  &#39;humans.txt&#39;: &#39;We are people, not machines&#39;
};</code></pre>
      <p>go</p>
      <p>
        映射将键映射到值。 映射的零值为 nil 。nil 映射既没有键，也不能添加键。
        <code>make</code> 函数会返回给定类型的映射，并将其初始化备用。
      </p>
      <pre><code class="language-go">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化
var numbers map[string]int
// 另一种map的声明方式
numbers := make(map[string]int)
numbers[&quot;one&quot;] = 1  //赋值
numbers[&quot;ten&quot;] = 10 //赋值
numbers[&quot;three&quot;] = 3


package main
import &quot;fmt&quot;
type Vertex struct {
  Lat, Long float64
}
var m map[string]Vertex
func main() {
  m = make(map[string]Vertex)
  m[&quot;Bell Labs&quot;] = Vertex{
    40.68433, -74.39967,
  }
  fmt.Println(m[&quot;Bell Labs&quot;])
}
// {40.68433 -74.39967}


// 映射的文法与结构体相似，不过必须有键名。
package main
import &quot;fmt&quot;
type Vertex struct {
  Lat, Long float64
}
var m = map[string]Vertex{
  &quot;Bell Labs&quot;: Vertex{
    40.68433, -74.39967,
  },
  &quot;Google&quot;: Vertex{
    37.42202, -122.08408,
  },
}
func main() {
  fmt.Println(m)
}


// 若顶级类型只是一个类型名，你可以在文法的元素中省略它。
package main
import &quot;fmt&quot;
type Vertex struct {
  Lat, Long float64
}
var m = map[string]Vertex{
  &quot;Bell Labs&quot;: {40.68433, -74.39967},
  &quot;Google&quot;:    {37.42202, -122.08408},
}
func main() {
  fmt.Println(m)
}


// 修改映射
package main

import &quot;fmt&quot;

func main() {
  m := make(map[string]int)

  m[&quot;Answer&quot;] = 42 // 在映射 m 中插入或修改元素：
  fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;]) // 获取元素：

  m[&quot;Answer&quot;] = 48
  fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;])

  delete(m, &quot;Answer&quot;) // 删除元素：
  fmt.Println(&quot;The value:&quot;, m[&quot;Answer&quot;])

  // 通过双赋值检测某个键是否存在：
  // 若 key 在 m 中，ok 为 true ；否则，ok 为 false。
  // 若 key 不在映射中，那么 elem 是该映射元素类型的零值。
  // 同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。
  v, ok := m[&quot;Answer&quot;]
  fmt.Println(&quot;The value:&quot;, v, &quot;Present?&quot;, ok)
}
// The value: 42
// The value: 48
// The value: 0
// The value: 0 Present? false</code></pre>
      <p>js</p>
      <p>
        JavaScript 的对象（Object），本质上是键值对的集合（Hash
        结构），但是传统上只能用字符串当作键。
        WeakMap结构与Map结构类似，也是用于生成键值对的集合。
      </p>
      <ul>
        <li>
          WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
        </li>
        <li>WeakMap的键名所指向的对象，不计入垃圾回收机制。</li>
      </ul>
      <p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p>
      <ul>
        <li>keys()：返回键名的遍历器。</li>
        <li>values()：返回键值的遍历器。</li>
        <li>entries()：返回所有成员的遍历器。</li>
        <li>forEach()：遍历 Map 的所有成员。</li>
      </ul>
      <pre><code class="language-js">let { keys, values, entries } = Object;
let obj = { a: 1, b: 2, c: 3 };
for (let key of keys(obj)) {
  console.log(key); // &#39;a&#39;, &#39;b&#39;, &#39;c&#39;
}
for (let value of values(obj)) {
  console.log(value); // 1, 2, 3
}
for (let [key, value] of entries(obj)) {
  console.log([key, value]); // [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]
}

const m = new Map();
const o = {p: &#39;Hello World&#39;};
m.set(o, &#39;content&#39;)
m.get(o) // &quot;content&quot;
m.has(o) // true
m.delete(o) // true
m.has(o) // false

const map = new Map([
  [&#39;name&#39;, &#39;张三&#39;],
  [&#39;title&#39;, &#39;Author&#39;]
]);
map.size // 2
map.has(&#39;name&#39;) // true
map.get(&#39;name&#39;) // &quot;张三&quot;
map.has(&#39;title&#39;) // true
map.get(&#39;title&#39;) // &quot;Author&quot;

const map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);
map.size // 2

const m = new Map();
m.set(undefined, &#39;nah&#39;);
m.has(undefined)     // true
m.delete(undefined)
m.has(undefined)       // false

let map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);
map.size // 2
map.clear()
map.size // 0


const map = new Map([
  [&#39;F&#39;, &#39;no&#39;],
  [&#39;T&#39;,  &#39;yes&#39;],
]);

for (let key of map.keys()) {
  console.log(key);
}
// &quot;F&quot;
// &quot;T&quot;

for (let value of map.values()) {
  console.log(value);
}
// &quot;no&quot;
// &quot;yes&quot;

for (let item of map.entries()) {
  console.log(item[0], item[1]);
}
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

// 或者
for (let [key, value] of map.entries()) {
  console.log(key, value);
}
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

// 等同于使用map.entries()
for (let [key, value] of map) {
  console.log(key, value);
}
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;


const someVariable = 2
const someDict = { [someVariable + 1]: &#39;three&#39; }
// three
console.log(someDict[3])</code></pre>
      <p>python</p>
      <pre><code class="language-sh">&gt;&gt;&gt; tel = {&#39;jack&#39;: 4098, &#39;sape&#39;: 4139}
&gt;&gt;&gt; tel[&#39;guido&#39;] = 4127
&gt;&gt;&gt; tel
{&#39;jack&#39;: 4098, &#39;sape&#39;: 4139, &#39;guido&#39;: 4127}
&gt;&gt;&gt; tel[&#39;jack&#39;]
4098
&gt;&gt;&gt; del tel[&#39;sape&#39;]
&gt;&gt;&gt; tel[&#39;irv&#39;] = 4127
&gt;&gt;&gt; tel
{&#39;jack&#39;: 4098, &#39;guido&#39;: 4127, &#39;irv&#39;: 4127}
&gt;&gt;&gt; list(tel)
[&#39;jack&#39;, &#39;guido&#39;, &#39;irv&#39;]
&gt;&gt;&gt; sorted(tel)
[&#39;guido&#39;, &#39;irv&#39;, &#39;jack&#39;]
&gt;&gt;&gt; &#39;guido&#39; in tel
True
&gt;&gt;&gt; &#39;jack&#39; not in tel
False

# dict() 构造函数可以直接从键值对序列里创建字典。
&gt;&gt;&gt; dict([(&#39;sape&#39;, 4139), (&#39;guido&#39;, 4127), (&#39;jack&#39;, 4098)])
{&#39;sape&#39;: 4139, &#39;guido&#39;: 4127, &#39;jack&#39;: 4098}

# 字典推导式可以从任意的键值表达式中创建字典
&gt;&gt;&gt; {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}

# 当关键字是简单字符串时，有时直接通过关键字参数来指定键值对更方便
&gt;&gt;&gt; dict(sape=4139, guido=4127, jack=4098)
{&#39;sape&#39;: 4139, &#39;guido&#39;: 4127, &#39;jack&#39;: 4098}


some_variable = 2
some_dict = {(some_variable + 1): &quot;three&quot;}
# three
print(some_dict[3])</code></pre>
      <h4 id="字典删除">字典删除</h4>
      <p>从 map 中删除 key 和 value</p>
      <p>dart</p>
      <pre><code class="language-dart">// 使用中括号来访问或者设置 map 中的数据，
// 使用 remove() 函数来从 map 中删除 key 和 value。
var nobleGases = {54: &#39;xenon&#39;};
// Retrieve a value with a key.
assert(nobleGases[54] == &#39;xenon&#39;);
// Check whether a map contains a key.
assert(nobleGases.containsKey(54));
// Remove a key and its value.
nobleGases.remove(54);
assert(!nobleGases.containsKey(54));</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">const m = new Map();
m.set(undefined, &#39;nah&#39;);
m.has(undefined)     // true
m.delete(undefined)
m.has(undefined)       // false


var obj = Object.defineProperties({}, {
  p1: { value: 1, configurable: true },
  p2: { value: 2, configurable: false }
});
delete obj.p1 // true
delete obj.p2 // false
obj.p1 // undefined
obj.p2 // 2</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h4 id="字典遍历">字典遍历</h4>
      <p>Maps(字典)遍历，获取 map 的所有 key 和 value</p>
      <p>dart</p>
      <pre><code class="language-dart">// 使用 .length 来获取 map 中键值对的数目
var gifts = {&#39;first&#39;: &#39;partridge&#39;};
gifts[&#39;fourth&#39;] = &#39;calling birds&#39;;
assert(gifts.length == 2);

var hawaiianBeaches = {
  &#39;Oahu&#39;      : [&#39;Waikiki&#39;, &#39;Kailua&#39;, &#39;Waimanalo&#39;],
  &#39;Big Island&#39;: [&#39;Wailea Bay&#39;, &#39;Pololu Beach&#39;],
  &#39;Kauai&#39;     : [&#39;Hanalei&#39;, &#39;Poipu&#39;]
};

// Get all the keys as an unordered collection
// (an Iterable).
var keys = hawaiianBeaches.keys;

assert(keys.length == 3);
assert(new Set.from(keys).contains(&#39;Oahu&#39;));

// Get all the values as an unordered collection
// (an Iterable of Lists).
var values = hawaiianBeaches.values;
assert(values.length == 3);
assert(values.any((v) =&gt; v.contains(&#39;Waikiki&#39;)));</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">// for...in循环
// 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
// 它不仅遍历对象自身的属性，还遍历继承的属性。
var obj = {a: 1, b: 2, c: 3};
for (var i in obj) {
  console.log(&#39;键名：&#39;, i);
  console.log(&#39;键值：&#39;, obj[i]);
}


// 获取 map 中键值对的数目
Object.keys(obj).length
Object.values(obj)
Object.entries(obj)

var engines = new Set([&quot;Gecko&quot;, &quot;Trident&quot;, &quot;Webkit&quot;, &quot;Webkit&quot;]);
for (var e of engines) {
  console.log(e);
}

var es6 = new Map();
es6.set(&quot;edition&quot;, 6);
es6.set(&quot;committee&quot;, &quot;TC39&quot;);
es6.set(&quot;standard&quot;, &quot;ECMA-262&quot;);
for (var [name, value] of es6) {
  console.log(name + &quot;: &quot; + value);
}

const someList = [6, 3, 5]
// 0 6
// 1 3
// 2 5
someList.forEach((element, index) =&gt; {
  console.log(`${index} ${element}`)
})


const list1 = [1, 3, 5]
const list2 = [2, 4, 6]
// [[1, 2], [3, 4], [5, 6]]
const zippedList = list1.map((x, y) =&gt; {
  return [x, list2[y]]
})
zippedList.forEach(element =&gt; {
  console.log(`${element[0]} ${element[1]}`)
})</code></pre>
      <p>python</p>
      <p>循环的技巧</p>
      <pre><code class="language-python">some_list = [6, 3, 5]
# 0 6
# 1 3
# 2 5
for i, item in enumerate(some_list):
    print(f&quot;{i} {item}&quot;)
# If you&#39;re not using this in a for loop, use list()
# list(enumerate(some_list)) # [(0, 6), (1, 3), (2, 5)]


list_1 = [1, 3, 5]
list_2 = [2, 4, 6]
# 1 2
# 3 4
# 5 6
for x, y in zip(list_1, list_2):
    print(f&quot;{x} {y}&quot;)</code></pre>
      <pre><code class="language-sh"># 当在字典中循环时，用 items() 方法可将关键字和对应的值同时取出
&gt;&gt;&gt; knights = {&#39;gallahad&#39;: &#39;the pure&#39;, &#39;robin&#39;: &#39;the brave&#39;}
&gt;&gt;&gt; for k, v in knights.items():
...     print(k, v)
...
gallahad the pure
robin the brave

# 当在序列中循环时，用 enumerate() 函数可以将索引位置和其对应的值同时取出
&gt;&gt;&gt; for i, v in enumerate([&#39;tic&#39;, &#39;tac&#39;, &#39;toe&#39;]):
...     print(i, v)
...
0 tic
1 tac
2 toe

# 当同时在两个或更多序列中循环时，可以用 zip() 函数将其内元素一一匹配。
&gt;&gt;&gt; questions = [&#39;name&#39;, &#39;quest&#39;, &#39;favorite color&#39;]
&gt;&gt;&gt; answers = [&#39;lancelot&#39;, &#39;the holy grail&#39;, &#39;blue&#39;]
&gt;&gt;&gt; for q, a in zip(questions, answers):
...     print(&#39;What is your {0}?  It is {1}.&#39;.format(q, a))
...
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.

# 当逆向循环一个序列时，先正向定位序列，然后调用 reversed() 函数
&gt;&gt;&gt; for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1

# 用 sorted() 函数，它可以在不改动原序列的基础上返回一个新的排好序的序列
&gt;&gt;&gt; basket = [&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;]
&gt;&gt;&gt; for f in sorted(set(basket)):
...     print(f)
...
apple
banana
orange
pear

# 有时可能会想在循环时修改列表内容，一般来说改为创建一个新列表是比较简单且安全的
&gt;&gt;&gt; import math
&gt;&gt;&gt; raw_data = [56.2, float(&#39;NaN&#39;), 51.7, 55.3, 52.5, float(&#39;NaN&#39;), 47.8]
&gt;&gt;&gt; filtered_data = []
&gt;&gt;&gt; for value in raw_data:
...     if not math.isnan(value):
...         filtered_data.append(value)
...
&gt;&gt;&gt; filtered_data
[56.2, 51.7, 55.3, 52.5, 47.8]</code></pre>
      <h4 id="字典判断">字典判断</h4>
      <p>判断 map 是否包含一个 key</p>
      <p>dart</p>
      <pre><code class="language-dart">// 由于 map 的 value 可以为 null，
// 所有通过 key 来获取 value 并通过 判断 value 是否为 null 来判断 key 是否存在是 行不通的。
var hawaiianBeaches = {
  &#39;Oahu&#39;      : [&#39;Waikiki&#39;, &#39;Kailua&#39;, &#39;Waimanalo&#39;],
  &#39;Big Island&#39;: [&#39;Wailea Bay&#39;, &#39;Pololu Beach&#39;],
  &#39;Kauai&#39;     : [&#39;Hanalei&#39;, &#39;Poipu&#39;]
};

assert(hawaiianBeaches.containsKey(&#39;Oahu&#39;));
assert(!hawaiianBeaches.containsKey(&#39;Florida&#39;));</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">// in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。
var obj = { p: 1 };
&#39;p&#39; in obj // true
&#39;toString&#39; in obj // true


const m = new Map();
m.set(&#39;edition&#39;, 6);
m.set(262, &#39;standard&#39;);
m.set(undefined, &#39;nah&#39;);
m.has(&#39;edition&#39;)     // true
m.has(&#39;years&#39;)       // false
m.has(262)           // true
m.has(undefined)     // true</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="集合">集合</h3>
      <p>Set 集合定义及操作</p>
      <p>dart</p>
      <pre><code class="language-dart">var ingredients = new Set();
ingredients.addAll([&#39;gold&#39;, &#39;titanium&#39;, &#39;xenon&#39;]);
assert(ingredients.length == 3);
// Adding a duplicate item has no effect.
ingredients.add(&#39;gold&#39;);
assert(ingredients.length == 3);
// Remove an item from a set.
ingredients.remove(&#39;gold&#39;);
assert(ingredients.length == 2);

var ingredients = new Set();
ingredients.addAll([&#39;gold&#39;, &#39;titanium&#39;, &#39;xenon&#39;]);
// Check whether an item is in the set.
assert(ingredients.contains(&#39;titanium&#39;));
// Check whether all the items are in the set.
assert(ingredients.containsAll([&#39;titanium&#39;, &#39;xenon&#39;]));

// 交际是两个 set 中都有的数据的子集：
var ingredients = new Set();
ingredients.addAll([&#39;gold&#39;, &#39;titanium&#39;, &#39;xenon&#39;]);
// Create the intersection of two sets.
var nobleGases = new Set.from([&#39;xenon&#39;, &#39;argon&#39;]);
var intersection = ingredients.intersection(nobleGases);
assert(intersection.length == 1);
assert(intersection.contains(&#39;xenon&#39;));</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">const s = new Set();
[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));
for (let i of s) {
  console.log(i);
}
// 2 3 5 4

// 例一
const set = new Set([1, 2, 3, 4, 4]);
[...set]
// [1, 2, 3, 4]

// 例二
const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 5

// 例三
const set = new Set(document.querySelectorAll(&#39;div&#39;));
set.size // 56

// 去除数组的重复成员
[...new Set(array)]

// 去除字符串里面的重复字符。
[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)
// &quot;abc&quot;

// 两个对象总是不相等的。
let set = new Set();
set.add({});
set.size // 1
set.add({});
set.size // 2


s.add(1).add(2).add(2);
// 注意2被加入了两次

s.size // 2

s.has(1) // true
s.has(2) // true
s.has(3) // false

s.delete(2);
s.has(2) // false


let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);

for (let item of set.keys()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.values()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.entries()) {
  console.log(item);
}
// [&quot;red&quot;, &quot;red&quot;]
// [&quot;green&quot;, &quot;green&quot;]
// [&quot;blue&quot;, &quot;blue&quot;]</code></pre>
      <p>python</p>
      <p>
        花括号或 set() 函数可以用来创建集合。 注意：要创建一个空集合你只能用
        set() 而不能用 {}， 因为后者是创建一个空字典
      </p>
      <pre><code class="language-sh">&gt;&gt;&gt; basket = {&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;}
&gt;&gt;&gt; print(basket)                      # show that duplicates have been removed
{&#39;orange&#39;, &#39;banana&#39;, &#39;pear&#39;, &#39;apple&#39;}
&gt;&gt;&gt; &#39;orange&#39; in basket                 # fast membership testing
True
&gt;&gt;&gt; &#39;crabgrass&#39; in basket
False

&gt;&gt;&gt; # Demonstrate set operations on unique letters from two words
...
&gt;&gt;&gt; a = set(&#39;abracadabra&#39;)
&gt;&gt;&gt; b = set(&#39;alacazam&#39;)
&gt;&gt;&gt; a                                  # unique letters in a
{&#39;a&#39;, &#39;r&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;}
&gt;&gt;&gt; a - b                              # letters in a but not in b
{&#39;r&#39;, &#39;d&#39;, &#39;b&#39;}
&gt;&gt;&gt; a | b                              # letters in a or b or both
{&#39;a&#39;, &#39;c&#39;, &#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;}
&gt;&gt;&gt; a &amp; b                              # letters in both a and b
{&#39;a&#39;, &#39;c&#39;}
&gt;&gt;&gt; a ^ b                              # letters in a or b but not both
{&#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;}

# 类似于 列表推导式，集合也支持推导式形式
&gt;&gt;&gt; a = {x for x in &#39;abracadabra&#39; if x not in &#39;abc&#39;}
&gt;&gt;&gt; a
{&#39;r&#39;, &#39;d&#39;}</code></pre>
      <h4 id="判断集合是否为空">判断集合是否为空</h4>
      <p>判断Iterable集合（List, Set, 和 Map）是否为空的</p>
      <p>dart</p>
      <pre><code class="language-dart">// 可以使用 isEmpty 函数来判断集合是否为空的：
if (lunchBox.isEmpty) return &#39;so hungry...&#39;;
if (words.isNotEmpty) return words.join(&#39; &#39;);
var teas = [&#39;green&#39;, &#39;black&#39;, &#39;chamomile&#39;, &#39;earl grey&#39;];
assert(!teas.isEmpty);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h4 id="集合的比较">集合的比较</h4>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python">(1, 2, 3)              &lt; (1, 2, 4)
[1, 2, 3]              &lt; [1, 2, 4]
&#39;ABC&#39; &lt; &#39;C&#39; &lt; &#39;Pascal&#39; &lt; &#39;Python&#39;
(1, 2, 3, 4)           &lt; (1, 2, 4)
(1, 2)                 &lt; (1, 2, -1)
(1, 2, 3)             == (1.0, 2.0, 3.0)
(1, 2, (&#39;aa&#39;, &#39;ab&#39;))   &lt; (1, 2, (&#39;abc&#39;, &#39;a&#39;), 4)</code></pre>
      <h3 id="指针">指针</h3>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <p>
        Go 拥有指针。指针保存了值的内存地址。 类型 <code>*T</code> 是指向 T
        类型值的指针。其零值为 <code>nil</code>。 与 C 不同，Go 没有指针运算。
      </p>
      <ul>
        <li><code>&amp;</code> 操作符会生成一个指向其操作数的指针。</li>
        <li><code>*</code> 操作符表示指针指向的底层值。</li>
      </ul>
      <pre><code class="language-go">// 类型 *T 是指向 T 类型值的指针。其零值为 nil。
var p *int


package main
import &quot;fmt&quot;
func main() {
  i, j := 42, 2701

  p := &amp;i         // 指向 i
  fmt.Println(*p) // 通过指针读取 i 的值
  *p = 21         // 通过指针设置 i 的值
  fmt.Println(i)  // 查看 i 的值

  p = &amp;j         // 指向 j
  *p = *p / 37   // 通过指针对 j 进行除法运算
  fmt.Println(j) // 查看 j 的值
}
// 42
// 21
// 73</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="结构体">结构体</h3>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <p>一个结构体（struct）就是一组字段（field）。</p>
      <pre><code class="language-go">package main
import &quot;fmt&quot;
type Vertex struct {
  X int
  Y int
}
func main() {
  fmt.Println(Vertex{1, 2})
}

// 结构体字段使用点号来访问。
package main
import &quot;fmt&quot;
type Vertex struct {
  X int
  Y int
}
func main() {
  v := Vertex{1, 2}
  v.X = 4
  fmt.Println(v.X)
}


// 如果我们有一个指向结构体的指针 p，
// 那么可以通过 (*p).X 来访问其字段 X。
//不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，
//直接写 p.X 就可以。
package main
import &quot;fmt&quot;
type Vertex struct {
  X int
  Y int
}
func main() {
  v := Vertex{1, 2}
  p := &amp;v
  // var p int = &amp;v
  fmt.Println(p)
  fmt.Println(*p)
  p.X = 3
  // (*p).X = 3
  fmt.Println(v)
}
// &amp;{1 2}
// {1 2}
// {3 2}


// 仅列出部分字段。（字段名的顺序无关。）
package main
import &quot;fmt&quot;
type Vertex struct {
  X, Y int
}
var (
  v1 = Vertex{1, 2}  // 创建一个 Vertex 类型的结构体
  v2 = Vertex{X: 1}  // Y:0 被隐式地赋予
  v3 = Vertex{}      // X:0 Y:0
  p  = &amp;Vertex{1, 2} // 创建一个 *Vertex 类型的结构体（指针）
)
func main() {
  fmt.Println(v1, p, v2, v3)
}
// {1 2} &amp;{1 2} {1 0} {0 0}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="信道">信道</h3>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <p>
        信道是带有类型的管道，你可以通过它用信道操作符
        <code>&lt;-</code> 来发送或者接收值。
      </p>
      <pre><code class="language-go">ch &lt;- v    // 将 v 发送至信道 ch。
v := &lt;-ch  // 从 ch 接收值并赋予 v。
ch := make(chan int) // 和映射与切片一样，信道在使用前必须创建：


package main
import &quot;fmt&quot;
func sum(s []int, c chan int) {
  sum := 0
  for _, v := range s {
    sum += v
  }
  c &lt;- sum // 将和送入 c
}
func main() {
  s := []int{7, 2, 8, -9, 4, 0}
  c := make(chan int)
  go sum(s[:len(s)/2], c)
  go sum(s[len(s)/2:], c)
  x, y := &lt;-c, &lt;-c // 从 c 中接收
  fmt.Println(x, y, x+y)
}
// -5 17 12


// 将缓冲长度作为第二个参数提供给 make 来初始化一个带缓冲的信道：
// 仅当信道的缓冲区填满后，向其发送数据时才会阻塞。
// 当缓冲区为空时，接受方会阻塞。
package main
import &quot;fmt&quot;
func main() {
  ch := make(chan int, 2)
  ch &lt;- 1
  ch &lt;- 2
  fmt.Println(&lt;-ch)
  fmt.Println(&lt;-ch)
}


// 发送者可通过 close 关闭一个信道来表示没有需要发送的值了。
// 若没有值可以接收且信道已被关闭
// v, ok := &lt;-ch
// ok 会被设置为 false。

// 循环 for i := range c 会不断从信道接收值，直到它被关闭。
// *注意：* 只有发送者才能关闭信道，而接收者不能。
package main
import (
  &quot;fmt&quot;
)
func fibonacci(n int, c chan int) {
  x, y := 0, 1
  for i := 0; i &lt; n; i++ {
    c &lt;- x
    x, y = y, x+y
  }
  close(c) // 关闭信道
}
func main() {
  c := make(chan int, 10)
  go fibonacci(cap(c), c)
  for i := range c { // 循环信道
    fmt.Println(i)
  }
}
// 0
// 1
// 1
// 2
// 3
// 5
// 8
// 13
// 21
// 34




// 练习：Web 爬虫
package main
import (
  &quot;fmt&quot;
)
// 定义接口
type Fetcher interface {
  // Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。
  Fetch(url string) (body string, urls []string, err error)
}
// fakeFetcher 是返回若干结果的 Fetcher。
type fakeFetcher map[string]*fakeResult
type fakeResult struct {
  body string
  urls []string
}
// 实现接口方法
func (f fakeFetcher) Fetch(url string) (string, []string, error) {
  if res, ok := f[url]; ok {
    return res.body, res.urls, nil
  }
  return &quot;&quot;, nil, fmt.Errorf(&quot;not found: %s&quot;, url)
}
// fetcher 是填充后的 fakeFetcher。
var fetcher = fakeFetcher{
  &quot;https://golang.org/&quot;: &amp;fakeResult{
    &quot;The Go Programming Language&quot;,
    []string{
      &quot;https://golang.org/pkg/&quot;,
      &quot;https://golang.org/cmd/&quot;,
    },
  },
  &quot;https://golang.org/pkg/&quot;: &amp;fakeResult{
    &quot;Packages&quot;,
    []string{
      &quot;https://golang.org/&quot;,
      &quot;https://golang.org/cmd/&quot;,
      &quot;https://golang.org/pkg/fmt/&quot;,
      &quot;https://golang.org/pkg/os/&quot;,
    },
  },
  &quot;https://golang.org/pkg/fmt/&quot;: &amp;fakeResult{
    &quot;Package fmt&quot;,
    []string{
      &quot;https://golang.org/&quot;,
      &quot;https://golang.org/pkg/&quot;,
    },
  },
  &quot;https://golang.org/pkg/os/&quot;: &amp;fakeResult{
    &quot;Package os&quot;,
    []string{
      &quot;https://golang.org/&quot;,
      &quot;https://golang.org/pkg/&quot;,
    },
  },
}
// Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。
func Crawl(url string, depth int, fetcher Fetcher) {
  // TODO: 并行的抓取 URL。
  // TODO: 不重复抓取页面。
        // 下面并没有实现上面两种情况：
  if depth &lt;= 0 {
    return
  }
  body, urls, err := fetcher.Fetch(url)
  if err != nil {
    fmt.Println(err)
    return
  }
  fmt.Printf(&quot;found: %s %q\n&quot;, url, body)
  for _, u := range urls {
    Crawl(u, depth-1, fetcher)
  }
  return
}
func main() {
  Crawl(&quot;https://golang.org/&quot;, 4, fetcher)
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h4 id="select语句">select语句</h4>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <p>
        select 语句使一个 Go 程可以等待多个通信操作。 select
        会阻塞到某个分支可以继续执行为止，这时就会执行该分支。
        当多个分支都准备好时会随机选择一个执行。
      </p>
      <pre><code class="language-go">package main
import &quot;fmt&quot;
func fibonacci(c, quit chan int) {
  x, y := 0, 1
  for {
    select {
      case c &lt;- x:
        x, y = y, x+y
      case &lt;-quit:
        fmt.Println(&quot;quit&quot;)
        return
    }
  }
}
func main() {
  c := make(chan int)
  quit := make(chan int)
  go func() {
    for i := 0; i &lt; 10; i++ {
      fmt.Println(&lt;-c)
    }
    quit &lt;- 0
  }() // 立即执行函数
  fibonacci(c, quit)
}


// 当 select 中的其它分支都没有准备好时，default 分支就会执行。
package main
import (
  &quot;fmt&quot;
  &quot;time&quot;
)
func main() {
  tick := time.Tick(100 * time.Millisecond)
  boom := time.After(500 * time.Millisecond)
  for {
    select {
    case &lt;-tick:
      fmt.Println(&quot;tick.&quot;)
    case &lt;-boom:
      fmt.Println(&quot;BOOM!&quot;)
      return
    default:
      fmt.Println(&quot;    .&quot;)
      time.Sleep(50 * time.Millisecond)
    }
  }
}


// 练习：等价二叉查找树
// 函数 tree.New(k) 用于构造一个随机结构的已排序二叉查找树，
// 它保存了值 k, 2k, 3k, ..., 10k
package main
import (
  &quot;fmt&quot;
  &quot;sort&quot;
  &quot;golang.org/x/tour/tree&quot;
)
func walk(t *tree.Tree, ch chan int) {
  if t == nil {
    return
  }
  walk(t.Left, ch)
  ch &lt;- t.Value
  walk(t.Right, ch)
}
// Walk 遍历 tree t 将所有的值从 tree 发送到 channel ch。
func Walk(t *tree.Tree, ch chan int) {
  walk(t, ch)
  close(ch)
}
// Same 检测树 t1 和 t2 是否含有相同的值。
func Same(t1, t2 *tree.Tree) bool {
  ch1 := make(chan int)
  ch2 := make(chan int)
  a1 := make([]int, 0)
  a2 := make([]int, 0)
  go Walk(t1, ch1)
  go Walk(t2, ch2)
  for v := range ch1 {
    a1 = append(a1, v)
  }
  for v := range ch2 {
    a2 = append(a2, v)
  }
  if len(a1) != len(a2) {
    return false
  }
  // 是否应当Sort？
  // 题目要求的是：检测 t1 和 t2 是否存储了相同的值
  sort.Ints(a1)
  sort.Ints(a2)
  for i, v := range a1 {
    if v != a2[i] {
      return false
    }
  }
  return true
}
func main() {
  // Test Walk
  ch := make(chan int)
  t := tree.New(1)
  fmt.Println(&quot;tree:&quot;, t)
  go Walk(t, ch)
  for v := range ch {
    fmt.Println(&quot;Got value:&quot;, v)
  }
  // Test Same
  t2 := tree.New(1)

  fmt.Println(&quot;Check same:&quot;, Same(t, t2))
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h4 id="互斥锁">互斥锁</h4>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <ul>
        <li>
          若我们只是想保证每次只有一个 Go
          程能够访问一个共享的变量，从而避免冲突？
        </li>
        <li>
          我们通常使用 <em>互斥锁（Mutex）</em> 这一数据结构来提供这种机制。
        </li>
        <li>
          我们可以通过在代码前调用 Lock 方法，在代码后调用 Unlock
          方法来保证一段代码的互斥执行。
        </li>
        <li>我们也可以用 defer 语句来保证互斥锁一定会被解锁</li>
      </ul>
      <pre><code class="language-go">package main
import (
  &quot;fmt&quot;
  &quot;sync&quot;
  &quot;time&quot;
)
// SafeCounter 的并发使用是安全的。
type SafeCounter struct {
  v   map[string]int
  mux sync.Mutex
}
// Inc 增加给定 key 的计数器的值。
func (c *SafeCounter) Inc(key string) {
  c.mux.Lock()
  // Lock 之后同一时刻只有一个 goroutine 能访问 c.v
  c.v[key]++
  c.mux.Unlock()
}
// Value 返回给定 key 的计数器的当前值。
func (c *SafeCounter) Value(key string) int {
  c.mux.Lock()
  // Lock 之后同一时刻只有一个 goroutine 能访问 c.v
  defer c.mux.Unlock()
  return c.v[key]
}
func main() {
  c := SafeCounter{v: make(map[string]int)}
  for i := 0; i &lt; 1000; i++ {
    go c.Inc(&quot;somekey&quot;)
  }
  time.Sleep(time.Second)
  fmt.Println(c.Value(&quot;somekey&quot;))
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="类型转换">类型转换</h2>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <p>表达式 <code>T(v)</code> 将值 v 转换为类型 T。</p>
      <p>Go 在不同类型的项之间赋值时需要显式转换。</p>
      <pre><code class="language-go">var i int = 42
var f float64 = float64(i)
var u uint = uint(f)

// 或者，更加简单的形式：
i := 42
f := float64(i)
u := uint(f)</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <h3 id="数值转字符串">数值转字符串</h3>
      <p>dart</p>
      <pre><code class="language-dart">// Convert an int to a string.
assert(42.toString() == &#39;42&#39;);
// Convert a double to a string.
assert(123.456.toString() == &#39;123.456&#39;);
// Specify the number of digits after the decimal.
assert(123.456.toStringAsFixed(2) == &#39;123.46&#39;);
// Specify the number of significant figures.
assert(123.456.toStringAsPrecision(2) == &#39;1.2e+2&#39;);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="字符串转数值">字符串转数值</h3>
      <p>dart</p>
      <pre><code class="language-dart">assert(int.parse(&#39;42&#39;) == 42);
assert(int.parse(&#39;0x42&#39;) == 66);
assert(double.parse(&#39;0.50&#39;) == 0.5);

assert(num.parse(&#39;42&#39;) is int);
assert(num.parse(&#39;0x42&#39;) is int);
assert(num.parse(&#39;0.50&#39;) is double);

assert(int.parse(&#39;42&#39;, radix: 16) == 66);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">parseInt(&#39;v8&#39;,32) // 1000

const string1 = &#39;1&#39;
const number1 = parseInt(string1)</code></pre>
      <p>python</p>
      <pre><code class="language-python">string_1 = &quot;1&quot;
number_1 = int(string_1)
# 3
print(number_1 + 2)</code></pre>
    </div>
    <script src="./highlight/highlight.pack.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>
