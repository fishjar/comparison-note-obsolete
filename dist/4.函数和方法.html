<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>4.函数和方法.md</title>
    <link rel="stylesheet" href="./styles.css" />
    <link rel="stylesheet" href="./highlight/styles/github.css" />
  </head>
  <body>
    <div id="nav">
      <ul>
        <li>
          <a href="#%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95"
            >函数和方法</a
          >
          <ul>
            <li>
              <a
                href="#Functions%EF%BC%88%E6%96%B9%E6%B3%95%EF%BC%89%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"
                >Functions（方法）函数定义</a
              >
            </li>
            <li>
              [Optional named parameters（可选命名参数）](#Optional named
              parameters（可选命名参数）)
            </li>
            <li>
              [Optional positional parameters（可选位置参数）](#Optional
              positional parameters（可选位置参数）)
            </li>
            <li>
              [Default parameter values（默认参数值）](#Default parameter
              values（默认参数值）)
            </li>
            <li>
              <a href="#%E8%A7%A3%E5%8C%85%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"
                >解包参数列表</a
              >
            </li>
            <li>
              [The main() function（入口函数）](#The main()
              function（入口函数）)
            </li>
            <li>
              [Functions as first-class objects（一等方法对象）](#Functions as
              first-class objects（一等方法对象）)
            </li>
            <li>
              [Anonymous functions（匿名方法）匿名函数](#Anonymous
              functions（匿名方法）匿名函数)
            </li>
            <li>
              <a href="#%E5%87%BD%E6%95%B0%E6%A0%87%E6%B3%A8">函数标注</a>
            </li>
            <li>[Lexical scope（静态作用域）](#Lexical scope（静态作用域）)</li>
            <li>
              [Lexical closures（词法闭包）](#Lexical closures（词法闭包）)
            </li>
            <li>
              [Testing functions for equality（测试函数是否相等）](#Testing
              functions for equality（测试函数是否相等）)
            </li>
            <li>[Return values（默认返回值）](#Return values（默认返回值）)</li>
            <li>
              <a
                href="#%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88IIFE%EF%BC%89"
                >立即调用的函数表达式（IIFE）</a
              >
            </li>
          </ul>
        </li>
      </ul>
    </div>
    <div id="content">
      <h1 id="函数和方法">函数和方法</h1>
      <h2 id="Functions（方法）函数定义">Functions（方法）函数定义</h2>
      <p>dart</p>
      <p>
        Dart 是一个真正的面向对象语言，方法也是对象并且具有一种 类型，
        Function。 这意味着，方法可以赋值给变量，也可以当做其他方法的参数。
        也可以把 Dart 类的实例当做方法来调用。
      </p>
      <pre><code class="language-dart">// 方法可以有两种类型的参数：必需的和可选的。 
// 必需的参数在参数列表前面， 后面是可选参数。
bool isNoble(int atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}
// 推荐 在公开的 APIs 上使用静态类型， 你当然也可以选择忽略类型定义
isNoble(atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}

// 对于只有一个表达式的方法，你可以选择 使用缩写语法来定义
// 这个 =&gt; expr 语法是 { return expr; } 形式的缩写。
// =&gt; 形式 有时候也称之为 胖箭头 语法。
// 在箭头 (=&gt;) 和冒号 (;) 之间只能使用一个 表达式 – 不能使用 语句。
bool isNoble(int atomicNumber) =&gt; _nobleGases[atomicNumber] != null;</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">function print(s) {
  console.log(s);
}

var print = function(s) {
  console.log(s);
};</code></pre>
      <p>python</p>
      <p>
        函数的 执行 会引入一个用于函数局部变量的新符号表。
        更确切地说，函数中的所有变量赋值都将值存储在本地符号表中；
      </p>
      <ul>
        <li>而变量引用首先在本地符号表中查找，</li>
        <li>然后在封闭函数的本地符号表中查找，</li>
        <li>然后在全局符号表中查找，</li>
        <li>最后在内置符号表中查找。</li>
      </ul>
      <p>所以全局变量不能直接在函数中赋值（除非使用 global 命名）</p>
      <p>
        即使没有 return 语句的函数也会返回一个值，尽管它是一个相当无聊的值。
        这个值称为 None （它是内置名称）。
      </p>
      <pre><code class="language-python">def fib(n):    # write Fibonacci series up to n
    &quot;&quot;&quot;Print a Fibonacci series up to n.&quot;&quot;&quot;
    a, b = 0, 1
    while a &lt; n:
        print(a, end=&#39; &#39;)
        a, b = b, a+b
    print()

# Now call the function we just defined:
fib(2000)
# 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597

f = fib
f(100)
# 0 1 1 2 3 5 8 13 21 34 55 89

fib(0)
print(fib(0))
# None

def fib2(n):  # return Fibonacci series up to n
    &quot;&quot;&quot;Return a list containing the Fibonacci series up to n.&quot;&quot;&quot;
    result = []
    a, b = 0, 1
    while a &lt; n:
        result.append(a)    # see below
        a, b = b, a+b
    return result

f100 = fib2(100)    # call it
f100                # write the result
# 0 1 1 2 3 5 8 13 21 34 55 89</code></pre>
      <h2 id="Optional named parameters（可选命名参数）">
        Optional named parameters（可选命名参数）
      </h2>
      <p>dart</p>
      <pre><code class="language-dart">/// Sets the [bold] and [hidden] flags to the values
/// you specify.
enableFlags({bool bold, bool hidden}) {
  // ...
}
enableFlags(bold: true, hidden: false);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">function f({x,y=2}) {
  // ...
}
f({x:1})</code></pre>
      <p>python</p>
      <p>关键字参数</p>
      <pre><code class="language-python"># 接受一个必需的参数（voltage）和三个可选的参数（state, action，和 type）
def parrot(voltage, state=&#39;a stiff&#39;, action=&#39;voom&#39;, type=&#39;Norwegian Blue&#39;):
    print(&quot;-- This parrot wouldn&#39;t&quot;, action, end=&#39; &#39;)
    print(&quot;if you put&quot;, voltage, &quot;volts through it.&quot;)
    print(&quot;-- Lovely plumage, the&quot;, type)
    print(&quot;-- It&#39;s&quot;, state, &quot;!&quot;)
parrot(1000)                                          # 1 positional argument
parrot(voltage=1000)                                  # 1 keyword argument
parrot(voltage=1000000, action=&#39;VOOOOOM&#39;)             # 2 keyword arguments
parrot(action=&#39;VOOOOOM&#39;, voltage=1000000)             # 2 keyword arguments
parrot(&#39;a million&#39;, &#39;bereft of life&#39;, &#39;jump&#39;)         # 3 positional arguments
parrot(&#39;a thousand&#39;, state=&#39;pushing up the daisies&#39;)  # 1 positional, 1 keyword</code></pre>
      <h2 id="Optional positional parameters（可选位置参数）">
        Optional positional parameters（可选位置参数）
      </h2>
      <p>dart</p>
      <p>把一些方法的参数放到 [] 中就变成可选 位置参数了：</p>
      <pre><code class="language-dart">String say(String from, String msg, [String device]) {
  var result = &#39;$from says $msg&#39;;
  if (device != null) {
    result = &#39;$result with a $device&#39;;
  }
  return result;
}
assert(say(&#39;Bob&#39;, &#39;Howdy&#39;) == &#39;Bob says Howdy&#39;);
assert(say(&#39;Bob&#39;, &#39;Howdy&#39;, &#39;smoke signal&#39;) ==
    &#39;Bob says Howdy with a smoke signal&#39;);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <p>任意的参数列表</p>
      <pre><code class="language-python">def cheeseshop(kind, *arguments, **keywords):
    print(&quot;-- Do you have any&quot;, kind, &quot;?&quot;)
    print(&quot;-- I&#39;m sorry, we&#39;re all out of&quot;, kind)
    for arg in arguments:
        print(arg)
    print(&quot;-&quot; * 40)
    for kw in keywords:
        print(kw, &quot;:&quot;, keywords[kw])

cheeseshop(&quot;Limburger&quot;,
           &quot;It&#39;s very runny, sir.&quot;,
           &quot;It&#39;s really very, VERY runny, sir.&quot;,
           shopkeeper=&quot;Michael Palin&quot;,
           client=&quot;John Cleese&quot;,
           sketch=&quot;Cheese Shop Sketch&quot;)

# -- Do you have any Limburger ?
# -- I&#39;m sorry, we&#39;re all out of Limburger
# It&#39;s very runny, sir.
# It&#39;s really very, VERY runny, sir.
# ----------------------------------------
# shopkeeper : Michael Palin
# client : John Cleese
# sketch : Cheese Shop Sketch</code></pre>
      <pre><code class="language-sh">&gt;&gt;&gt; def concat(*args, sep=&quot;/&quot;):
...     return sep.join(args)
...
&gt;&gt;&gt; concat(&quot;earth&quot;, &quot;mars&quot;, &quot;venus&quot;)
&#39;earth/mars/venus&#39;
&gt;&gt;&gt; concat(&quot;earth&quot;, &quot;mars&quot;, &quot;venus&quot;, sep=&quot;.&quot;)
&#39;earth.mars.venus&#39;</code></pre>
      <h2 id="Default parameter values（默认参数值）">
        Default parameter values（默认参数值）
      </h2>
      <p>dart</p>
      <p>
        在定义方法的时候，可以使用 = 来定义可选参数的默认值。
        默认值只能是编译时常量。 如果没有提供默认值，则默认值为 null。
      </p>
      <pre><code class="language-dart">/// Sets the [bold] and [hidden] flags to the values you
/// specify, defaulting to false.
void enableFlags({bool bold = false, bool hidden = false}) {
  // ...
}
// bold will be true; hidden will be false.
// 旧版本代码可能需要使用一个冒号 (:) 而不是 = 来设置参数默认值。
// 在以后版本不能使用：，
// Dart SDK 版本为 1.21 或者更高的版本，推荐使用 = 来设置默认值
enableFlags(bold: true);

String say(String from, String msg,
    [String device = &#39;carrier pigeon&#39;, String mood]) {
  var result = &#39;$from says $msg&#39;;
  if (device != null) {
    result = &#39;$result with a $device&#39;;
  }
  if (mood != null) {
    result = &#39;$result (in a $mood mood)&#39;;
  }
  return result;
}
assert(say(&#39;Bob&#39;, &#39;Howdy&#39;) ==
    &#39;Bob says Howdy with a carrier pigeon&#39;);

void doStuff(
    {List&lt;int&gt; list = const [1, 2, 3],
    Map&lt;String, String&gt; gifts = const {
      &#39;first&#39;: &#39;paper&#39;,
      &#39;second&#39;: &#39;cotton&#39;,
      &#39;third&#39;: &#39;leather&#39;
    }}) {
  print(&#39;list:  $list&#39;);
  print(&#39;gifts: $gifts&#39;);
}

// 默认参数必须为const类型
void main() {
  List f({int a, List&lt;int&gt; L = const []}) {
    // var L2 = new List.from(L);
    var L2 = []..addAll(L);
    L2.add(a);
    return L2;
  }
  print(f(a:1));
  print(f(a:2));
  print(f(a:3));
}
// [1]
// [2]
// [3]</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">function f(a, L=[]) {
  L.push(a);
  return L;
}
console.log(f(1));
console.log(f(2));
console.log(f(3));
// [ 1 ]
// [ 2 ]
// [ 3 ]</code></pre>
      <p>python</p>
      <p>这个函数可以通过几种方式调用:</p>
      <ul>
        <li>只给出必需的参数：ask_ok(&#39;Do you really want to quit?&#39;)</li>
        <li>
          给出一个可选的参数：ask_ok(&#39;OK to overwrite the file?&#39;, 2)
        </li>
        <li>
          或者给出所有的参数：ask_ok(&#39;OK to overwrite the file?&#39;, 2,
          &#39;Come on, only yes or no!&#39;)
        </li>
      </ul>
      <pre><code class="language-python">def ask_ok(prompt, retries=4, reminder=&#39;Please try again!&#39;):
    while True:
        ok = input(prompt)
        if ok in (&#39;y&#39;, &#39;ye&#39;, &#39;yes&#39;): # in 关键字。它可以测试一个序列是否包含某个值。
            return True
        if ok in (&#39;n&#39;, &#39;no&#39;, &#39;nop&#39;, &#39;nope&#39;):
            return False
        retries = retries - 1
        if retries &lt; 0:
            raise ValueError(&#39;invalid user response&#39;)
        print(reminder)

# 默认值是在 定义过程 中在函数定义处计算的，所以
i = 5

def f(arg=i):
    print(arg)

i = 6
f()
# 5

# 默认值为可变对象（列表、字典以及大多数类实例）时
def f(a, L=[]):
    L.append(a)
    return L
print(f(1))
print(f(2))
print(f(3))
# [1]
# [1, 2]
# [1, 2, 3]

# 如果你不想要在后续调用之间共享默认值
def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L</code></pre>
      <h2 id="解包参数列表">解包参数列表</h2>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-sh">&gt;&gt;&gt; list(range(3, 6))            # normal call with separate arguments
[3, 4, 5]
&gt;&gt;&gt; args = [3, 6]
&gt;&gt;&gt; list(range(*args))            # call with arguments unpacked from a list
[3, 4, 5]</code></pre>
      <pre><code class="language-python">def parrot(voltage, state=&#39;a stiff&#39;, action=&#39;voom&#39;):
    print(&quot;-- This parrot wouldn&#39;t&quot;, action, end=&#39; &#39;)
    print(&quot;if you put&quot;, voltage, &quot;volts through it.&quot;, end=&#39; &#39;)
    print(&quot;E&#39;s&quot;, state, &quot;!&quot;)

d = {&quot;voltage&quot;: &quot;four million&quot;, &quot;state&quot;: &quot;bleedin&#39; demised&quot;, &quot;action&quot;: &quot;VOOM&quot;}
parrot(**d)</code></pre>
      <h2 id="The main() function（入口函数）">
        The main() function（入口函数）
      </h2>
      <p>dart</p>
      <p>
        每个应用都需要有个顶级的 main() 入口方法才能执行。 main() 方法的返回值为
        void 并且有个可选的 <code>List&lt;String&gt;</code> 参数。
      </p>
      <pre><code class="language-dart">void main() {
  querySelector(&quot;#sample_text_id&quot;)
    ..text = &quot;Click me!&quot;
    ..onClick.listen(reverseText);
}

// 下面是一个命令行应用的 main() 方法，并且使用了 方法参数作为输入参数
// Run the app like this: dart args.dart 1 test
void main(List&lt;String&gt; arguments) {
  print(arguments);
  assert(arguments.length == 2);
  assert(int.parse(arguments[0]) == 1);
  assert(arguments[1] == &#39;test&#39;);
}</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="Functions as first-class objects（一等方法对象）">
        Functions as first-class objects（一等方法对象）
      </h2>
      <p>dart</p>
      <pre><code class="language-dart">// 可以把方法当做参数调用另外一个方法。
printElement(element) {
  print(element);
}
var list = [1, 2, 3];
// Pass printElement as a parameter.
list.forEach(printElement);

// 方法也可以赋值给一个变量：
var loudify = (msg) =&gt; &#39;!!! ${msg.toUpperCase()} !!!&#39;;
assert(loudify(&#39;hello&#39;) == &#39;!!! HELLO !!!&#39;);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">function add(x, y) {
  return x + y;
}

// 将函数赋值给一个变量
var operator = add;

// 将函数作为参数和返回值
function a(op){
  return op;
}
a(add)(1, 1)
// 2</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="Anonymous functions（匿名方法）匿名函数">
        Anonymous functions（匿名方法）匿名函数
      </h2>
      <p>dart</p>
      <p>
        大部分方法都带有名字，例如 main() 或者 printElement()。
        你有可以创建没有名字的方法，称之为 匿名方法， 有时候也被称为 lambda 或者
        closure 闭包。
      </p>
      <pre><code class="language-dart">var list = [&#39;apples&#39;, &#39;oranges&#39;, &#39;grapes&#39;, &#39;bananas&#39;, &#39;plums&#39;];
list.forEach((i) {
  print(list.indexOf(i).toString() + &#39;: &#39; + i);
});
// 如果方法只包含一个语句，可以使用胖箭头语法缩写。
list.forEach((i) =&gt; print(list.indexOf(i).toString() + &#39;: &#39; + i));</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <p>箭头函数有几个使用注意点。</p>
      <ul>
        <li>
          函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
        </li>
        <li>
          不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
        </li>
        <li>
          不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest
          参数代替。
        </li>
        <li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</li>
      </ul>
      <p>不适用场合</p>
      <ul>
        <li>第一个场合是定义对象的方法，且该方法内部包括this。</li>
        <li>第二个场合是需要动态this的时候，也不应使用箭头函数。</li>
      </ul>
      <pre><code class="language-js">var sum = (num1, num2) =&gt; { return num1 + num2; }
let getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });
[1,2,3].map(x =&gt; x * x);
var result = values.sort((a, b) =&gt; a - b);


function Timer() {
  this.s1 = 0;
  this.s2 = 0;
  // 箭头函数
  setInterval(() =&gt; this.s1++, 1000);
  // 普通函数
  setInterval(function () {
    this.s2++;
  }, 1000);
}
var timer = new Timer();
setTimeout(() =&gt; console.log(&#39;s1: &#39;, timer.s1), 3100);
setTimeout(() =&gt; console.log(&#39;s2: &#39;, timer.s2), 3100);
// s1: 3
// s2: 0


// ES6
function foo() {
  setTimeout(() =&gt; {
    console.log(&#39;id:&#39;, this.id);
  }, 100);
}
// ES5
function foo() {
  var _this = this;
  setTimeout(function () {
    console.log(&#39;id:&#39;, _this.id);
  }, 100);
}

// 调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；
// 如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。
const cat = {
  lives: 9,
  jumps: () =&gt; {
    this.lives--;
  }
}
// 点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。
var button = document.getElementById(&#39;press&#39;);
button.addEventListener(&#39;click&#39;, () =&gt; {
  this.classList.toggle(&#39;on&#39;);
});</code></pre>
      <p>python</p>
      <pre><code class="language-python"># 使用一个lambda表达式来返回一个函数
def make_incrementor(n):
    return lambda x: x + n
f = make_incrementor(42)

# 传递一个小函数作为参数
pairs = [(1, &#39;one&#39;), (2, &#39;two&#39;), (3, &#39;three&#39;), (4, &#39;four&#39;)]
pairs.sort(key=lambda pair: pair[1])
# [(4, &#39;four&#39;), (1, &#39;one&#39;), (3, &#39;three&#39;), (2, &#39;two&#39;)]</code></pre>
      <h2 id="函数标注">函数标注</h2>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python">def f(ham: str, eggs: str = &#39;eggs&#39;) -&gt; str:
    print(&quot;Annotations:&quot;, f.__annotations__)
    print(&quot;Arguments:&quot;, ham, eggs)
    return ham + &#39; and &#39; + eggs

f(&#39;spam&#39;)</code></pre>
      <h2 id="Lexical scope（静态作用域）">Lexical scope（静态作用域）</h2>
      <p>dart</p>
      <p>
        Dart 是静态作用域语言，变量的作用域在写代码的时候就确定过了。
        基本上大括号里面定义的变量就 只能在大括号里面访问，和 Java 作用域 类似。
      </p>
      <pre><code class="language-dart">var topLevel = true;
main() {
  var insideMain = true;
  myFunction() {
    var insideFunction = true;
    nestedFunction() {
      var insideNestedFunction = true;
      assert(topLevel);
      assert(insideMain);
      assert(insideFunction);
      assert(insideNestedFunction);
    }
  }
}</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="Lexical closures（词法闭包）">Lexical closures（词法闭包）</h2>
      <p>dart</p>
      <p>
        一个 闭包 是一个方法对象， 不管该对象在何处被调用，
        该对象都可以访问其作用域内 的变量。 方法可以封闭定义到其作用域内的变量。
      </p>
      <pre><code class="language-dart">// makeAdder() 捕获到了变量 addBy。
// 不管你在那里执行 makeAdder() 所返回的函数，都可以使用 addBy 参数
/// Returns a function that adds [addBy] to the
/// function&#39;s argument.
Function makeAdder(num addBy) {
  return (num i) =&gt; addBy + i;
}

main() {
  // Create a function that adds 2.
  var add2 = makeAdder(2);

  // Create a function that adds 4.
  var add4 = makeAdder(4);

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">function f1() {
  var n = 999;
  function f2() {
    console.log(n);
  }
  return f2;
}
var result = f1();
result(); // 999


function createIncrementor(start) {
  return function () {
    return start++;
  };
}
var inc = createIncrementor(5);
inc() // 5
inc() // 6
inc() // 7


function Person(name) {
  var _age;
  function setAge(n) {
    _age = n;
  }
  function getAge() {
    return _age;
  }
  return {
    name: name,
    getAge: getAge,
    setAge: setAge
  };
}
var p1 = Person(&#39;张三&#39;);
p1.setAge(25);
p1.getAge() // 25</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="Testing functions for equality（测试函数是否相等）">
        Testing functions for equality（测试函数是否相等）
      </h2>
      <p>dart</p>
      <pre><code class="language-dart">foo() {}               // A top-level function

class A {
  static void bar() {} // A static method
  void baz() {}        // An instance method
}

main() {
  var x;

  // Comparing top-level functions.
  x = foo;
  assert(foo == x);

  // Comparing static methods.
  x = A.bar;
  assert(A.bar == x);

  // Comparing instance methods.
  var v = new A(); // Instance #1 of A
  var w = new A(); // Instance #2 of A
  var y = w;
  x = w.baz;

  // These closures refer to the same instance (#2),
  // so they&#39;re equal.
  assert(y.baz == x);

  // These closures refer to different instances,
  // so they&#39;re unequal.
  assert(v.baz != w.baz);
}</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="Return values（默认返回值）">Return values（默认返回值）</h2>
      <p>dart</p>
      <p>
        所有的函数都返回一个值。 如果没有指定返回值，则 默认把语句 return null;
        作为函数的最后一个语句执行。
      </p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="立即调用的函数表达式（IIFE）">立即调用的函数表达式（IIFE）</h2>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">(function(){ /* code */ }());
// 或者
(function(){ /* code */ })();</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
    </div>
    <script src="./highlight/highlight.pack.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>
