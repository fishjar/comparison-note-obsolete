<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>4.函数和方法.md</title>
    <link rel="stylesheet" href="./styles.css" />
    <link rel="stylesheet" href="./highlight/styles/github.css" />
  </head>
  <body>
    <div id="nav">
      <ul>
        <li>
          <a href="#%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95"
            >函数和方法</a
          >
          <ul>
            <li>
              <a
                href="#%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89"
                >函数和方法定义</a
              >
              <ul>
                <li>
                  <a href="#%E9%BB%98%E8%AE%A4%E8%BF%94%E5%9B%9E%E5%80%BC"
                    >默认返回值</a
                  >
                </li>
                <li>
                  <a href="#%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC"
                    >命名返回值</a
                  >
                </li>
              </ul>
            </li>
            <li>
              <a href="#%E6%96%B9%E6%B3%95">方法</a>
              <ul>
                <li>
                  <a href="#%E6%96%B9%E6%B3%95%E7%BB%A7%E6%89%BF">方法继承</a>
                </li>
                <li>
                  <a href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99">方法重写</a>
                </li>
                <li>
                  <a href="#%E6%8E%A5%E5%8F%A3">接口</a>
                  <ul>
                    <li><a href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3">空接口</a></li>
                    <li>
                      <a href="#%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97"
                        >接口嵌套</a
                      >
                    </li>
                    <li>
                      <a href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"
                        >类型断言</a
                      >
                    </li>
                    <li>
                      <a href="#%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9"
                        >类型选择</a
                      >
                    </li>
                    <li>
                      <a href="#Stringer%E6%8E%A5%E5%8F%A3">Stringer接口</a>
                    </li>
                    <li><a href="#error%E6%8E%A5%E5%8F%A3">error接口</a></li>
                    <li><a href="#Reader%E6%8E%A5%E5%8F%A3">Reader接口</a></li>
                    <li><a href="#Image%E6%8E%A5%E5%8F%A3">Image接口</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>
              <a href="#%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0">入口函数</a>
              <ul>
                <li><a href="#init%E5%87%BD%E6%95%B0">init函数</a></li>
              </ul>
            </li>
            <li>
              <a href="#%E5%8F%82%E6%95%B0">参数</a>
              <ul>
                <li>
                  <a
                    href="#%E5%8F%AF%E9%80%89%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"
                    >可选命名参数</a
                  >
                </li>
                <li>
                  <a
                    href="#%E5%8F%AF%E9%80%89%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"
                    >可选位置参数</a
                  >
                </li>
                <li>
                  <a href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%80%BC"
                    >默认参数值</a
                  >
                </li>
                <li>
                  <a
                    href="#%E8%A7%A3%E5%8C%85%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"
                    >解包参数列表</a
                  >
                </li>
                <li><a href="#%E5%8F%98%E5%8F%82">变参</a></li>
              </ul>
            </li>
            <li>
              <a href="#%E4%B8%80%E7%AD%89%E6%96%B9%E6%B3%95%E5%AF%B9%E8%B1%A1"
                >一等方法对象</a
              >
            </li>
            <li>
              <a href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">匿名函数</a>
            </li>
            <li>
              <a href="#%E5%87%BD%E6%95%B0%E6%A0%87%E6%B3%A8">函数标注</a>
            </li>
            <li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a></li>
            <li><a href="#%E9%97%AD%E5%8C%85">闭包</a></li>
            <li>
              <a
                href="#%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"
                >测试函数是否相等</a
              >
            </li>
            <li>
              <a
                href="#%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"
                >立即调用的函数表达式</a
              >
            </li>
          </ul>
        </li>
      </ul>
    </div>
    <div id="content">
      <h1 id="函数和方法">函数和方法</h1>
      <h2 id="函数和方法定义">函数和方法定义</h2>
      <p>dart</p>
      <p>
        Dart 是一个真正的面向对象语言，方法也是对象并且具有一种 类型，
        Function。 这意味着，方法可以赋值给变量，也可以当做其他方法的参数。
        也可以把 Dart 类的实例当做方法来调用。
      </p>
      <pre><code class="language-dart">// 方法可以有两种类型的参数：必需的和可选的。 
// 必需的参数在参数列表前面， 后面是可选参数。
bool isNoble(int atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}
// 推荐 在公开的 APIs 上使用静态类型， 你当然也可以选择忽略类型定义
isNoble(atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}

// 对于只有一个表达式的方法，你可以选择 使用缩写语法来定义
// 这个 =&gt; expr 语法是 { return expr; } 形式的缩写。
// =&gt; 形式 有时候也称之为 胖箭头 语法。
// 在箭头 (=&gt;) 和冒号 (;) 之间只能使用一个 表达式 – 不能使用 语句。
bool isNoble(int atomicNumber) =&gt; _nobleGases[atomicNumber] != null;</code></pre>
      <p>go</p>
      <p>
        实参通过值的方式传递，因此函数的形参是实参的拷贝。
        如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，
        实参可能会由于函数的间接引用被修改。
      </p>
      <pre><code class="language-go">package main
import &quot;fmt&quot;
// 注意类型在变量名 之后。
func add(x int, y int) int  {
  return x + y
}
func main() {
  fmt.Println(add(42, 13))
}


// 当连续两个或多个函数的已命名形参类型相同时，
// 除最后一个类型以外，其它都可以省略。
package main
import &quot;fmt&quot;
// x int, y int 被缩写为 x, y int
func add(x, y int) (int) {
  return x + y
}
func main() {
  fmt.Println(add(42, 13))
}


// 函数可以返回任意数量的返回值。
package main
import &quot;fmt&quot;
func swap(x, y string) (string, string) {
  return y, x
}
func main() {
  a, b := swap(&quot;hello&quot;, &quot;world&quot;)
  fmt.Println(a, b)
}


// 有函数体的函数声明，这表示该函数不是以Go实现的。
// 这样的声明定义了函数标识符。
package math
func Sin(x float64) float //implemented in assembly language</code></pre>
      <p>js</p>
      <pre><code class="language-js">function print(s) {
  console.log(s);
}

var print = function(s) {
  console.log(s);
};</code></pre>
      <p>python</p>
      <p>
        函数的 执行 会引入一个用于函数局部变量的新符号表。
        更确切地说，函数中的所有变量赋值都将值存储在本地符号表中；
      </p>
      <ul>
        <li>而变量引用首先在本地符号表中查找，</li>
        <li>然后在封闭函数的本地符号表中查找，</li>
        <li>然后在全局符号表中查找，</li>
        <li>最后在内置符号表中查找。</li>
      </ul>
      <p>所以全局变量不能直接在函数中赋值（除非使用 global 命名）</p>
      <p>
        即使没有 return 语句的函数也会返回一个值，尽管它是一个相当无聊的值。
        这个值称为 None （它是内置名称）。
      </p>
      <pre><code class="language-python">def fib(n):    # write Fibonacci series up to n
    &quot;&quot;&quot;Print a Fibonacci series up to n.&quot;&quot;&quot;
    a, b = 0, 1
    while a &lt; n:
        print(a, end=&#39; &#39;)
        a, b = b, a+b
    print()

# Now call the function we just defined:
fib(2000)
# 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597

f = fib
f(100)
# 0 1 1 2 3 5 8 13 21 34 55 89

fib(0)
print(fib(0))
# None

def fib2(n):  # return Fibonacci series up to n
    &quot;&quot;&quot;Return a list containing the Fibonacci series up to n.&quot;&quot;&quot;
    result = []
    a, b = 0, 1
    while a &lt; n:
        result.append(a)    # see below
        a, b = b, a+b
    return result

f100 = fib2(100)    # call it
f100                # write the result
# 0 1 1 2 3 5 8 13 21 34 55 89</code></pre>
      <h3 id="默认返回值">默认返回值</h3>
      <p>Return values（默认返回值）</p>
      <p>dart</p>
      <p>
        所有的函数都返回一个值。 如果没有指定返回值，则 默认把语句 return null;
        作为函数的最后一个语句执行。
      </p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="命名返回值">命名返回值</h3>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <ul>
        <li>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</li>
        <li>返回值的名称应当具有一定的意义，它可以作为文档使用。</li>
        <li>没有参数的 return 语句返回已命名的返回值。也就是 直接 返回。</li>
        <li>
          直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。
        </li>
      </ul>
      <pre><code class="language-go">package main
import &quot;fmt&quot;
func split(sum int) (x, y int) {
  x = sum * 4 / 9
  y = sum - x
  return
}
func main() {
  //fmt.Println(split(17))
  a, b := split(17)
  fmt.Println(a, b)
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="方法">方法</h2>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <ul>
        <li>方法就是一类带特殊的 接收者 参数的函数。</li>
        <li>方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。</li>
      </ul>
      <p>
        我们可以给任何自定义类型添加一个或多个方法。
        每种类型对应的方法必须和类型的定义在同一个包中，
        因此是无法给int这类内置类型添加方法的
        （因为方法的定义和类型的定义不在一个包中）。
        对于给定的类型，每个方法的名字必须是唯一的，
        同时方法和函数一样也不支持重载。
      </p>
      <pre><code class="language-go">package main
import (
  &quot;fmt&quot;
  &quot;math&quot;
)
type Vertex struct {
  X, Y float64
}
func (v Vertex) Abs() float64 {
  return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
func main() {
  v := Vertex{3, 4}
  fmt.Println(v.Abs())
}

// 虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样
// method里面可以访问接收者的字段
// 调用method通过.访问，就像struct里面访问字段一样
package main
import (
  &quot;fmt&quot;
  &quot;math&quot;
)
type Rectangle struct {             // 定义矩形
  width, height float64
}
type Circle struct {                // 定义圆形
  radius float64
}
func (r Rectangle) area() float64 { // 矩形的面积
  return r.width*r.height
}
func (c Circle) area() float64 {    // 圆形的面积
  return c.radius * c.radius * math.Pi
}
func main() {
  r1 := Rectangle{12, 2}
  r2 := Rectangle{9, 4}
  c1 := Circle{10}
  c2 := Circle{25}
  fmt.Println(&quot;Area of r1 is: &quot;, r1.area())
  fmt.Println(&quot;Area of r2 is: &quot;, r2.area())
  fmt.Println(&quot;Area of c1 is: &quot;, c1.area())
  fmt.Println(&quot;Area of c2 is: &quot;, c2.area())
}


// 复杂一点的例子
package main
import &quot;fmt&quot;
const(
  WHITE = iota // 枚举
  BLACK
  BLUE
  RED
  YELLOW
)
type Color byte
type Box struct {
  width, height, depth float64
  color Color
}
type BoxList []Box // a slice of boxes
func (b Box) Volume() float64 {
  return b.width * b.height * b.depth
}
func (b *Box) SetColor(c Color) {
  b.color = c
}
func (bl BoxList) BiggestColor() Color {
  v := 0.00
  k := Color(WHITE)
  for _, b := range bl {
    if bv := b.Volume(); bv &gt; v {
      v = bv
      k = b.color
    }
  }
  return k
}
func (bl BoxList) PaintItBlack() {
  for i, _ := range bl {
    bl[i].SetColor(BLACK)
  }
}
func (c Color) String() string {
  strings := []string {&quot;WHITE&quot;, &quot;BLACK&quot;, &quot;BLUE&quot;, &quot;RED&quot;, &quot;YELLOW&quot;}
  return strings[c]
}
func main() {
  boxes := BoxList {
    Box{4, 4, 4, RED},
    Box{10, 10, 1, YELLOW},
    Box{1, 1, 20, BLACK},
    Box{10, 10, 1, BLUE},
    Box{10, 30, 1, WHITE},
    Box{20, 20, 20, YELLOW},
  }

  fmt.Printf(&quot;We have %d boxes in our set\n&quot;, len(boxes))
  fmt.Println(&quot;The volume of the first one is&quot;, boxes[0].Volume(), &quot;cm³&quot;)
  fmt.Println(&quot;The color of the last one is&quot;,boxes[len(boxes)-1].color.String())
  fmt.Println(&quot;The biggest one is&quot;, boxes.BiggestColor().String())

  fmt.Println(&quot;Let&#39;s paint them all black&quot;)
  boxes.PaintItBlack()
  fmt.Println(&quot;The color of the second one is&quot;, boxes[1].color.String())

  fmt.Println(&quot;Obviously, now, the biggest one is&quot;, boxes.BiggestColor().String())
}


// 方法只是个带接收者参数的函数。
// 现在这个 Abs 的写法就是个正常的函数，功能并没有什么变化。
package main
import (
  &quot;fmt&quot;
  &quot;math&quot;
)
type Vertex struct {
  X, Y float64
}
func Abs(v Vertex) float64 {
  return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
func main() {
  v := Vertex{3, 4}
  fmt.Println(Abs(v))
}


// 也可以为非结构体类型声明方法。
// 只能为在同一包内定义的类型的接收者声明方法，
// 而不能为其它包内定义的类型（包括 int 之类的内建类型）的接收者声明方法
package main
import (
  &quot;fmt&quot;
  &quot;math&quot;
)
type MyFloat float64
func (f MyFloat) Abs() float64 {
  if f &lt; 0 {
    return float64(-f)
  }
  return float64(f)
}
func main() {
  f := MyFloat(-math.Sqrt2)
  fmt.Println(f.Abs())
}


// 指针接收者的方法可以修改接收者指向的值（就像 Scale 在这做的）。
// 由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。
// 若使用值接收者，那么 Scale 方法会对原始 Vertex 值的副本进行操作。
package main
import (
  &quot;fmt&quot;
  &quot;math&quot;
)
type Vertex struct {
  X, Y float64
}
func (v Vertex) Abs() float64 {
  return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
func (v *Vertex) Scale(f float64) { // 指针接收者
  v.X = v.X * f
  v.Y = v.Y * f
}
func main() {
  v := Vertex{3, 4} // 初始化结构体
  v.Scale(10) // 更改结构体自身数据
  fmt.Println(v.Abs())
}


// 把 Abs 和 Scale 方法重写为函数。
package main
import (
  &quot;fmt&quot;
  &quot;math&quot;
)
type Vertex struct {
  X, Y float64
}
func Abs(v Vertex) float64 {
  return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
func Scale(v *Vertex, f float64) {
  v.X = v.X * f
  v.Y = v.Y * f
}
func main() {
  v := Vertex{3, 4}
  Scale(&amp;v, 10)
  fmt.Println(Abs(v))
}


// 带指针参数的函数必须接受一个指针：
// 而以指针为接收者的方法被调用时，接收者既能为值又能为指针：
// Go 会将语句 v.Scale(5) 解释为 (&amp;v).Scale(5)。
package main
import &quot;fmt&quot;
type Vertex struct {
  X, Y float64
}
func (v *Vertex) Scale(f float64) {
  v.X = v.X * f
  v.Y = v.Y * f
}
func ScaleFunc(v *Vertex, f float64) {
  v.X = v.X * f
  v.Y = v.Y * f
}
func main() {
  v := Vertex{3, 4}
  v.Scale(2)
  ScaleFunc(&amp;v, 10)
  p := &amp;Vertex{4, 3}
  p.Scale(3)
  ScaleFunc(p, 8)
  fmt.Println(v, p) // {60 80} &amp;{96 72}
}


// 接受一个值作为参数的函数必须接受一个指定类型的值：
// 方法调用 p.Abs() 会被解释为 (*p).Abs()。
package main
import (
  &quot;fmt&quot;
  &quot;math&quot;
)
type Vertex struct {
  X, Y float64
}
func (v Vertex) Abs() float64 {
  return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
func AbsFunc(v Vertex) float64 {
  return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
func main() {
  v := Vertex{3, 4}
  fmt.Println(v.Abs())
  fmt.Println(AbsFunc(v))
  p := &amp;Vertex{4, 3}
  fmt.Println(p.Abs())
  fmt.Println(AbsFunc(*p))
}


// 使用指针接收者的原因有二：
// 首先，方法能够修改其接收者指向的值。
// 其次，这样可以避免在每次调用方法时复制该值。
// 若值的类型为大型结构体时，这样做会更加高效。
package main
import (
  &quot;fmt&quot;
  &quot;math&quot;
)
type Vertex struct {
  X, Y float64
}
func (v *Vertex) Scale(f float64) {
  v.X = v.X * f
  v.Y = v.Y * f
}
func (v *Vertex) Abs() float64 {
  return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
func main() {
  v := &amp;Vertex{3, 4}
  fmt.Printf(&quot;Before scaling: %+v, Abs: %v\n&quot;, v, v.Abs())
  v.Scale(5)
  fmt.Printf(&quot;After scaling: %+v, Abs: %v\n&quot;, v, v.Abs())
}


// 想要调用指针类型方法(*Point).ScaleBy
r := &amp;Point{1, 2}
r.ScaleBy(2)
fmt.Println(*r) // &quot;{2, 4}&quot;
// 或者这样：
p := Point{1, 2}
pptr := &amp;p
pptr.ScaleBy(2)
fmt.Println(p) // &quot;{2, 4}&quot;
// 或者这样:
p := Point{1, 2}
(&amp;p).ScaleBy(2)
fmt.Println(p) // &quot;{2, 4}&quot;
// 如果接收器p是一个Point类型的变量，
// 并且其方法需要一个Point指针作为接收器，
// 我们可以用下面这种简短的写法：
p.ScaleBy(2)

// 所以下面这两种写法等价的：
pptr.Distance(q)
(*pptr).Distance(q)</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="方法继承">方法继承</h3>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go">package main
import &quot;fmt&quot;
type Human struct {
  name string
  age int
  phone string
}
type Student struct {
  Human //匿名字段
  school string
}
type Employee struct {
  Human //匿名字段
  company string
}
//在human上面定义了一个method
func (h *Human) SayHi() {
  fmt.Printf(&quot;Hi, I am %s you can call me on %s\n&quot;, h.name, h.phone)
}
func main() {
  mark := Student{Human{&quot;Mark&quot;, 25, &quot;222-222-YYYY&quot;}, &quot;MIT&quot;}
  sam := Employee{Human{&quot;Sam&quot;, 45, &quot;111-888-XXXX&quot;}, &quot;Golang Inc&quot;}

  mark.SayHi()
  sam.SayHi()
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="方法重写">方法重写</h3>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go">package main
import &quot;fmt&quot;
type Human struct {
  name string
  age int
  phone string
}
type Student struct {
  Human //匿名字段
  school string
}
type Employee struct {
  Human //匿名字段
  company string
}
//Human定义method
func (h *Human) SayHi() {
  fmt.Printf(&quot;Hi, I am %s you can call me on %s\n&quot;, h.name, h.phone)
}
//Employee的method重写Human的method
func (e *Employee) SayHi() {
  fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;, e.name,
    e.company, e.phone) //Yes you can split into 2 lines here.
}
func main() {
  mark := Student{Human{&quot;Mark&quot;, 25, &quot;222-222-YYYY&quot;}, &quot;MIT&quot;}
  sam := Employee{Human{&quot;Sam&quot;, 45, &quot;111-888-XXXX&quot;}, &quot;Golang Inc&quot;}

  mark.SayHi()
  sam.SayHi()
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h3 id="接口">接口</h3>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <p>
        接口类型具体描述了一系列方法的集合，
        一个实现了这些方法的具体类型是这个接口类型的实例
      </p>
      <p>
        一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。
      </p>
      <p>
        接口类型 是由一组方法签名定义的集合。
        接口类型的变量可以保存任何实现了这些方法的值。
      </p>
      <p>
        interface类型定义了一组方法，
        如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。
      </p>
      <p>
        interface可以被任意的对象实现，
        同理，一个对象可以实现任意多个interface。
      </p>
      <p>
        任意的类型都实现了空interface(我们这样定义：interface{})，
        也就是包含0个method的interface。
      </p>
      <pre><code class="language-go">package main
import (
  &quot;fmt&quot;
  &quot;math&quot;
)
type Abser interface {
  Abs() float64
}
type MyFloat float64
type Vertex struct {
  X, Y float64
}
func (f MyFloat) Abs() float64 {
  if f &lt; 0 {
    return float64(-f)
  }
  return float64(f)
}
func (v *Vertex) Abs() float64 {
  return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
func main() {
  var a Abser
  f := MyFloat(-math.Sqrt2)
  v := Vertex{3, 4}
  a = f  // a MyFloat 实现了 Abser
  a = &amp;v // a *Vertex 实现了 Abser

  // 下面一行，v 是一个 Vertex（而不是 *Vertex）
  // 所以没有实现 Abser。
  // a = v

  fmt.Println(a.Abs())
}


//
package main
import &quot;fmt&quot;
type Human struct {
  name string
  age int
  phone string
}
type Student struct {
  Human //匿名字段
  school string
  loan float32
}
type Employee struct {
  Human //匿名字段
  company string
  money float32
}
//Human实现SayHi方法
func (h Human) SayHi() {
  fmt.Printf(&quot;Hi, I am %s you can call me on %s\n&quot;, h.name, h.phone)
}
//Human实现Sing方法
func (h Human) Sing(lyrics string) {
  fmt.Println(&quot;La la la la...&quot;, lyrics)
}
//Employee重载Human的SayHi方法
func (e Employee) SayHi() {
  fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;, e.name,
    e.company, e.phone)
}
// Interface Men被Human,Student和Employee实现
// 因为这三个类型都实现了这两个方法
type Men interface {
  SayHi()
  Sing(lyrics string)
}
func main() {
  mike := Student{Human{&quot;Mike&quot;, 25, &quot;222-222-XXX&quot;}, &quot;MIT&quot;, 0.00}
  paul := Student{Human{&quot;Paul&quot;, 26, &quot;111-222-XXX&quot;}, &quot;Harvard&quot;, 100}
  sam := Employee{Human{&quot;Sam&quot;, 36, &quot;444-222-XXX&quot;}, &quot;Golang Inc.&quot;, 1000}
  tom := Employee{Human{&quot;Tom&quot;, 37, &quot;222-444-XXX&quot;}, &quot;Things Ltd.&quot;, 5000}
  //定义Men类型的变量i
  var i Men
  //i能存储Student
  i = mike
  fmt.Println(&quot;This is Mike, a Student:&quot;)
  i.SayHi()
  i.Sing(&quot;November rain&quot;)
  //i也能存储Employee
  i = tom
  fmt.Println(&quot;This is tom, an Employee:&quot;)
  i.SayHi()
  i.Sing(&quot;Born to be wild&quot;)
  //定义了slice Men
  fmt.Println(&quot;Let&#39;s use a slice of Men and see what happens&quot;)
  x := make([]Men, 3)
  //这三个都是不同类型的元素，但是他们实现了interface同一个接口
  x[0], x[1], x[2] = paul, sam, mike
  for _, value := range x{
    value.SayHi()
  }
}


// 类型通过实现一个接口的所有方法来实现该接口。
// 隐式接口从接口的实现中解耦了定义，
// 这样接口的实现可以出现在任何包中，无需提前准备。
package main
import &quot;fmt&quot;
type I interface {
  M()
}
type T struct {
  S string
}
// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。
func (t T) M() {
  fmt.Println(t.S)
}
func main() {
  // var i I
  // var t T = T{&quot;hello&quot;}
  // i = t
  // i.M()
  var i I = T{&quot;hello&quot;}
  i.M()
}


// 接口也是值。它们可以像其它值一样传递。
// 接口值可以用作函数的参数或返回值。
// 在内部，接口值可以看做包含值和具体类型的元组：
package main
import (
  &quot;fmt&quot;
  &quot;math&quot;
)
type I interface {
  M()
}
type T struct {
  S string
}
type F float64
func (t *T) M() {
  fmt.Println(t.S)
}
func (f F) M() {
  fmt.Println(f)
}
func main() {
  var i I
  i = &amp;T{&quot;Hello&quot;}
  describe(i)
  i.M()

  i = F(math.Pi)
  describe(i)
  i.M()
}
func describe(i I) {
  fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
}
// (&amp;{Hello}, *main.T)
// Hello
// (3.141592653589793, main.F)
// 3.141592653589793


// 即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。
package main
import &quot;fmt&quot;
type I interface {
  M()
}
type T struct {
  S string
}
func (t *T) M() {
  // 处理空指针
  if t == nil {
    fmt.Println(&quot;&lt;nil&gt;&quot;)
    return
  }
  fmt.Println(t.S)
}
func main() {
  var i I
  var t *T

  i = t
  describe(i)
  i.M()

  i = &amp;T{&quot;hello&quot;}
  describe(i)
  i.M()
}
func describe(i I) {
  fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
}
// (&lt;nil&gt;, *main.T)
// &lt;nil&gt;
// (&amp;{hello}, *main.T)
// hello


// nil 接口值既不保存值也不保存具体类型。
package main
import &quot;fmt&quot;
type I interface {
  M()
}
func main() {
  var i I
  describe(i) // (&lt;nil&gt;, &lt;nil&gt;)
  i.M() // runtime error
}
func describe(i I) {
  fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
}



// 任何实现了String方法的类型都能作为参数被fmt.Println调用
package main
import (
  &quot;fmt&quot;
  &quot;strconv&quot;
)
type Human struct {
  name string
  age int
  phone string
}
// 通过这个方法 Human 实现了 fmt.Stringer
func (h Human) String() string {
  return &quot;❰&quot;+h.name+&quot; - &quot;+strconv.Itoa(h.age)+&quot; years -  ✆ &quot; +h.phone+&quot;❱&quot;
}
func main() {
  Bob := Human{&quot;Bob&quot;, 39, &quot;000-7777-XXX&quot;}
  fmt.Println(&quot;This Human is : &quot;, Bob)
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h4 id="空接口">空接口</h4>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go">// 指定了零个方法的接口值被称为 *空接口：*
// 空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）
// 空接口被用来处理未知类型的值。
package main
import &quot;fmt&quot;
func main() {
  var i interface{}
  describe(i)

  i = 42
  describe(i)

  i = &quot;hello&quot;
  describe(i)
}
func describe(i interface{}) {
  fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
}
// (&lt;nil&gt;, &lt;nil&gt;)
// (42, int)
// (hello, string)</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h4 id="接口嵌套">接口嵌套</h4>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go">// 源码包container/heap
type Interface interface {
  // Len is the number of elements in the collection.
  Len() int
  // Less returns whether the element with index i should sort
  // before the element with index j.
  Less(i, j int) bool
  // Swap swaps the elements with indexes i and j.
  Swap(i, j int)
}
type Interface interface {
  sort.Interface //嵌入字段sort.Interface
  Push(x interface{}) //a Push method to push elements into the heap
  Pop() interface{} //a Pop elements that pops elements from the heap
}


// io包下面的 io.ReadWriter
type ReadWriter interface {
  Reader
  Writer
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h4 id="类型断言">类型断言</h4>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go">// 类型断言 提供了访问接口值底层具体值的方式。
// 该语句断言接口值 i 保存了具体类型 T，并将其底层类型为 T 的值赋予变量 t。
// 类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。
package main
import &quot;fmt&quot;
func main() {
  var i interface{} = &quot;hello&quot;

  s := i.(string)
  fmt.Println(s)

  s, ok := i.(string)
  fmt.Println(s, ok)

  f, ok := i.(float64)
  fmt.Println(f, ok)

  f = i.(float64) // 报错(panic)
  fmt.Println(f)
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h4 id="类型选择">类型选择</h4>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go">// 类型选择 是一种按顺序从几个类型断言中选择分支的结构。
// 类型选择中的声明与类型断言 i.(T) 的语法相同，
// 只是具体类型 T 被替换成了关键字 type。
package main
import &quot;fmt&quot;
func do(i interface{}) {
  switch v := i.(type) {
  case int:
    fmt.Printf(&quot;Twice %v is %v\n&quot;, v, v*2)
  case string:
    fmt.Printf(&quot;%q is %v bytes long\n&quot;, v, len(v))
  default:
    fmt.Printf(&quot;I don&#39;t know about type %T!\n&quot;, v)
  }
}
func main() {
  do(21)
  do(&quot;hello&quot;)
  do(true)
}
// 类型判断
package main
import &quot;fmt&quot;
func do(i interface{}) {
  fmt.Printf(&quot;%v, %T\n&quot;,i,i)
}
func main() {
  do(21)
  do(&quot;hello&quot;)
  do(true)
}
// 21, int
// hello, string
// true, bool</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h4 id="Stringer接口">Stringer接口</h4>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go">// fmt 包中定义的 Stringer 是最普遍的接口之一。
// type Stringer interface {
//     String() string
// }
// fmt 包（还有很多包）都通过此接口来打印值。
package main
import &quot;fmt&quot;
type Person struct {
  Name string
  Age  int
}
func (p Person) String() string {
  return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)
}
func main() {
  a := Person{&quot;Arthur Dent&quot;, 42}
  z := Person{&quot;Zaphod Beeblebrox&quot;, 9001}
  fmt.Println(a, z)
}

// 通过让 IPAddr 类型实现 fmt.Stringer 来打印点号分隔的地址。
package main
import &quot;fmt&quot;
type IPAddr [4]byte
// TODO: 给 IPAddr 添加一个 &quot;String() string&quot; 方法
func (ip IPAddr) String() string {
  //var s = &quot;&quot;
  //for _,v := range ip {
  //  fmt.Println(v)
  //  s += string(v)
  //}
  //return s
  return fmt.Sprintf(&quot;%v.%v.%v.%v&quot;, ip[0],ip[1],ip[2],ip[3])
}
func main() {
  hosts := map[string]IPAddr{
    &quot;loopback&quot;:  {127, 0, 0, 1},
    &quot;googleDNS&quot;: {8, 8, 8, 8},
  }
  for name, ip := range hosts {
    fmt.Printf(&quot;%v: %v\n&quot;, name, ip)
  }
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h4 id="error接口">error接口</h4>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <p>Go 程序使用 error 值来表示错误状态。</p>
      <pre><code class="language-go">// type error interface {
//     Error() string
// }
package main
import (
  &quot;fmt&quot;
  &quot;time&quot;
)
type MyError struct {
  When time.Time
  What string
}
func (e *MyError) Error() string {
  return fmt.Sprintf(&quot;at %v, %s&quot;,
    e.When, e.What)
}
func run() error {
  return &amp;MyError{
    time.Now(),
    &quot;it didn&#39;t work&quot;,
  }
}
func main() {
  if err := run(); err != nil {
    fmt.Println(err)
  }
}
// at 2009-11-10 23:00:00 +0000 UTC m=+0.000000001, it didn&#39;t work

// 练习：错误
package main

import (
  &quot;fmt&quot;
  &quot;math&quot;
)
type ErrNegativeSqrt float64
func (e ErrNegativeSqrt) Error() string {
  return fmt.Sprintf(&quot;cannot Sqrt negative number: %v&quot;, float64(e))
}
func Sqrt(x float64) (float64, error) {
  if x&lt;0 {
    return 0.0, ErrNegativeSqrt(x)
  }
  return math.Sqrt(x), nil
}
func main() {
  fmt.Println(Sqrt(2))
  fmt.Println(Sqrt(-2))
}
// 1.4142135623730951 &lt;nil&gt;
// 0 cannot Sqrt negative number: -2</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h4 id="Reader接口">Reader接口</h4>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <p>io 包指定了 io.Reader 接口，它表示从数据流的末尾进行读取。</p>
      <pre><code class="language-go">// 示例代码创建了一个 strings.Reader 并以每次 8 字节的速度读取它的输出。
package main
import (
  &quot;fmt&quot;
  &quot;io&quot;
  &quot;strings&quot;
)
func main() {
  r := strings.NewReader(&quot;Hello, Reader!&quot;)
  b := make([]byte, 8)
  for {
    n, err := r.Read(b)
    fmt.Printf(&quot;n = %v err = %v b = %v\n&quot;, n, err, b)
    fmt.Printf(&quot;b[:n] = %q\n&quot;, b[:n])
    if err == io.EOF {
      break
    }
  }
}
// n = 8 err = &lt;nil&gt; b = [72 101 108 108 111 44 32 82]
// b[:n] = &quot;Hello, R&quot;
// n = 6 err = &lt;nil&gt; b = [101 97 100 101 114 33 32 82]
// b[:n] = &quot;eader!&quot;
// n = 0 err = EOF b = [101 97 100 101 114 33 32 82]
// b[:n] = &quot;&quot;</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h4 id="Image接口">Image接口</h4>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go">package main
import (
  &quot;fmt&quot;
  &quot;image&quot;
)
func main() {
  m := image.NewRGBA(image.Rect(0, 0, 100, 100))
  fmt.Println(m.Bounds())
  fmt.Println(m.At(0, 0).RGBA())
}

// 练习
package main
import (
  &quot;golang.org/x/tour/pic&quot;
  &quot;image/color&quot;
  &quot;image&quot;
)
type Image struct{}  //新建一个Image结构体
func (i Image) ColorModel() color.Model{  //实现Image包中颜色模式的方法
    return color.RGBAModel
}
func (i Image) Bounds() image.Rectangle{  //实现Image包中生成图片边界的方法
    return image.Rect(0,0,200,200)
}
func (i Image) At(x,y int) color.Color{  //实现Image包中生成图像某个点的方法
    return color.RGBA{uint8(x),uint8(y),uint8(255),uint8(255)}
}
func main() {
    m := Image{}
    pic.ShowImage(m)  //调用
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="入口函数">入口函数</h2>
      <p>dart</p>
      <p>
        每个应用都需要有个顶级的 main() 入口方法才能执行。 main() 方法的返回值为
        void 并且有个可选的 <code>List&lt;String&gt;</code> 参数。
      </p>
      <pre><code class="language-dart">void main() {
  querySelector(&quot;#sample_text_id&quot;)
    ..text = &quot;Click me!&quot;
    ..onClick.listen(reverseText);
}

// 下面是一个命令行应用的 main() 方法，并且使用了 方法参数作为输入参数
// Run the app like this: dart args.dart 1 test
void main(List&lt;String&gt; arguments) {
  print(arguments);
  assert(arguments.length == 2);
  assert(int.parse(arguments[0]) == 1);
  assert(arguments[1] == &#39;test&#39;);
}</code></pre>
      <p>go</p>
      <p>
        程序的初始化和执行都起始于main包。 在定义时不能有任何的参数和返回值。
        <code>package main</code>就必须包含一个<code>main</code>函数。
      </p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <h3 id="init函数">init函数</h3>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <p>
        每个源文件都可以通过定义自己的无参数 init 函数来设置一些必要的状态。
        （其实每个文件都可以拥有多个 init 函数。） init
        函数还常被用在程序真正开始执行前，检验或校正程序的状态。
      </p>
      <p><img src="images/init.png" alt="main函数引入包初始化流程图" /></p>
      <pre><code class="language-go">func init() {
  if user == &quot;&quot; {
    log.Fatal(&quot;$USER not set&quot;)
  }
  if home == &quot;&quot; {
    home = &quot;/home/&quot; + user
  }
  if gopath == &quot;&quot; {
    gopath = home + &quot;/go&quot;
  }
  // gopath 可通过命令行中的 --gopath 标记覆盖掉。
  flag.StringVar(&amp;gopath, &quot;gopath&quot;, gopath, &quot;override default GOPATH&quot;)
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="参数">参数</h2>
      <h3 id="可选命名参数">可选命名参数</h3>
      <p>Optional named parameters（可选命名参数）</p>
      <p>dart</p>
      <pre><code class="language-dart">/// Sets the [bold] and [hidden] flags to the values
/// you specify.
enableFlags({bool bold, bool hidden}) {
  // ...
}
enableFlags(bold: true, hidden: false);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">function f({x,y=2}) {
  // ...
}
f({x:1})</code></pre>
      <p>python</p>
      <p>关键字参数</p>
      <pre><code class="language-python"># 接受一个必需的参数（voltage）和三个可选的参数（state, action，和 type）
def parrot(voltage, state=&#39;a stiff&#39;, action=&#39;voom&#39;, type=&#39;Norwegian Blue&#39;):
    print(&quot;-- This parrot wouldn&#39;t&quot;, action, end=&#39; &#39;)
    print(&quot;if you put&quot;, voltage, &quot;volts through it.&quot;)
    print(&quot;-- Lovely plumage, the&quot;, type)
    print(&quot;-- It&#39;s&quot;, state, &quot;!&quot;)
parrot(1000)                                          # 1 positional argument
parrot(voltage=1000)                                  # 1 keyword argument
parrot(voltage=1000000, action=&#39;VOOOOOM&#39;)             # 2 keyword arguments
parrot(action=&#39;VOOOOOM&#39;, voltage=1000000)             # 2 keyword arguments
parrot(&#39;a million&#39;, &#39;bereft of life&#39;, &#39;jump&#39;)         # 3 positional arguments
parrot(&#39;a thousand&#39;, state=&#39;pushing up the daisies&#39;)  # 1 positional, 1 keyword</code></pre>
      <h3 id="可选位置参数">可选位置参数</h3>
      <p>Optional positional parameters（可选位置参数）</p>
      <p>dart</p>
      <p>把一些方法的参数放到 [] 中就变成可选 位置参数了：</p>
      <pre><code class="language-dart">String say(String from, String msg, [String device]) {
  var result = &#39;$from says $msg&#39;;
  if (device != null) {
    result = &#39;$result with a $device&#39;;
  }
  return result;
}
assert(say(&#39;Bob&#39;, &#39;Howdy&#39;) == &#39;Bob says Howdy&#39;);
assert(say(&#39;Bob&#39;, &#39;Howdy&#39;, &#39;smoke signal&#39;) ==
    &#39;Bob says Howdy with a smoke signal&#39;);</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <p>任意的参数列表</p>
      <pre><code class="language-python">def cheeseshop(kind, *arguments, **keywords):
    print(&quot;-- Do you have any&quot;, kind, &quot;?&quot;)
    print(&quot;-- I&#39;m sorry, we&#39;re all out of&quot;, kind)
    for arg in arguments:
        print(arg)
    print(&quot;-&quot; * 40)
    for kw in keywords:
        print(kw, &quot;:&quot;, keywords[kw])

cheeseshop(&quot;Limburger&quot;,
           &quot;It&#39;s very runny, sir.&quot;,
           &quot;It&#39;s really very, VERY runny, sir.&quot;,
           shopkeeper=&quot;Michael Palin&quot;,
           client=&quot;John Cleese&quot;,
           sketch=&quot;Cheese Shop Sketch&quot;)

# -- Do you have any Limburger ?
# -- I&#39;m sorry, we&#39;re all out of Limburger
# It&#39;s very runny, sir.
# It&#39;s really very, VERY runny, sir.
# ----------------------------------------
# shopkeeper : Michael Palin
# client : John Cleese
# sketch : Cheese Shop Sketch</code></pre>
      <pre><code class="language-sh">&gt;&gt;&gt; def concat(*args, sep=&quot;/&quot;):
...     return sep.join(args)
...
&gt;&gt;&gt; concat(&quot;earth&quot;, &quot;mars&quot;, &quot;venus&quot;)
&#39;earth/mars/venus&#39;
&gt;&gt;&gt; concat(&quot;earth&quot;, &quot;mars&quot;, &quot;venus&quot;, sep=&quot;.&quot;)
&#39;earth.mars.venus&#39;</code></pre>
      <h3 id="默认参数值">默认参数值</h3>
      <p>Default parameter values（默认参数值）</p>
      <p>dart</p>
      <p>
        在定义方法的时候，可以使用 = 来定义可选参数的默认值。
        默认值只能是编译时常量。 如果没有提供默认值，则默认值为 null。
      </p>
      <pre><code class="language-dart">/// Sets the [bold] and [hidden] flags to the values you
/// specify, defaulting to false.
void enableFlags({bool bold = false, bool hidden = false}) {
  // ...
}
// bold will be true; hidden will be false.
// 旧版本代码可能需要使用一个冒号 (:) 而不是 = 来设置参数默认值。
// 在以后版本不能使用：，
// Dart SDK 版本为 1.21 或者更高的版本，推荐使用 = 来设置默认值
enableFlags(bold: true);

String say(String from, String msg,
    [String device = &#39;carrier pigeon&#39;, String mood]) {
  var result = &#39;$from says $msg&#39;;
  if (device != null) {
    result = &#39;$result with a $device&#39;;
  }
  if (mood != null) {
    result = &#39;$result (in a $mood mood)&#39;;
  }
  return result;
}
assert(say(&#39;Bob&#39;, &#39;Howdy&#39;) ==
    &#39;Bob says Howdy with a carrier pigeon&#39;);

void doStuff(
    {List&lt;int&gt; list = const [1, 2, 3],
    Map&lt;String, String&gt; gifts = const {
      &#39;first&#39;: &#39;paper&#39;,
      &#39;second&#39;: &#39;cotton&#39;,
      &#39;third&#39;: &#39;leather&#39;
    }}) {
  print(&#39;list:  $list&#39;);
  print(&#39;gifts: $gifts&#39;);
}

// 默认参数必须为const类型
void main() {
  List f({int a, List&lt;int&gt; L = const []}) {
    // var L2 = new List.from(L);
    var L2 = []..addAll(L);
    L2.add(a);
    return L2;
  }
  print(f(a:1));
  print(f(a:2));
  print(f(a:3));
}
// [1]
// [2]
// [3]</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js">function f(a, L=[]) {
  L.push(a);
  return L;
}
console.log(f(1));
console.log(f(2));
console.log(f(3));
// [ 1 ]
// [ 2 ]
// [ 3 ]</code></pre>
      <p>python</p>
      <p>这个函数可以通过几种方式调用:</p>
      <ul>
        <li>只给出必需的参数：ask_ok(&#39;Do you really want to quit?&#39;)</li>
        <li>
          给出一个可选的参数：ask_ok(&#39;OK to overwrite the file?&#39;, 2)
        </li>
        <li>
          或者给出所有的参数：ask_ok(&#39;OK to overwrite the file?&#39;, 2,
          &#39;Come on, only yes or no!&#39;)
        </li>
      </ul>
      <pre><code class="language-python">def ask_ok(prompt, retries=4, reminder=&#39;Please try again!&#39;):
    while True:
        ok = input(prompt)
        if ok in (&#39;y&#39;, &#39;ye&#39;, &#39;yes&#39;): # in 关键字。它可以测试一个序列是否包含某个值。
            return True
        if ok in (&#39;n&#39;, &#39;no&#39;, &#39;nop&#39;, &#39;nope&#39;):
            return False
        retries = retries - 1
        if retries &lt; 0:
            raise ValueError(&#39;invalid user response&#39;)
        print(reminder)

# 默认值是在 定义过程 中在函数定义处计算的，所以
i = 5

def f(arg=i):
    print(arg)

i = 6
f()
# 5

# 默认值为可变对象（列表、字典以及大多数类实例）时
def f(a, L=[]):
    L.append(a)
    return L
print(f(1))
print(f(2))
print(f(3))
# [1]
# [1, 2]
# [1, 2, 3]

# 如果你不想要在后续调用之间共享默认值
def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L</code></pre>
      <h3 id="解包参数列表">解包参数列表</h3>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-sh">&gt;&gt;&gt; list(range(3, 6))            # normal call with separate arguments
[3, 4, 5]
&gt;&gt;&gt; args = [3, 6]
&gt;&gt;&gt; list(range(*args))            # call with arguments unpacked from a list
[3, 4, 5]</code></pre>
      <pre><code class="language-python">def parrot(voltage, state=&#39;a stiff&#39;, action=&#39;voom&#39;):
    print(&quot;-- This parrot wouldn&#39;t&quot;, action, end=&#39; &#39;)
    print(&quot;if you put&quot;, voltage, &quot;volts through it.&quot;, end=&#39; &#39;)
    print(&quot;E&#39;s&quot;, state, &quot;!&quot;)

d = {&quot;voltage&quot;: &quot;four million&quot;, &quot;state&quot;: &quot;bleedin&#39; demised&quot;, &quot;action&quot;: &quot;VOOM&quot;}
parrot(**d)</code></pre>
      <h3 id="变参">变参</h3>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go">// arg ...int告诉Go这个函数接受不定数量的参数。
func myfunc(arg ...int) {}

// 变量arg是一个int的slice：
for _, n := range arg {
  fmt.Printf(&quot;And the number is: %d\n&quot;, n)
}</code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="一等方法对象">一等方法对象</h2>
      <p>dart</p>
      <pre><code class="language-dart">// 可以把方法当做参数调用另外一个方法。
printElement(element) {
  print(element);
}
var list = [1, 2, 3];
// Pass printElement as a parameter.
list.forEach(printElement);

// 方法也可以赋值给一个变量：
var loudify = (msg) =&gt; &#39;!!! ${msg.toUpperCase()} !!!&#39;;
assert(loudify(&#39;hello&#39;) == &#39;!!! HELLO !!!&#39;);</code></pre>
      <p>go</p>
      <ul>
        <li>函数也是值。它们可以像其它值一样传递。</li>
        <li>函数值可以用作函数的参数或返回值。</li>
      </ul>
      <pre><code class="language-go">package main
import (
  &quot;fmt&quot;
  &quot;math&quot;
)
func compute(fn func(float64, float64) float64) float64 {
  return fn(3, 4)
}
func main() {
  hypot := func(x, y float64) float64 {
    return math.Sqrt(x*x + y*y) // 求直角斜边
  }
  fmt.Println(hypot(5, 12))
  fmt.Println(compute(hypot))
  fmt.Println(compute(math.Pow)) // 指数
}
// 13
// 5
// 81



// 函数作为类型
// package main
import &quot;fmt&quot;
type testInt func(int) bool // 声明了一个函数类型
func isOdd(integer int) bool {
  if integer%2 == 0 {
    return false
  }
  return true
}
func isEven(integer int) bool {
  if integer%2 == 0 {
    return true
  }
  return false
}
// 声明的函数类型在这个地方当做了一个参数
func filter(slice []int, f testInt) []int {
  var result []int
  for _, value := range slice {
    if f(value) {
      result = append(result, value)
    }
  }
  return result
}
func main(){
  slice := []int {1, 2, 3, 4, 5, 7}
  fmt.Println(&quot;slice = &quot;, slice)
  odd := filter(slice, isOdd)    // 函数当做值来传递了
  fmt.Println(&quot;Odd elements of slice are: &quot;, odd)
  even := filter(slice, isEven)  // 函数当做值来传递了
  fmt.Println(&quot;Even elements of slice are: &quot;, even)
}</code></pre>
      <p>js</p>
      <pre><code class="language-js">function add(x, y) {
  return x + y;
}

// 将函数赋值给一个变量
var operator = add;

// 将函数作为参数和返回值
function a(op){
  return op;
}
a(add)(1, 1)
// 2</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="匿名函数">匿名函数</h2>
      <p>Anonymous functions（匿名方法）匿名函数</p>
      <p>dart</p>
      <p>
        大部分方法都带有名字，例如 main() 或者 printElement()。
        你有可以创建没有名字的方法，称之为 匿名方法， 有时候也被称为 lambda 或者
        closure 闭包。
      </p>
      <pre><code class="language-dart">var list = [&#39;apples&#39;, &#39;oranges&#39;, &#39;grapes&#39;, &#39;bananas&#39;, &#39;plums&#39;];
list.forEach((i) {
  print(list.indexOf(i).toString() + &#39;: &#39; + i);
});
// 如果方法只包含一个语句，可以使用胖箭头语法缩写。
list.forEach((i) =&gt; print(list.indexOf(i).toString() + &#39;: &#39; + i));</code></pre>
      <p>go</p>
      <pre><code class="language-go">package main
import &quot;fmt&quot;
func main() {
  func() { // 匿名函数
    fmt.Println(&quot;run!&quot;)
  }()
}</code></pre>
      <p>js</p>
      <p>箭头函数有几个使用注意点。</p>
      <ul>
        <li>
          函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
        </li>
        <li>
          不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
        </li>
        <li>
          不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest
          参数代替。
        </li>
        <li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</li>
      </ul>
      <p>不适用场合</p>
      <ul>
        <li>第一个场合是定义对象的方法，且该方法内部包括this。</li>
        <li>第二个场合是需要动态this的时候，也不应使用箭头函数。</li>
      </ul>
      <pre><code class="language-js">var sum = (num1, num2) =&gt; { return num1 + num2; }
let getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });
[1,2,3].map(x =&gt; x * x);
var result = values.sort((a, b) =&gt; a - b);


function Timer() {
  this.s1 = 0;
  this.s2 = 0;
  // 箭头函数
  setInterval(() =&gt; this.s1++, 1000);
  // 普通函数
  setInterval(function () {
    this.s2++;
  }, 1000);
}
var timer = new Timer();
setTimeout(() =&gt; console.log(&#39;s1: &#39;, timer.s1), 3100);
setTimeout(() =&gt; console.log(&#39;s2: &#39;, timer.s2), 3100);
// s1: 3
// s2: 0


// ES6
function foo() {
  setTimeout(() =&gt; {
    console.log(&#39;id:&#39;, this.id);
  }, 100);
}
// ES5
function foo() {
  var _this = this;
  setTimeout(function () {
    console.log(&#39;id:&#39;, _this.id);
  }, 100);
}

// 调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；
// 如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。
const cat = {
  lives: 9,
  jumps: () =&gt; {
    this.lives--;
  }
}
// 点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。
var button = document.getElementById(&#39;press&#39;);
button.addEventListener(&#39;click&#39;, () =&gt; {
  this.classList.toggle(&#39;on&#39;);
});</code></pre>
      <p>python</p>
      <pre><code class="language-python"># 使用一个lambda表达式来返回一个函数
def make_incrementor(n):
    return lambda x: x + n
f = make_incrementor(42)

# 传递一个小函数作为参数
pairs = [(1, &#39;one&#39;), (2, &#39;two&#39;), (3, &#39;three&#39;), (4, &#39;four&#39;)]
pairs.sort(key=lambda pair: pair[1])
# [(4, &#39;four&#39;), (1, &#39;one&#39;), (3, &#39;three&#39;), (2, &#39;two&#39;)]</code></pre>
      <h2 id="函数标注">函数标注</h2>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python">def f(ham: str, eggs: str = &#39;eggs&#39;) -&gt; str:
    print(&quot;Annotations:&quot;, f.__annotations__)
    print(&quot;Arguments:&quot;, ham, eggs)
    return ham + &#39; and &#39; + eggs

f(&#39;spam&#39;)</code></pre>
      <h2 id="作用域">作用域</h2>
      <p>Lexical scope（静态作用域）</p>
      <p>dart</p>
      <p>
        Dart 是静态作用域语言，变量的作用域在写代码的时候就确定过了。
        基本上大括号里面定义的变量就 只能在大括号里面访问，和 Java 作用域 类似。
      </p>
      <pre><code class="language-dart">var topLevel = true;
main() {
  var insideMain = true;
  myFunction() {
    var insideFunction = true;
    nestedFunction() {
      var insideNestedFunction = true;
      assert(topLevel);
      assert(insideMain);
      assert(insideFunction);
      assert(insideNestedFunction);
    }
  }
}</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="闭包">闭包</h2>
      <p>Lexical closures（词法闭包）</p>
      <p>dart</p>
      <p>
        一个 闭包 是一个方法对象， 不管该对象在何处被调用，
        该对象都可以访问其作用域内 的变量。 方法可以封闭定义到其作用域内的变量。
      </p>
      <pre><code class="language-dart">// makeAdder() 捕获到了变量 addBy。
// 不管你在那里执行 makeAdder() 所返回的函数，都可以使用 addBy 参数
/// Returns a function that adds [addBy] to the
/// function&#39;s argument.
Function makeAdder(num addBy) {
  return (num i) =&gt; addBy + i;
}

main() {
  // Create a function that adds 2.
  var add2 = makeAdder(2);

  // Create a function that adds 4.
  var add4 = makeAdder(4);

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}</code></pre>
      <p>go</p>
      <p>
        闭包是一个函数值，它引用了其函数体之外的变量。
        该函数可以访问并赋予其引用的变量的值，
        换句话说，该函数被这些变量“绑定”在一起。
      </p>
      <pre><code class="language-go">// squares返回一个匿名函数。
// 该匿名函数每次被调用时都会返回下一个数的平方。
func squares() func() int {
  var x int
  return func() int {
    x++
    return x * x
  }
}
func main() {
  f := squares()
  fmt.Println(f()) // &quot;1&quot;
  fmt.Println(f()) // &quot;4&quot;
  fmt.Println(f()) // &quot;9&quot;
  fmt.Println(f()) // &quot;16&quot;
}


package main
import &quot;fmt&quot;
func adder() func(int) int { // 返回：func(int) int
  sum := 0
  return func(x int) int { // 返回：int
    sum += x
    return sum
  }
}
func main() {
  pos, neg := adder(), adder()
  for i := 0; i &lt; 10; i++ {
    fmt.Println(
      pos(i),
      neg(-2*i),
    )
  }
}
// 0 0
// 1 -2
// 3 -6
// 6 -12
// 10 -20
// 15 -30
// 21 -42
// 28 -56
// 36 -72
// 45 -90


package main
import &quot;fmt&quot;
// 返回一个“返回int的函数”
func fibonacci() func() int {
  var n int
  x,y := 0,1
  return func() int {
    n = x
    x,y = y,x+y
    return n
  }
}
func main() {
  f := fibonacci()
  for i := 0; i &lt; 10; i++ {
    fmt.Println(f())
  }
}
// 0
// 1
// 1
// 2
// 3
// 5
// 8
// 13
// 21
// 34</code></pre>
      <p>js</p>
      <pre><code class="language-js">function f1() {
  var n = 999;
  function f2() {
    console.log(n);
  }
  return f2;
}
var result = f1();
result(); // 999


function createIncrementor(start) {
  return function () {
    return start++;
  };
}
var inc = createIncrementor(5);
inc() // 5
inc() // 6
inc() // 7


function Person(name) {
  var _age;
  function setAge(n) {
    _age = n;
  }
  function getAge() {
    return _age;
  }
  return {
    name: name,
    getAge: getAge,
    setAge: setAge
  };
}
var p1 = Person(&#39;张三&#39;);
p1.setAge(25);
p1.getAge() // 25</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="测试函数是否相等">测试函数是否相等</h2>
      <p>Testing functions for equality（测试函数是否相等）</p>
      <p>dart</p>
      <pre><code class="language-dart">foo() {}               // A top-level function

class A {
  static void bar() {} // A static method
  void baz() {}        // An instance method
}

main() {
  var x;

  // Comparing top-level functions.
  x = foo;
  assert(foo == x);

  // Comparing static methods.
  x = A.bar;
  assert(A.bar == x);

  // Comparing instance methods.
  var v = new A(); // Instance #1 of A
  var w = new A(); // Instance #2 of A
  var y = w;
  x = w.baz;

  // These closures refer to the same instance (#2),
  // so they&#39;re equal.
  assert(y.baz == x);

  // These closures refer to different instances,
  // so they&#39;re unequal.
  assert(v.baz != w.baz);
}</code></pre>
      <p>go</p>
      <pre><code class="language-go"></code></pre>
      <p>js</p>
      <pre><code class="language-js"></code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
      <h2 id="立即调用的函数表达式">立即调用的函数表达式</h2>
      <p>（IIFE）</p>
      <p>dart</p>
      <pre><code class="language-dart"></code></pre>
      <p>go</p>
      <pre><code class="language-go">package main
import &quot;fmt&quot;
func main() {
  func() {
    fmt.Println(&quot;run!&quot;)
  }()
}</code></pre>
      <p>js</p>
      <pre><code class="language-js">(function(){ /* code */ }());
// 或者
(function(){ /* code */ })();</code></pre>
      <p>python</p>
      <pre><code class="language-python"></code></pre>
    </div>
    <script src="./highlight/highlight.pack.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>
