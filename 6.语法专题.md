# 语法专题

## Generics（泛型）

dart

如果你查看 List 类型的 API 文档， 则可以看到 实际的类型定义为 List<E>。
这个 <…> 声明 list 是一个 泛型 (或者 参数化) 类型。
通常情况下，使用一个字母来代表类型参数， 例如 E, T, S, K, 和 V 等。

```dart
// 一个保存缓存对象 的接口
abstract class ObjectCache {
  Object getByKey(String key);
  setByKey(String key, Object value);
}
// 一个用来缓存字符串的实现
abstract class StringCache {
  String getByKey(String key);
  setByKey(String key, String value);
}
// 泛型可以避免这种重复的代码。 你只需要创建一个接口即可：
abstract class Cache<T> {
  T getByKey(String key);
  setByKey(String key, T value);
}
// 在上面的代码中，T 是一个备用类型。
// 这是一个类型占位符， 在开发者调用该接口的时候会指定具体类型。
```

go

```go
```

js

```js
```

python

```python
```

## Using collection literals（使用集合字面量）

dart

List 和 map 字面量也是可以参数化的。
参数化定义 list 需要在中括号之前 添加 <type> ，
定义 map 需要在大括号之前 添加 <keyType, valueType>。

```dart
var names = <String>['Seth', 'Kathy', 'Lars'];
var pages = <String, String>{
  'index.html': 'Homepage',
  'robots.txt': 'Hints for web robots',
  'humans.txt': 'We are people, not machines'
};
```

go

```go
```

js

```js
```

python

```python
```

## Using parameterized types with constructors（在构造函数中使用泛型）

dart

```dart
var names = new List<String>();
names.addAll(['Seth', 'Kathy', 'Lars']);
var nameSet = new Set<String>.from(names);

// 下面代码创建了一个 key 为 integer， value 为 View 类型 的 map：
var views = new Map<int, View>();
```

go

```go
```

js

```js
```

python

```python
```

## 泛型判断

dart

Dart 的泛型类型是固化的，在运行时也 可以判断具体的类型。

```dart
var names = new List<String>();
names.addAll(['Seth', 'Kathy', 'Lars']);
print(names is List<String>); // true
```

go

```go
```

js

```js
```

python

```python
```

## Restricting the parameterized type（限制泛型类型）

dart

```dart
// T must be SomeBaseClass or one of its descendants.
class Foo<T extends SomeBaseClass> {...}

class Extender extends SomeBaseClass {...}

void main() {
  // It's OK to use SomeBaseClass or any of its subclasses inside <>.
  var someBaseClassFoo = new Foo<SomeBaseClass>();
  var extenderFoo = new Foo<Extender>();

  // It's also OK to use no <> at all.
  var foo = new Foo();

  // Specifying any non-SomeBaseClass type results in a warning and, in
  // checked mode, a runtime error.
  // var objectFoo = new Foo<Object>();
}
```

go

```go
```

js

```js
```

python

```python
```

## Using generic methods（使用泛型函数）

dart

一开始，泛型只能在 Dart 类中使用。 新的语法也支持在函数和方法上使用泛型了。

这里的 first (<T>) 泛型可以在如下地方使用 参数 T ：

- 函数的返回值类型 (T).
- 参数的类型 (List<T>).
- 局部变量的类型 (T tmp).


```dart
T first<T>(List<T> ts) {
  // ...Do some initial work or error checking, then...
  T tmp ?= ts[0];
  // ...Do some additional checking or processing...
  return tmp;
}
```

go

```go
```

js

```js
```

python

```python
```

## Asynchrony support（异步支持）

dart

异步编程通常使用回调函数，但是 Dart 提供了另外的 选择： Future 和 Stream 对象。
Future 和 JavaScript 中的 Promise 类似，
代表在将来某个时刻会返回一个 结果。
Stream 是一种用来获取一些列数据的方式，例如 事件流。

在 Dart 库中随处可见 Future 对象，通常异步函数返回的对象就是一个 Future。

Dart 库中有很多返回 Future 或者 Stream 对象的方法。
这些方法是 异步的： 这些函数在设置完基本的操作 后就返回了， 而无需等待操作执行完成。

Stream 在 Dart API 中也经常出现，代表一些列数据。
例如， HTML 按钮点击事件就可以使用 stream 来表示。
还可以把读取文件内容当做一个 Stream。

有两种方式可以使用 Future 对象中的 数据：

- 使用 async 和 await
- 使用 Future API

`Future` 类似js中的 `Promise`

```dart
// 要使用 await，其方法必须带有 async 关键字：
checkVersion() async {
  var version = await lookUpVersion();
  if (version == expectedVersion) {
    // Do something.
  } else {
    // Do something else.
  }
}
// 可以使用 try, catch, 和 finally 来处理使用 await 的异常：
try {
  server = await HttpServer.bind(InternetAddress.LOOPBACK_IP_V4, 4044);
} catch (e) {
  // React to inability to bind to the port...
}

// 使用 then() 可以在 Future 完成的时候执行其他代码 来解析返回的数据：
HttpRequest.getString(url).then((String result) {
  print(result);
});
// Should handle errors here.

// 使用 catchError() 来处理 Future 对象可能抛出的 各种异常和错误：
HttpRequest.getString(url).then((String result) {
  print(result);
}).catchError((e) {
  // Handle or ignore the error.
});


// then() 函数返回值为 Future，可以把多个异步调用给串联起来。
// 如果 then() 函数注册的回调函数也返回一个 Future，而 then() 返回一个同样的 Future。
// 如果回调函数返回的是一个其他类型的值， 则 then() 会创建一个新的 Future 对象 并完成这个 future。
Future result = costlyQuery();
return result.then((value) => expensiveWork())
             .then((value) => lengthyComputation())
             .then((value) => print('done!'))
             .catchError((exception) => print('DOH!'));

// 要想在每个数据到达的时候就去处理，则可以选择使用 await for 或者 使用 listen() 函数来订阅事件：
// Find a button by ID and add an event handler.
querySelector('#submitInfo').onClick.listen((e) {
  // When the button is clicked, it runs this code.
  submitData();
});

// 经常你需要先转换 stream 里面的数据才能使用。
// 使用 transform() 函数可以生产另外一个数据类型 的 Stream 对象：
var stream = inputStream
    .transform(UTF8.decoder)
    .transform(new LineSplitter());
// 上面的代码使用两种转换器（transformer）。
// 第一个使用 UTF8.decoder 来把整数类型的数据流转换为字符串类型的数据流。
// 然后使用 LineSplitter 把字符串类型数据流转换为按行分割的数据流。
```

go

```go
```

js

```js
```

python

```python
```

## Declaring async functions（声明异步方法）

dart

一个 async 方法 是函数体被标记为 async 的方法。

```dart
checkVersion() async {
  // ...
}
lookUpVersion() async => /* ... */;

// 下面是一个返回字符串 的同步方法
String lookUpVersionSync() => '1.0.0';
// 如果使用 async 关键字，则该方法 返回一个 Future，并且 认为该函数是一个耗时的操作。
// 方法的函数体并不需要使用 Future API。 Dart 会自动在需要的时候创建 Future 对象
Future<String> lookUpVersion() async => '1.0.0';
```

go

```go
```

js

```js
```

python

```python
```

## Using await expressions with Futures（使用 await 表达式）

dart

在 await expression 中， expression 的返回值通常是一个 Future；
如果返回的值不是 Future，则 Dart 会自动把该值放到 Future 中返回。
Future 对象代表返回一个对象的承诺（promise）。
await expression 执行的结果为这个返回的对象。
await expression 会阻塞住，直到需要的对象返回为止。

如果 await 无法正常使用，请确保是在一个 async 方法中。
例如要在 main() 方法中使用 await， 则 main() 方法的函数体必须标记为 async：

 异步方法（带有关键字 async 的方法）会返回 Future。
 如果你不想让你的方法返回 future，则 不要使用 async 关键字。
 例如，你可以在你的方法里面调用一个 异步方法。

```dart
var entrypoint = await findEntrypoint();
var exitCode = await runExecutable(entrypoint, args);
await flushThenExit(exitCode);

main() async {
  checkVersion();
  print('In main: version is ${await lookUpVersion()}');
}

// 使用 Future 的 then() 函数来 执行三个异步方法， 每个方法执行完后才继续执行后一个方法。
runUsingFuture() {
  //...
  findEntrypoint().then((entrypoint) {
    return runExecutable(entrypoint, args);
  }).then(flushThenExit);
}
// 下面是使用 await 表达式实现的同样功能的代码， 看起来更像是同步代码，更加容易理解：
runUsingAsyncAwait() async {
  //...
  var entrypoint = await findEntrypoint();
  var exitCode = await runExecutable(entrypoint, args);
  await flushThenExit(exitCode);
}
// 异步方法可以把 Future 中的错误当做 异常来处理。 例如：
attached() async {
  super.attached();
  try {
    await appObject.start();
  } catch (e) {
    //...handle the error...
  }
}
```

go

```go
```

js

```js
```

python

```python
```

## Using asynchronous for loops with Streams（在循环中使用异步）

dart

```dart
main() async {
  ...
  await for (var request in requestServer) {
    handleRequest(request);
  }
  ...
}

// 使用 Stream 的 listen() 函数来订阅 一些文件，然后使用一个方法参数来 搜索每个文件和目录。
void main(List<String> arguments) {
  // ...
  FileSystemEntity.isDirectory(searchPath).then((isDir) {
    if (isDir) {
      final startingDir = new Directory(searchPath);
      startingDir
          .list(
              recursive: argResults[RECURSIVE],
              followLinks: argResults[FOLLOW_LINKS])
          .listen((entity) {
        if (entity is File) {
          searchFile(entity, searchTerms);
        }
      });
    } else {
      searchFile(new File(searchPath), searchTerms);
    }
  });
}
// 下面是使用 await 表达式和异步 for 循环 实现的等价的代码， 看起来更像是同步代码：
main(List<String> arguments) async {
  // ...
  if (await FileSystemEntity.isDirectory(searchPath)) {
    final startingDir = new Directory(searchPath);
    await for (var entity in startingDir.list(
        recursive: argResults[RECURSIVE],
        followLinks: argResults[FOLLOW_LINKS])) {
      if (entity is File) {
        searchFile(entity, searchTerms);
      }
    }
  } else {
    searchFile(new File(searchPath), searchTerms);
  }
}
```

go

```go
```

js

```js
```

python

```python
```

## 并发/同时触发

dart

```dart
// 使用 Future.wait() 这个静态函数来管理多个 Future 并等待所有 Future 执行完成。
Future deleteDone = deleteLotsOfFiles();
Future copyDone = copyLotsOfFiles();
Future checksumDone = checksumLotsOfOtherFiles();

Future.wait([deleteDone, copyDone, checksumDone])
    .then((List values) {
      print('Done with all the long steps');
    });
```

go

```go
```

js

```js
```

python

```python
```

## 异步的错误捕获

dart

```dart
// 在 stream 关闭后执行的代码位于异步 for 循环 之后。
readFileAwaitFor() async {
  var config = new File('config.txt');
  Stream<List<int>> inputStream = config.openRead();

  var lines = inputStream
      .transform(UTF8.decoder)
      .transform(new LineSplitter());
  try {
    await for (var line in lines) {
      print('Got ${line.length} characters from stream');
    }
    print('file is now closed');
  } catch (e) {
    print(e);
  }
}

// 如果你使用 Stream API，则需要 使用 onError 函数来处理异常。
// stream 完成后执行的代码要通过 onDone 函数 来执行。
var config = new File('config.txt');
Stream<List<int>> inputStream = config.openRead();
inputStream
    .transform(UTF8.decoder)
    .transform(new LineSplitter())
    .listen((String line) {
      print('Got ${line.length} characters from stream');
    }, onDone: () {
      print('file is now closed');
    }, onError: (e) {
      print(e);
    });
```

go

```go
```

js

```js
```

python

```python
```

## 生成器

dart

```dart
```

go

```go
```

js

```js
```

python

Generator 是一个用于创建迭代器的简单而强大的工具。
它们的写法类似标准的函数，但当它们要返回数据时会使用 yield 语句。
每次对生成器调用 next() 时，
它会从上次离开位置恢复执行（它会记住上次执行语句时的所有数据值）。

```python
def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]
for char in reverse('golf'):
    print(char)
# f
# l
# o
# g

# 某些简单的生成器可以写成简洁的表达式代码，
# 所用语法类似列表推导式，将外层为圆括号而非方括号。
sum(i*i for i in range(10))
```

## Metadata（元数据）注解/装饰器

dart

使用元数据给你的代码添加其他额外信息。
元数据注解是以 @ 字符开头，后面是一个编译时 常量(例如 deprecated)或者 调用一个常量构造函数。

有三个注解所有的 Dart 代码都可以使用： @deprecated、 @override、 和 @proxy。

```dart
lass Television {
  /// _Deprecated: Use [turnOn] instead._
  // 表示弃用此函数
  @deprecated
  void activate() {
    turnOn();
  }

  /// Turns the TV's power on.
  void turnOn() {
    print('on!');
  }
}

// 你还可以定义自己的元数据注解。
// 下面的示例定义了一个带有两个参数的 @todo 注解：
library todo;
class todo {
  final String who;
  final String what;
  const todo(this.who, this.what);
}
// 使用 @todo 注解的示例：
import 'todo.dart';
@todo('seth', 'make this do something')
void doSomething() {
  print('do something');
}
```

go

```go
```

js

```js
```

python

```python

```

## Regular expressions（正则表达式）

dart

```dart
// Here's a regular expression for one or more digits.
var numbers = new RegExp(r'\d+');

var allCharacters = 'llamas live fifteen to twenty years';
var someDigits = 'llamas live 15 to 20 years';

// contains() can use a regular expression.
assert(!allCharacters.contains(numbers));
assert(someDigits.contains(numbers));

// Replace every match with another string.
var exedOut = someDigits.replaceAll(numbers, 'XX');
assert(exedOut == 'llamas live XX to XX years');

// 还可以直接操作 RegExp 类。
// Match 类提供了 访问正则表达式匹配到的内容。
var numbers = new RegExp(r'\d+');
var someDigits = 'llamas live 15 to 20 years';

// Check whether the reg exp has a match in a string.
assert(numbers.hasMatch(someDigits));

// Loop through all matches.
for (var match in numbers.allMatches(someDigits)) {
  print(match.group(0)); // 15, then 20
}
```

go

```go
```

js

```js
```

python

```python
import re
re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')
# 只需要简单的功能时，首选字符串方法
'tea for too'.replace('too', 'two')
```
